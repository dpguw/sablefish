% RELAX: R Editor for Literate Analysis and lateX / Copyright (C) 2005 Hans Peter Wolf
% --------------------------------------------------------------------------
% steps to create a new relax-version: 
% a) Datum/Version in RELAX-Chunk: "Version von [[relax]]" 
% b) "Nr" UND "DATUM" in RELAX-Chunk: "define-DESCRIPTION", 
% c) aktualisiere RELAX-Chunk: "define-dorx"
% d) Nr in Datei "install.dir/dorx":     
%            notangle -Rdefine-dorx relax.rev > install.dir/dorx; chmod +x install.dir/dorx
% e) $HOME/R/work/install.dir/dorx   starten 
% f) cp install.dir/relax_1.3.13.*  
%          http://www.wiwi.uni-bielefeld.de/fileadmin/stat/wolf/SOFTWARE/relax_1.3.13.*
% g) upload to cran:
%    1. mailto:  cran@r-project.org: subject: CRAN submission relax 1.3.13
%    2a. upload by konquerer!! 
%          ftp://CRAN.R-project.org/incoming/ 
%    2b. upload by ftp
%          ftp ftp://cran.R-project.org/incoming/
%          ftp> put relax_1.3.13.tar.gz
%          ftp> bye   
% ==========================================================
% Paketverteilung fuer Rechner: 138/20/21/102: 
%   cd /usr/lib/R/library/relax; 
%   cp -rp $HOME/R/work/relax/install.dir/lib/relax/* .
% ==========================================================
% Pakettest:
%   cd /home/wiwi/pwolf/work/relax
%   echo "library(relax,,,'lib'); relax()" | R --vanilla
%   library(relax,lib.loc="/home/wiwi/pwolf/R/work/relax/install.dir/lib");relax()
% Paketerstellung:
%   cd /home/wiwi/pwolf/work/relax
%   notangle relax.rev > $HOME/work/relax/install.dir/relax/R/relax.R
%   R CMD check relax;  R CMD build relax
%   R CMD INSTALL --library=lib relax_0.991.tar.gz
%   cd lib; zip -r relax.zip relax
% Paketbeschaffung über Netz:
%   download.file(
%     "http://www.wiwi.uni-bielefeld.de/fileadmin/stat/wolf/SOFTWARE/relax_1.3.13.tar.gz",
%     "relax_1.3.13.tar.gz")
% Dokumentationserstellung:
%   cd /home/wiwi/pwolf/work/relax
%   noweave -delay -index relax.rev > relax.tex; latex relax
%   save.window data; save.window wizardry; save.window options; save.window edit; save.window file
%   convert file.jpg file.ps; convert edit.jpg edit.ps; convert options.jpg options.ps; convert data.jpg data.ps
%   convert methods.jpg methods.ps; convert wizardry.jpg wizardry.ps
% Vorarbeiten:
%   notangle -RLaTeX-head relax.rev > $HOME/work/relax/install.dir/relax/inst/lib/LaTeX-head.tex
% Kommentare zu Changes
% SavePlot:  Neuerstellung: show.single.plot,  Aktualisieren unter Edit eintragen, sonst  
%                                              Aufrufparameter beachten
% to do: Leerzeile als Trennzeichen nach CODE?
% done: xtable bei output, sliderfns neu, log-Ausschnitt ins gelbe Fenster?, tcl(update)
% Mai 2006:  Umlaute und UTF-8 fuer relax ok, weaven: zu tun!
% Jan 2006: 1. TcltoWin.write, 2. Sweave-Test-Knopf (Argumente noch fraglich)
% fuer R-2.3.0: tkcmd() gegen tcl(...) getauscht
% Problem: MAC: Zwischenspeicher nicht mit Tcl/Tk kompatibel?? ok
% Problem: MAC: Klicks nicht immer erfolgreich, erst nach Bereichswechsel ok
% Codeausblendmechanismus??
% Warnungsmechanismus von R-2.4.0 beachten
% UTF-Fehlervermeidung (Berwin)
% Farbsetzung innerhalb von Codechunks verbessert
% webRweave eingebaut
% configurierbare Hoehe
% Klammernmatchanzeige 4.7.2006
% Objektnamensexpansion 30.6.2006
% Sweave mit LaTeX und ueberschreiben von filename.rnw
%
% Changes:
% 051219: selection in entry widget; webR: undefined chunks
% LaTeX.head erweitert
% UNDO OPTION!!!!: % text .t; pack .t; .t configure -undo 1
% Strg PageDown:   tkmark.set(tworkwin, "insert", "end") zur Platzierung des Cursors. ab 1.02: abgeschaltet
% TO DO - DONE - LIST
%  ?? suchen und ersetzen??
%  ?? wiederholte Code-Chunk-Beginns ohne @ zulassen??
%      headmenufunktionen pruefen
%      Umlaute testen / auch unter windows
%      Plots nur im sichtbaren Bereich einbinden / rein / raus?
%  ?? connections - input/output
%  ?? mehrfache Aktivierungen!?, sowie Numerierungen (eher nein)?,
%  ?? Texte german - Englisch anpassen
\documentclass[twoside]{article}
\usepackage{graphicx}
  \usepackage{gnoweb}% \usepackage[roman8]{inputenc}
  \noweboptions{webnumbering,smallcode,longchunks,longxref}\language1
 \usepackage[T1]{fontenc}
 \input{uml-ok.tex}  % \newcommand{\includegraphics}[1]{{#1}} %win
 \def\nwendcode{\endtrivlist\endgroup\vfil\penalty10\vfilneg}\let\nwdocspar=\smallbreak
\sloppy\newcommand{\kannweg}[1]{\relax} \textheight=25cm\topmargin=-3cm\oddsidemargin=0mm\evensidemargin=0mm
\textwidth=165mm \parindent=0mm
\begin{document} \renewcommand{\contentsname}{Inhaltsverzeichnis}
\title{[[relax]] --- eine Oberfläche für R\\implementiert mittels [[Tcl/Tk]]}
\author{H. P. Wolf}\date{[[pwd:pwolf/work/relax/relax.rev]], Druck: \today} \maketitle



@
%% ============================================================== %% neue Versionen: ändere auch "
" in "install.dir" sowie Chunk unten: define-DESCRIPTION
<<Version von [[relax]]>>=
"relax 1.3.13 - 130408"
@
<<relax>>=
"relax"

@
<<testerei>>=
R --vanilla
library(relax,lib.loc="/home/pwolf/R/work/relax/install.dir/lib")
relax(out) #(out)

@
\tableofcontents
%% library(relax,lib.loc="lib"); relax()

@
\paragraph{General Remarks}
Some windows versions use some ingredients of
\begin{itemize}
\item[noweb] [[ / noweb.sty]]: system of Norman Ramsey
--- [[http://www.eecs.harvard.edu/~nr/noweb/intro.html]]%
--- but not version relax 1.1 and newer
\footnote{
Noweb is copyright 1989-1999 by Norman Ramsey. All rights reserved.
You may use and distribute noweb for any purpose, for free. You may modify noweb and create derived works,
provided you retain the copyright notice, but the result may not be called noweb without my written consent.
You may do anything you like with programs created with noweb. You may even sell noweb itself, for example,
as part of a CD-ROM distribution, provided that what you sell is the true, complete, and unmodified noweb.)}
\item[img:] of Jan Nijtmans --- not included in versions 121212++
    [[http://members.chello.nl/~j.nijtmans/img.html]] or
    [[http://home.kpnplanet.nl/~J.Nijtmans@kpnplanet.nl/img.html]]
    [[http://tkimg.sourceforge.net/, the package is found on]],
    [[http://sourceforge.net/projects/tkimg/files/]],
    [[http://sourceforge.net/projects/tkimg]],%
    [[http://www.posoft.de/html/extTkImg.html]]. % mit binaries for MAC/Linux
    -- the img package has to install additionally
\footnote{Copyright (c) 1995-2003 Jan Nijtmans [[<nijtmans@users.sourceforge.com>]]\\
  see: [[http://sourceforge.net/docman/display_doc.php?docid=6025&group_id=1]],\\
  [[http://www.opensource.org/docs/definition.php]],\\
  [[http://aspn.activestate.com/ASPN/docs/ActiveTcl/img/doc/img.html]]\\
  [[http://aspn.activestate.com/ASPN/docs/ActiveTcl/at.license.html]]}
The license terms concerning the img package are found in the source file of the package, see:
[[relax/src/tkimg1.3.tar.gz]].
\item[gawk:] --- [[http://www.gnu.org/software/gawk/gawk.html]] --- only older versions of relax %
\footnote{
    gawk is GNU: This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Here you get the text via internet: http://www.gnu.org/licenses/gpl.txt
}
\end{itemize}

@
\section{Ziel und Weg}
Dieser Full-Screen-Editor soll
\begin{itemize}
\item
einen reportorientierten Arbeitsstil,
\item
den Umgang mit wiederbelebbaren Papieren,
\item
die Erstellung von wiederbelebbaren Materialien
\end{itemize}
unterstützen.
Das Erscheinungsbild, die Mächtigkeit und die nötigen Arbeitsschritte
sollen dabei so sein, daß sowohl der Anfänger als
auch der Fortgeschrittene auf seine Kosten kommt. Viele der hier angebotenen
zentralen Funktionalitäten entsprechen denen
der Funktion {\sc revive} bzw.\ der R-Bibliothek {\sc rrevive}.
Hinzugekommen ist eine neue Oberfläche. Diese zeigt
dem Anwender die Arbeitsdokumente direkt an und gestattet es,
in den Dokumenten zu navigieren und in ihnen zu arbeiten.
Weitere einleitende Bemerkungen sind dem Papier
zum Reportmanager zu entnehmen.


@
\section{Evaluierung von Anweisungen}

@
\subsection{Einfachste Arbeitsform}

Es sollte möglich sein,
quick and dirty mit Datensätzen herumzuspielen und gegebenenfalls
einige Service-Funktionen der Oberfläche in Anspruch zu nehmen.
Mit diesen Funktionen könnten zum Beispiel
Zugriffe auf zurückliegende Anweisungen
erleichtert werden, und es sind Funktionen denkbar, die nach
Themenberei\-chen geordnet dem Anwender zu dem richtigen Einsatz von
statistischen Funktionen hinführen --- die Hilfen anbieten.

@
\subsection{Sprachelemente}

\subsubsection{Arbeitsfenster: [[workwin]]}
Absolut notwendig für die Ausführung statistischer Arbeitsschritte ist ein
Texteingabefeld, in dem der Anwender seine Gedanken und Anweisungen
niederschreiben kann und in das die berechneten Ergebnisse ausgegeben werden.
Texte werden --- wie allgemein üblich ---
über Tastatur in das Eingabefeld eingebracht.
Dieses Fenster wird im Folgenden {\em Arbeitsfenster} genannt.
Wie beim normalen Schreiben soll das Textfeld nur nach unten hin
verlängern werden. Nach einem Beschreibungstext, auch Text-Chunk genannt,
folgt ein Abschnitt mit auszuführenden Anweisungen, die dem Interpreter zur
Auswertung übergeben werden.

Nach der Evaluierung der Anweisungen (des Code-Chunk)
werden die Ergebnisse in einem zweiten Textfenster,
dem Output-Fenster, an die dort schon befindlichen Einträge angefügt.
Auf Wunsch können diese Ergebnisse in das Arbeitsfenster übernommen werden.
Damit besteht der Inhalt des Arbeitsfensters aus einer
Aneinanderreihung von Anwender-Texten, Anweisungen für R und
Berechnungsergebnissen. Es ist zweckmäßig, Anweisungen und Ergebnisse als
unterschiedliche Qualitäten deutlich von einander abzugrenzen.
Anders formuliert bedarf es bestimmter Sprachelemente, damit
Anwender aber auch die verarbeitenden Werkzeuge
die unterschiedlichen Typen passend verstehen. Hierfür gelten folgende
Regeln\footnote{Diese Regeln gehen wesentlich auf die
Regeln des [[noweb]]-Systems zurück, das
zur Unterstützung des literaten Programmierstils entworfen wurde.}.

@
\paragraph{Beginn eines Text-Chunks.}
Ein [[@]]-Zeichen am Beginn einer Zeile als einziges Zeichen
leitet einen Textabschnitt oder Text-Chunk ein.
Text-Chunks sind also die Einheiten, die die Gedanken in verbaler
Form aufnehmen.
@
\paragraph{Abgrenzung von Ergebnissen.}
Übernommene
Ergebnisse werden in Form eines Text-Chunk abgelegt, wobei sie zusätzlich
durch die Zeichenketten \verb+output-start+ und \verb+output-end+ umklammert
werden.
@
\paragraph{Abgrenzung von Anweisungsfolgen.}
Zusammen auszuführende Anweisungssequenzen müssen
durch die Zeichenkette \verb+@<<*>>=+ eingeleitet werden.
Damit erhält die Lösung der Hello-World-Print-Aufgabe folgende Gestalt.
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+print("Hello World")+
\end{quote}

@
Mit dem Beginn des nächsten
Text-Chunks oder spätestens mit dem Ende des Arbeitsfeldes
endet der sogenannte Code-Chunk. Die auszuwertenden Zeilen befinden
sich also zwischen dem Code-Chunk-Namen und dem nächsten [[@]] oder
dem Textfeldende.
Nach der Auswertung wird das Ergebnis im Outputfeld angezeigt und kann
übernommen werden, so dass im Arbeitsfeld zu sehen ist:
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+output-start+\\
\verb+Hello World+\\
\verb+output-end+
\end{quote}

@
Hiernach lassen sich weitere Gedanken anfügen, die jeweils wieder mit einem
alleinstehenden [[@]] eingeleitet werden (sollten).
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+output-start+\\
\verb+Hello World+\\
\verb+output-end+
\verb+@+\\
\verb+... neuer Gedanke ...+
\end{quote}

@
Der Code-Chunk-Name [[*]] kann durch einen sprechenden
Name ersetzt werden. Hierdurch kann der
Code über den Namen referenziert werden, d.h.\
in einer anderen Code-Sequenz verwendet werden.
Es ist zu beachten, daß der {\em Name} des Code-Chunk
keine Zeilenumbrüche enthalten darf:
\begin{quote}
{\small
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<drucke "Hello World" aus>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+Im Rahmen der Ergebnisausgabe soll die ganze Welt angesprochen werden+
\verb+@<<*>>=+\\
\verb+@<<drucke "Hello World" aus>>+\\
\verb+cat("Hier das Ergebnis:\n")+\\
\verb+print(42)+
} %end of small
\end{quote}



@
\subsubsection{Knöpfe:  [[PlanRCode]], [[EvalRCode]], [[TrashROutput]], [[Up]], [[Down]], [[Examples]], [[Help.R:]]}

\paragraph{[[EvalRCode]]: Aktivierung von Anweisungen.}
Für die Aktivierung von Code-Sequenzen bedarf es eines Sprachelements.
Dieses wird durch einen Aktivierungsknopfes sowie der Verabredung umgesetzt,
daß dieser Knopf immer nur die Anweisung(en) aus dem Arbeitsfenster
umsetzt, auf die der Cursor zeigt.

@
\paragraph{[[PlanRCode]]: Text- und Code-Chunk in leerer Form bereitstellen.}
Für die Vorbereitung eines neuen Arbeitsschrittes ist ein Knopf eine gute Hilfe, der
das Muster einer leeren Text-Code-Chunk-Einheit ins Arbeitsfenster
schreibt. Wird der Knopf [[PlanRCode]] gedrückt, erscheint in der Nähe des
Cursors:
\begin{quote}
\verb+@+\\
\verb+ +\\
\verb+@<<*>>=+\\
\verb+ +
\end{quote}


@
\paragraph{[[TrashROutput]]: Entfernung des letzten Output.}
Die Arbeit mit den ersten Testversionen hat gezeigt, daß
immer wieder Fehlversuche gemacht werden, die nicht weiter aufbewahrenswert
sind. Um bequem übernommene Ausgaben zu löschen wird der
Knopf [[TrashROutput]] angeboten. Er entfernt die Ergebnisse
wieder aus dem Arbeitsfenster, auf die der Cursor zeigt.

@
\paragraph{[[Down]]: Bewegung der Schreibmarke zum nächsten Code-Chunk.}
Zur erleichterten Navigation kann der Anwender durch Druck auf den Knopf
[[Down]] die Schreibmarke auf den nächst folgenden Code-Chunk
positionieren.

@
\paragraph{[[Up]]: Bewegung der Schreibmarke zum vorherigen Code-Chunk.}
Durch Druck auf den Knopf
[[Up]] kann der Anwender zur vorherigen Schreibmarke zurückblättern.


@
\paragraph{[[Help.R:]] Start einer Hilfe.}
Als kleine Hilfe wird (oben rechts) ein Hilfeknopf definiert, mit dem die
R-Hilfe angestoßen werden kann.

@
\paragraph{Short cuts für Knöpfe.}
Zur Vereinfachung der Bedienung von Knöpfen soll es für den geübten
Anwender möglich sein, die Operationen
auch über {\sc Alt}-Tastenkombinationen, also über sogenannte short cuts,
auszulösen.

@
\subsubsection{Meldungsanzeige: [[Info]]}
\paragraph{[[Info:]] Anzeige von Meldungen.}
Eine Zeile für Fehler-, Zustands- und Informationsmeldungen wird immer
benötigt.

@
\paragraph{[[Strg Pagedown]] Kopieren ans Ende -- ab 1.02 abgeschaltet.}
Um nicht schon einmal eingegebene Anweisungen
neu eintippen zu müssen, soll die Tastenkombination
[[Strg Pagedown]], wenn das Reportfenster aktiv ist, den
Code-Chunk, dessen Beginn sich vor der Cursor-Position befindet,
ans Ende kopieren, ihn aber nicht ausführen.

Damit haben wir auch die Überleitung zu der nächsten Frage:
Welche wesentlichen Operationen will der Statistiker
während seiner Arbeit neben der Eingabe von Texten und
der Beschreibungen von Berechnungen und Datenmanipulationen
umgesetzt bekommen?
Zur Auslösung entsprechender Prozesse werden im Folgenden eine Reihe
von Funktions-Knöpfen entworfen.



@
\subsubsection{Operationen für das Outputfeld:
[[RemoveOut]], [[Insert]], [[SavePlot]]}
Bisher sind drei elementare Operationen für das Outputfeld
im Angebot:

\paragraph{[[RemoveOut]]: Entfernung des Inhalts.}
Mit diesem Knopf lässt sich der Inhalt aus dem Outputfenster entfernen.

\paragraph{[[Insert]]: Verschieben des Inhalts ins Arbeitsfenster.}
Mit diesem Knopf lässt sich der Inhalt ins Arbeitsfenster hinter die
Schreibmarke verschieben. Dannach ist das
Outputfenster leer.

\paragraph{[[SavePlot]]: Sichert Plot.} 
Sichert den Inhalt eines graphischen Device
als Postscript- und JPEG-Datei und stellt Plot im Arbeitsfenster dar.


@
\subsubsection{Menüs: [[File]], [[Edit]], [[Options]]}

\paragraph{[[File]]: Datei- und andere dateinahe Operationen.}
Dateioperationen werden bei vielen
Softwareprodukten in der Kopfzeile angeboten, so daß sich auch hier ein
entsprechendes Pull-Down-Menü mit den Namen [[File]] anbietet.
Unter diesem werden Auf\-listungs, Lade- und Speicheroperationen
angeboten.
Auch wenn die Überschrift für die Programmbeendigung wenig sinnig im
Datei-Menü untergebracht ist, soll [[Exit]] unter den Dateioperationen
subsummiert werden, wie es auch bei vielen anderen Oberflächen üblich ist.

@
\paragraph{[[Edit]]: Suchen nach Dingen und andere arbeitsfensterbezogene
Operationen.}
Für die Navigation bietet sich ein zweites Menü für spezielle Bearbeitsschritte,
zum Beispiel für Suchfunktionen an. So kommt immer wieder der Wunsch auf,
nach Textstrings zu suchen. Weiter könnte man nach Code-Chunks suchen wollen.
\paragraph{[[CopyToEnd]]: Verschieben des Outputs ans
Ende des Arbeitsfensters.} Mit diesem Knopf wird der Inhalt des Outputfeldes ans
Ende des Arbeitsfensters verschoben. Inzwischen als Menüeintrag unter
[[Edit]].

@
\paragraph{[[Options]]: Veränderung von Einstellungen.}
Die Veränderung der Schrift
und einigen anderen Dingen dürfte wünschenswert sein. Für solche
Setzungen eignet sich ein Options-Menü.
Auch muß es eine Möglichkeit geben, um die Größe von Postscript-Bildern
zu setzen.
Wie sich mit der Zeit herausgestellt hat, kann es passieren, daß
ein ungeschickter Auftrag zu einer sehr langen aber,
unbrauchbaren Ausgabe führt. Die Festlegung einer Output-Obergrenze
ist damit ein weiterer Kandidat für das Options-Menü.

@
\paragraph{[[Wizardry]]: Dokumentverarbeitung.}
Rohreports wollen schön gesetzt sein. Dafür werden unter diesem 
Menü verschiedene Punkte angeboten: weave, tangle, latex, view *dvi,
Präambel einfügen usw.

@
\paragraph{[[Data]]: hilft bei der Auswahl von Daten.}

@
\paragraph{[[Methods]]: zeigt die Syntax einfacher Operationen.}


@
\paragraph{[[CopyToEnd]]: Verschieben des Outputs ans
Ende des Arbeitsfensters.} Mit diesem Knopf wird der Inhalt des Outputfeldes ans
Ende des Arbeitsfensters verschoben. Inzwischen als Menüeintrag unter
[[Edit]].


@
\subsubsection{Zusammenfassung}
Für die elementaren Arbeiten sind zusammenfassend
ein Text-Eingabefeld, ein Ausgabefeld, neun Knöpfe, drei Menüs
und eine Meldungsleiste beschrieben worden. Hier die Übersicht:
\begin{itemize}
\item[[EvalRCode]] --- aktiviere letzte Anweisungen
\item[[PlanRCode]] --- stelle leere Text-Code-Chunk-Einheit bereit
\item[[TrashROutput]] --- entferne letzten Output
\item[[Down]] --- gehe zum nächsten Code-Chunk
\item[[Up]] --- gehe zum vorherigen Code-Chunk
\item[[Examples]] --- zeigt R-Beispiele
\item[[Help.R]] --- starte R-Hilfe
\item[[Info]] --- Meldungsanzeigefeld
\item[[File]] --- Menü mit dateinahen Operationen und Ausgang
\item[[Edit]] --- Menü zum Suchen und fensterbezogenen Operationen
\item[[Options]] --- Veränderung spezieller Einstellungen
\item[[workwin]] --- Arbeitsfenster
\item[[outwin]] --- Outputfenster
\item{\sc Alt} --- short cuts für Knöpfe
\item [[Strg Pagedown]] zur Kopie von Codesequenzen -- ab 1.02 abgeschaltet
\item[[@]] und [[@<<...>>=]] --- zur Abgrenzung von Texten und Code
\end{itemize}

Die genannten Elemente werden in dem hier vorgestellten Instrument
mit folgendem Erscheinungsbild umgesetzt.
In Voraussicht ist schon ein Feld mit dem Reportnamen ergänzt worden.
Weiterhin sind Menüs mit dem Titel [[Data]] und [[Methods]]
zu erkennen, diese werden weiter unten diskutiert.

@
Der Kopfbereich entspricht im Design
vielen bekannten Oberflächen. Hierdurch soll der Suchaufwand
für die im allgemeinen dort untergebrachten Operationen klein bleiben.
Der Rest ist der Anordnung einer PC-Anlage nachempfunden,
bei der die Tastatur unterhalb des Bildschirm zu finden ist.
Das Eingabefenster entspricht dabei dem Bildschirm. Es befindet sich über
den zentralen, als winzige Tastatur interpretierbare Knöpfen für die Eingabe.
Ausgaben erscheinen zunächst unten, wie auch ein per Hand beschriebenes
Papier in der Regel unten verlängert wird.
Die Arbeitsschritte werden dadurch oft zu einem sich wiederholenden
Perspektivenwechsel führen:
\begin{enumerate}
\item Lesen der alten Inhalte (z.B.\ Ergebnisse),
\item Anfügungen von neuem Text,
\item Entwurf eines neuen Code-Chunk,
\item Aktivierung des Code.
\item Übernahme oder Löschung der Ergebnisse
\end{enumerate}
@
\begin{center}

% \includegraphics[height=8cm]{PS/relax-win.ps}
\includegraphics[height=10cm]{PS/f4.ps}

%rawhtml% \begin{rawhtml}<p><img src="win1.gif"><p>\end{rawhtml}

\end{center}

@
\section{Reportorientiertes Arbeiten}

\subsection{Arbeitsform}
Ein reportorientiertes Arbeiten erfordert alle Dinge, die schon
unter der Überschrift {\em Evaluierung von Anweisung} aufgelistet
sind. Das Eingabefenster wandelt sich bei diesem Arbeitsstil
von einem Arbeits- zu einem {\em Reportfenster}. Dieses muß zu keinen
Änderungen der Oberfläche führen.
Als funktionale Neuerung dürfte die Möglichkeit
der Verwendung von benannten Code-Sequenzen in einem auszuführenden
Code-Chunk vorteilhaft sein.
Dieses erfordert bei der Aktivierung des letzten
Code-Chunk einen lokalen {\sc Tangle}-Prozeß,
dessen Umsetzung weiter unten näher diskutiert wird.
Da über diesen Mechanismus auch externe Code-Chunks
--- also welche, die sich in anderen Dateien befinden ---
referenziert werden können sollen, ergibt sich ein Lösungsvorschlag zu
drei Problemkreisen:
Erstens können so im Report wiederverwendbare Code-Sequenzen
aus externen Bibliothekspapieren eingebunden werden,
zweitens lassen sich für wiederbelebbare Papiere
Anhänge mit Funktionsdefinitionen in separaten Dateien halten und
drittens können Reports von Reaktivierungen erstellt werden, die nicht vor Code
bersten.

Neben dieser konzeptionellen Erweiterung müssen die typischen
Operationen zur Verwaltung und Verarbeitung von Reports, wie Ortswahl,
Laden, Speichern und Dokumenterstellung hinzukommen.
Wenn ein halbfertiger Report erneut zur weiteren Arbeit geladen wird,
muß es die Möglichkeit geben, den gesamten alten Code zu wiederholen,
um die Umgebung in den alten Zustand zu versetzen.

Damit ist ein grober Rahmen in Form von Anforderungen umrissen.
Für Textstruktur und Inhalt bleibt der Anwender jedoch selbst verantwortlich.


@
\subsection{Sprachelemente}

Als wesentliche Erweiterung müssen definiert werden:
\begin{itemize}
\item
[[SaveReport]] --- speichere einen erarbeiteten Report
\item
[[OpenReport]] --- öffne einen noch unfertigen Report, hänge ihn
unten an das Report-Fenster an
\end{itemize}
Zur Begleitung dieser beiden Aufgaben sollte als Service-Funktion
zum Verzeichniswechsel angeboten werden.
\begin{itemize}
\item
[[SetWorkPath]] --- lege das Arbeitsverzeichnis Reporterstellung fest
\end{itemize}
Nach der Abspeicherung müssen die Rohreports betrachtet werden können,
so daß auch hierfür etwas angeboten werden muss.
Für den Anfänger genügt die gespeicherte Html-Version.
Derjenige mit einer größeren Erfahrung muss weitergehende
Verarbeitungsschritte selbst entwerfen.
Zum Betrachten wird angeboten:
\begin{itemize}
\item
[[ViewReport.html]] --- zeige Report (Html-Version) mit einem Browser an
\end{itemize}
In dem Menü [[Edit]] sind noch einige Einträge zur Erleichterung
der Arbeit an einem Report vorgesehen. Es sind damit folgende
Einträge zu finden:
\begin{itemize}
\item
[[FindRFns]] --- suche nach R-Funktionen aufgrund eines Stichwortes
\item
[[FindReportText]] --- suche im bisherigen Report nach einer Zeichenkette
\item
[[FindReportCode]] --- suche nach einem Code-Chunk
\item
[[FindLaTeXSection]] --- suche  eine \LaTeX-Sektion.
\item
[[EditReport]] ---
starte einen Editor, mit dem der Anwender hoffentlich alle
die Dinge einfach erledigen kann, die ihm direkt mit dem Reportfenster
nicht gelingen. Für Spezialisten sei erwähnt, daß
der Name des Editors auf einer
Variable mit dem Namen [[editor.sys]] abgelegt ist. Diese läßt sich
durch einen geeigneten Funktions-Aufruf setzen.
\item 
[[CopyToEnd]] --- kopiert Ausgabefensterinhalt ans Ende.
%\item
%[[SaveDiffReport]] --- speichert Veränderungen zum Ausgangsfile.
\item
[[RunAll]] --- löse alle Start- und Stern-Code-Chunks
eines Reports aus, damit zum Beispiel
nach dem Laden eines halbfertigen Reports möglichst der Zustand
bei der Speicherung wieder hergestellt wird.
\item
[[DeleteAll]] --- lösche den Inhalt des Reportfensters.
\item
[[UnDo]] --- stelle den Zustand vor der letzten [[EvalRCode]]-Operation her.
Dieses kann sehr wichtig sein, wenn versehentlich wichtige Dinge gelöscht
worden sind. Der Zustand der Variablen wird dabei jedoch nicht zurückgesetzt.
\end{itemize}
@
\paragraph{[[SavePlot]]: Speicherung eines Bildes.}
Wer möchte nicht gern in seinem Report die Abdrucke der gelungenen
Graphiken eingefügt haben? Zu diesem Zweck müssen sie auf\-findbar als Dateien
abgelegt werden. Die Betätigung von [[SavePlot]] erstellt zu
einem Bild eine [[PS]]- und eine
[[JPG]]-Datei und blendet es bei entsprechender Installation im Arbeitsfenster ein.
Das leichte Kopieren eines Bildes in das Dokument
in Form einer Postscript- und einer [[JPG]]-Datei wird sicher auch reportophobe
Anwender erfreuen.
Natürlich wird diese Operation im reportorientierten Arbeitsstil
an Relevanz gewinnen.

@
Für den lokalen {\sc Tangle}-Prozeß bedarf es noch einer sprachlichen
Fixierung:
\begin{itemize}
\item {\sc Tangle}-Prozeß:
In einem Code-Chunk dürfen auch {\em externe Code-Chunks} adressiert werden.
Für diese gilt die Syntax:
\begin{quote}
[[#<file:]]$\langle${\em Pfad}$\rangle$[[/]]%
$\langle${\em Dateiname}$\rangle$[[:]]%
$\langle${\em Code-Chunk-Nummer}$\rangle$[[>#]]
\end{quote}
oder
\begin{quote}
[[#<file:]]$\langle${\em Pfad}$\rangle$[[/]]%
$\langle${\em Dateiname}$\rangle$[[:]]%
$\langle${\em Referenz des Code-Chunk}$\rangle$[[>#]]
\end{quote}
\end{itemize}
Für die Auswertung muß der Code-Chunk-File -- also die Datei mit der
Endung [[R]] -- zugreifbar sein.

@
% Bei der Generierung eines Reports wird als Pfad der Inhalt von
% [[revpath.sys]] abgelegt.

@
Es ist nicht erforderlich, auf der obersten Ebene weitere Oberflächenelemente
zu ergänzen. Jedoch müssen in dem Menü [[Edit]] die neuen Punkte
aufgenommen werden.


@
Hier noch die Anzeige der einzelne Menü der Kopfleiste:

\begin{itemize}

\item{Das Datei-Menü:}

{\centering\includegraphics[height=4cm]{PS/file.ps}}

@
\item{Das Bearbeiten-Menü}

{\centering\includegraphics[height=5cm]{PS/edit.ps}}

@
\item{Das Optionen-Menü}

{\centering\includegraphics[height=4cm]{PS/options.ps}}

@
\item{Das Wizardry-Menü}

{\centering\includegraphics[height=5cm]{PS/wizardry.ps}}
@
\item{Das Methoden-Menü}

{\centering\includegraphics[height=3cm]{PS/methods.ps}}
@
\item{Das Daten-Menü}

{\centering\includegraphics[height=4cm]{PS/data.ps}}

\end{itemize}

@
\section{Überblick über Umgebungen, Objekte und Funktionen}
Bevor die Oberfläche mit ihren Elementen definiert werden kann,
muß die große Linie festgelegt werden.
Die Fragen:
{\em Welche Objekte sind wo zu finden,
was muß an welcher Stelle abgelegt werden,
was ist wie zu finden?\/} müssen zweckmäßigerweise
vorher beantwortet werden. Natürlich hat sich die
genaue Struktur mit der Zeit entwickelt. Dennoch sind einige
wesentliche Entscheidungen über alle bisherigen Versionen
stabil geblieben. Diese werden in diesem Kapitel zusammengefaßt.

\subsection{Der R-Editor als R-Paket}

Der R-Editor soll  isoliert als R-Paket mit dem Namen [[relax]]
bereitgestellt werden.
% Dann soll eine Vereinigung mit der Bibliothek [[rtrevive]] angestrebt werden.
Also müssen alle hier definierten Dinge --- also Funktionen und
Initialisierungsanweisungen --- in einer [[R]]-Codedatei zusammengefaßt
werden. Für ihre Anordnung sind dabei Reihenfolgebedingungen zu beachten.
Für die Aktivierung soll es ausreichen, das Paket mit dem
Namen [[relax]] zu laden und die Oberflächenfunktion [[relax()]]
zu starten.
Durch diesen Aufruf müssen dann
\begin{itemize}
\item ggf.\ das [[Tcl/Tk]]-Paket angeschlossen,
\item die Oberfläche aufgebaut,
\item die Elemente der Oberfläche mit den nötigen Funktionalitäten
      ausgestattet und
\item die Verwaltung für Anwender- und Systemobjekte eingerichtet
\end{itemize}
werden.
Dabei sind Unterschiede für verschiedene Plattformen zu berücksichtigen.

@
\subsection{Über die Objektverwaltung}
Für die Übersicht werden alle Anwenderobjekte von den Systemobjekten getrennt
in einer eigenen Umgebung [[revive.env]] abgelegt. In dieser finden auch die
durch den Anwender ausgelösten Evaluierungsprozesse statt.
Hierdurch wird vermieden, daß
die vom Anwender erarbeiteten Ergebnisse mit Dingen des Systems kollidieren.
Die Umgebung des Anwenders [[revive.env]] wird beim Anschluß des
Pakets mit [[new.env]] eingerichtet, sofern sie noch nicht existiert.
Damit auch nach einem Absturz auf Anwenderdaten zugegriffen werden kann,
wird die Adresse zu der Umgebung auf der globalen Variablen
[[revive.env]] abgelegt.

In dieser Umgebung wird als einziges System-Objekt die
Variablen [[revive.sys]] generiert, die die Verbindung zu der Umgebung hält,
in der alle Objekte des Systems abgelegt sind.

Damit gibt es vier Orte zu unterscheiden:
\begin{itemize}
\item das [[relax]]-Paket -- hier befinden sich alle prozeduralen
      Beschreibungen zum Start des Managers sowie die Funktionen
      zur Überlagerung der R-Input-/Output-Funktionen
\item die globale Umgebung -- hier wird das Objekt [[revive.env]] abgelegt,
      der Link zu den Anwenderobjekten bzw.\ zu der Anwenderumgebung
\item die Umgebung [[revive.env]] -- hier befinden sich
      die vom Anwender geschaffenen Objekte und als einziges Systemobjekt
      der Link zur Umgebung des Report-Manager-Betriebs: [[revive.sys]]
\item die Umgebung [[revive.sys]] -- hier residieren alle internen Objekte des
      Report-Managers, die sich zur Laufzeit ändern und zum Betrieb des
      Managers erforderlich sind, wie auch Kopien aller
      Funktionen aus dem Paket.
\end{itemize}

Es folgt die Umsetzung: ggf.\ Schaffung der Umgebung [[new.env()]]
sowie die Definition der Umgebung für Systemdinge, die unter dem
Namen [[revive.sys]] in der Anwenderumgebung abgelegt wird.

Dieser Chunk wird beim Aufruf des Report-Managers aktiviert.
Es ergab sich die Schwierigkeit, daß beim zweiten Aufruf des
Managers aus dem Report-Fenster heraus verschiedene Objekte
aus dem ersten statt aus dem zweiten Aufruf gefunden wurden.
Dieses lag daran, daß diese Objekte in einem Speicherbereich
gefunden wurden, der gar nicht für die Verwaltung gedacht war.
Aus unbekannten Gründen wurde beim zweiten Versuch auf diesen
veralteten Bereich zugegriffen. Zur Abhilfe wird jetzt
als Vater-Umgebung von [[revive.env]] explizit [[.GlobalEnv]]
definiert und es werden beim zweiten Start -- wenn also [[revive.env]]
existiert -- alle Objekte aus [[revive.sys]] gelöscht.
Möglicherweise wäre es geschickter nur die sensiblen Dingen
zu entfernen, jedoch wird auf diese Weise ein hoher Grad an
tabula rasa realisiert.
<<generiere eine neue Umgebung für die Anwenderdaten>>=
revive.env<-"1"; rm(revive.env)
if(!exists("revive.env")){
  revive.env<<-rev.env<-new.env(parent=.GlobalEnv) ### 111103
} else {
  revive.sys<-get("revive.sys",envir=revive.env)
  rm(list=ls(envir=revive.sys),  envir=revive.sys)
}
revive.sys<-environment()
assign("revive.sys", revive.sys, envir=revive.env)
# if(0<length(grep("relax.fns",search()))) detach("relax.fns") # 121214 ???
# attach(what=NULL,name="relax.fns")
# pos.of.relax.fns <- grep("relax.fns",search())

@
Damit nach Beendigung von [[relax()]] der Suchpfad wieder in Ordnung ist, wird dieser nach Schließung des Fensters entfernt. 
<<entferne [[relax.fns]] nach Beendigung von [[relax]] aus Suchpfad>>=
tkbind(tworkwin,"<Destroy>", function() {  # 121212
     base::print("Top Level Window of relax has been closed.")
     #  if(0<length(grep("relax.fns",search()))) detach("relax.fns")
   }
)
@
Da [[relax()]] verlassen wird, bevor die Arbeit mit dem Editor beginnt,
geht folgender Trick nur beim Einsatz von [[tkwait.window()]] am Ende von 
[[relax()]]:
[[on.exit( if(0<length(grep("relax.fns",search()))) detach("relax.fns") )]]

@
\subsection{Der Ausgangspunkt für die Oberfläche}

Zunächst muß ein Fenster der obersten Ebene mit einem Titel geschaffen werden.
Damit Fenster und andere Oberflächenelemente angesprochen werden können,
wird für jedes Element mit seiner Erschaffung eine Variable erstellt.
Die Variable für das Toplevelfenster heißt [[TopW]]. Wie bereits
ausgeführt wurde, werden solche Variablen und alle Funktionen der Oberfläche
in der Umgebung [[revive.sys]] gehalten, so daß sie nicht mit den
Objekten des Anwenders kollidieren können.
[[wm protocol . WM_DELETE_WINDOW { puts "kein ordentlicher Ausstieg" }]]
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
TopW<-tktoplevel(); tkwm.geometry(TopW,"+0+15")
tkwm.title(TopW,paste(
             if(but.Wizardry=="simple") "redit -- simple Report EDITor for statistical analysis:" else
                                        "relax -- Report Editor for Literate Analysis and lateX:",
                      <<Version von [[relax]]>>))
tkwm.protocol(TopW,"WM_DELETE_WINDOW",function(){
                   <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
		   cat("... not a nice way to exit relax !!!\n")
		   cat("backup file: report-UnDo-bak.rev\n")
		   if( <<das OS ist Windows>> ){
                      cat("--> to proceed the R session try: Quit R, then don't quit!\n")
                   }
                   if(<<das OS ist Linux>>) cat("-- try: <Ctrl-C> to proceed the R session!\n")
		   set.tclvalue("tvexit","fertig"); tkdestroy(TopW)
           }
)


@
In dieses Top-Level-Fenster werden verschiedene Frames eingebracht,
die im weiteren Verlauf mit Ober\-flächen\-ele\-menten gefüllt werden.

@
\subsection{Das Erstellungs-Modell für einen Knopf}
Knöpfe werden wiederholt zum Einsatz kommen. Für diese bietet sich
eine Standardisierung an, um Wartung und Pflege zu vereinfachen.

@
Die Definition eines Knopfes umfaßt
\begin{itemize}
\item die Festlegung der Wirkung durch eine Knopf\-funktion,
\item die Plazierung dieser Funktion in die richtige Umgebung,
\item die Definition eines virtuellen Events,
\item die Definition des Knopfes mit Einbau in die Oberfläche,
\item die Vereinbarung der Wirkungsfunktion als Knopf-Kommando
\item sowie die Verbindung der Wirkungsfunktion mit dem virtuellen Event.
\end{itemize}

Anhand eines Testknopfes soll das Vorgehen zur Erstellung eines
Knopfes beschrieben werden.

Die Wirkungsfunktion wird außerhalb des Oberflächenmanagers erstellt.
Sie könnte folgende Gestalt haben.
<<definiere Testknopf\-funktion>>=
fTest<-function(){
  melde("fTest",1)
  cat("Hallo Welt\n")
  news <- "\n@\nTestknopftest"
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  melde("fTest",2)
}

@
Dann wird nach Aufruf des R-Editors beim Aufbau der Oberfläche
--- nachdem die Systemumgebung [[revive.sys]] eingerichtet worden ist ---
der Knopf\-funktion die Umgebung [[revive.sys]] zugeordnet.
Damit wird bei Aktivierung des Knopfes die Wirkungsfunktion gefunden,
welche wiederum alles findet, was in [[revive.sys]] abgelegt ist.
<<setze Umgebung für Testknopf\-funktion>>=
environment(fTest)<-revive.sys

@
Es wird das virtuelle Ereignis [[@<<Test>>]] für die Tastenkombination ALT-T,
definiert. Unter Unix war der Tastatur-Code anders, so dass eine
Zuweisung in Abhängigkeit vom Betriebssystem erforderlich war.
<<definiere Testknopf-Ereignis>>=
tkevent.add("@<<Test>>",  "<Alt_L><t>")

@
Der Knopf selbst wird
mit der Service-Funktion [[implement.but]] eingerichtet.
Diese Funktion besitzt verschiedene Argumente:
Argument eins zeigt den Knopfnamen an. Der Name der
Wirkungsfunktionsnamen ergibt sich durch Voranstellen des Buchstaben [[f]]
vor den Knopfnamen. Das zweite Argument bezeichnet
den gewählten Frame. Das dritte eine kurze Beschreibung, die als Kurzhilfetext
eingeblendet wird.
<<implementiere Testknopf>>=
implement.but("Test", "fworkcmds", "Dies ist ein Testknopf" )

@
Zum Schluß wird die Funktion [[fTest]] als Knopfkommando vereinbart und
mit dem virtuellen Event verbunden.
<<implementiere Eigenschaften vom Testknopf>>=
tkconfigure(Test,command=fTest)
tkbind(TopW, "@<<Test>>", fTest)

@
\subsubsection{Eine Funktion zur Implementation von Knöpfen.}
Da im folgenden noch verschiedene Knöpfe benötigt werden, werden diese
mit der Funktion [[implement.but]] erzeugt, deren Definition als Vorarbeit
hier abgehandelt wird.
In einer solchen Funktion lassen sich Design-Merkmale für alle
Knöpfe der Oberfläche pflegeleicht festlegen.
Das erste Argumente beschreibt zugleich den Knopfnamen und seine Beschriftung,
das zweite seine Frame-Zugehörigkeit, das
dritte eine Kurzhilfe, das vierte seine Positionierung im zugehörigen
Widget, das fünfte die Darstellungsart und das sechste, ob für einen
short cut durch die
{\sc Alt}-Taste der erste Buchstabe unterstrichen werden soll.

@
Das Ergebnis --- die Variable mit der Verbindung zu einem Knopf ---
muß in der Umgebung [[revive.sys]] abgelegt werden, damit jederzeit
ein Zugriff möglich ist.

Unter Linux gab es plötzlich Probleme mit der Reaktion der Knöpfe.
Deshalb wurde am 07115 umgestellt darauf, dass nicht per [[configure]]
die Funktionalität der Knöpfe festgelegt wird, sondern durch
das Event: [[<Button-1><ButtonRelease>]]. Der Job wird über ein 
weiteres Argument von [[implement.but]] übermittelt.

@
<<definiere [[Implement.but]]>>=
implement.but<-
function(but,frame,mess=" ",side="right",relief="raised",short.cut=TRUE,bwf=1,job=""){ ## 071115
  if(is.character(frame)) frame<-eval(parse(text=frame))
  b<-tkbutton(frame, text=but, relief=relief, pady=<<negativer y-Platz>>,
  	      width=floor(<<Knopfbreite>>*bwf), font=<<Font für Knöpfe>>)
  if(short.cut) tkconfigure(b,underline=0)
  tkbind(b,"<Enter>",function()set.tclvalue("tvmess",mess))
  tkbind(b,"<Leave>",<<relax-zeige-Funktion>>)
  tkbind(b,"<Button-1><ButtonRelease>",job) ## 071115
  tkpack(b, side=side)
  assign(but, b, envir=revive.sys)
}
@
vorher: -1
<<negativer y-Platz>>=
"-3"

@
Damit haben wir eine Standardisierung für Knöpfe vorgenommen.

@
\section{Reportloses Arbeiten --- Implementation}
\subsection{Implementation der Oberflächenelemente}

In diesem Abschnitt werden die Elemente der Oberfläche definiert, die
für den reportlosen Arbeitsstil erforderlich sind.

@
\subsubsection{Frames für das reportlose Arbeiten}
Das Top-Level-Fenster wird in horizontale Streifen aufteilt.
Diese werden als {\sc Tk}-Frames definiert.
Der oberste Streifen ([[fhead]]) dient dem Anstoß von Datei-Operationen,
Konfigurationsveränderungen und anderen allgemeinen Dingen. Als zweites
kommt ein Bereich, in dem der für Steuerungsfragen notwendige
Informationsaustausch abgewickelt wird: [[finfo]].
Dann folgt das Arbeitsfenster ([[fworkwin]]) selbst, in dem die Texte und
R-Aufträge niedergeschrieben werden.
Direkt zum Reportfenster / Arbeitsfenster gehörende
Information und Knöpfe werden im dritten Streifen ([[fworkcmds]]%
\footnote{Zuerst besaßen dieser Frame und auch verschiedene andere Objekte
den Namensbestandteil [[rep]] statt [[work]]. Als Folge führte die
Namensnähe zu [[rev]] wiederholt zu zeitaufwendigen Fehlersuchen.})
angebracht. Es folgt die Kommando-Leiste für das
Outputfeld und das Outputfeld selbst.

@
\paragraph{Veränderung der Text-Fenstergrößen}
Der gangbare Weg, um die beiden Fenster dynamisch zu vergrößern
bzw.\ verkleinern ist zunächst direkt mit Tcl/Tk probiert worden. Dabei
ergab sich folgender Entwurf:
\begin{verbatim}
button .b1
button .b2
frame .mitte -height 300 -width 900
pack  .b1
pack  .mitte -fill both -expand 1
pack  .b2
#ok
frame .mitte.top
frame .mitte.bottom
frame .mitte.handle -bd 2 -relief raised -bg red -cursor sb_v_double_arrow
place .mitte.top    -relwidth 1 -rely 0 -height -1 -anchor nw
place .mitte.bottom -relwidth 1 -rely 1 -height -1 -anchor sw
place .mitte.handle -relx 0.05 -width 10 -height 10 -anchor e
#ok

. configure -bg blue
bind . <Configure> {
  set H [winfo height .mitte].0
  set Y0 [winfo rooty .mitte]
}
bind .mitte.handle <B1-Motion> {
  set fract [expr (%Y -$Y0)/$H]
  if { $fract < 0.2 } {
    set fract 0.2
  }
  if { $fract > 0.8 } {
    set fract 0.8
  }
  place .mitte.top -relheight $fract
  place .mitte.handle -rely $fract
  place .mitte.bottom -relheight [expr 1.0 - $fract]
}

set fract 0.5
place .mitte.top -relheight $fract
place .mitte.handle -rely $fract
place .mitte.bottom -relheight [expr 1.0 - $fract]

frame .mitte.bottom.f1
text .mitte.bottom.f1.tt -yscrollcommand ".mitte.bottom.f1.scroll set"
scrollbar .mitte.bottom.f1.scroll -command ".mitte.bottom.f1.tt yview"
pack .mitte.bottom.f1.scroll -side right -fill y

frame .mitte.bottom.f2
frame .mitte.bottom.f3
button .mitte.bottom.f2.b1 -text "left: text.mitte.bottom.f2.b1"
button .mitte.bottom.f2.b2 -text "right: text.mitte.bottom.f2.b2"
button .mitte.bottom.f3.b1 -text "left: text.mitte.bottom.f3.b1"
button .mitte.bottom.f3.b2 -text "right: text.mitte.bottom.f3.b2"
pack .mitte.bottom.f2.b1 -side left
pack .mitte.bottom.f2.b2 -side right
pack .mitte.bottom.f3.b1 -side left
pack .mitte.bottom.f3.b2 -side right
pack .mitte.bottom.f2 -fill x
pack .mitte.bottom.f3 -fill x
pack .mitte.bottom.f1 .mitte.bottom.f1.tt -fill x
.mitte.bottom.f1.tt insert 0.0 [exec cat $env(HOME)/out.rev]

# frame .mitte.top.f1
text .mitte.top.tt -yscrollcommand ".mitte.top.scroll set"
scrollbar .mitte.top.scroll -command ".mitte.top.tt yview"
pack .mitte.top.scroll -side right -fill y
pack .mitte.top.tt -fill x
.mitte.top.tt insert 0.0 [exec cat $env(HOME)/test.rev]
\end{verbatim}
Diesen Entwurf werden wir jetzt auf [[relax]] übertragen.

Zunächst benötigen wir folgende Frames:
[[fhead]] für die Menüleiste, [[finfo]] für Meldungen, [[finout]] für die
Textfenster und die Kommandoknöpfe.
Neu Sept.\ 2006: konfigurierbare Fensterdimensionen
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fhead<- tkframe(TopW, relief="raised", bd="1")
#### finfo<- tkframe(TopW)  ###100208 shift to foutcmds
# finout   <- tkframe(TopW,height="700",width="700") 
finout<- tkframe(TopW,height=relaxwindow.height.sys,width=relaxwindow.width.sys) 
tkpack(fhead, side="top",fill="x")
#### tkpack(finfo,   side="top") ###100208 shift to foutcmds
tkpack(finout, side="top",fill="both",expand="1")

@
Der Frame [[finout]] wird in drei weitere Frames zerlegt: [[fworkwin]], [[fhandle]] und
[[fout]]:
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fworkwin<-tkframe(finout)
fout        <-tkframe(finout)
fhandle   <-tkframe(finout,bd="2",relief="raised", bg="#BEE3D2",   # #87ff9D",
                                   cursor="sb_v_double_arrow")
tkplace(fworkwin, relwidth="1",rely="0",height="-1",anchor="nw")
tkplace(fout, relwidth="1",rely="1",height="-1",anchor="sw")
tkplace(fhandle, relx="1",width="1500",height="6",anchor="e")

@
Wenn sich bestimmte Verschiebungen ereignen, müssen die
Fenster angepasst werden.
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
proc<-paste(
  paste("bind ",TopW$ID," <Configure> {" ),
      paste("set H [winfo height ",finout$ID, "].0" ),
      paste("set Y0  [winfo rooty ",finout$ID, "]" ),
  "}",
  paste("bind",fhandle$ID," <B1-Motion> {"),
    "set fract [expr (%Y -$Y0)/$H]",
    "if { $fract < 0.1 } {",
    "  set fract 0.1",
    "}",
    "if { $fract > 0.95 } {",
    "  set fract 0.95",
    "}",
    paste("place ",fworkwin$ID," -relheight $fract"),
    paste("place ",fhandle$ID," -rely $fract"),
    paste("place ",fout," -relheight [expr 1.0 - $fract]"),
  "}",
  sep="\n")
.Tcl(proc)

@
Die Anfangsgrößenverteilung wird festgelegt.
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fract<- 0.5
tkplace(fworkwin, relheight=fract)
tkplace(fhandle, rely=fract)
tkplace(fout, relheight=1-fract)

@
Jetzt können wir das Arbeitsfenster andenken. Dieses wird weiter unten
(siehe: [[tktext(fworkwin,...)]]) mit einem entsprechenden Scrollbar versehen.

@
Der untere Bildteil [[fout]] besteht aus drei Teilen:
dem Frame für die Arbeitsfenster-Kommandos:
[[fworkcmds]], dem für die Output-Fenster-Kommandos: [[foutcmds]] und
dem Frame für das Output-Text-Fenster [[foutwin]].
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fworkcmds<-tkframe(fout, relief="raised", bd="0")
foutcmds<-tkframe(fout, relief="raised", bd="0") # ,background="#37D70F")
foutwin   <- tkframe(fout)

tkpack(fworkcmds,foutcmds,fill="x")
tkpack(foutwin,fill="both",expand="yes")

finfo<- tkframe(foutcmds); 
tkpack(finfo, side="left",fill="both",expand="yes")  ###100208
### tkpack(tklabel(foutcmds, text=" Result(s):",pady=#<negativer y-Platz>#,
###	font=#<Font für Knöpfe>#), side="left")  #ipady=7, 

@
\subsubsection{[[fhead]]: [[File]], [[Edit]], [[Options]], [[Help.R]]}
Für Dateioperationen wird ein [[tkmenubutton]] links im Frame [[fhead]]
definiert. Daneben folgen weitere für Navigationsaufgaben und
Konfigurationseinstellungen.
Oben rechts erscheint ein Button zum Zugriff auf die R-Hilfe ([[Help.R]]).

@
\paragraph{Zum Kopf-Frame.}
Die notwendigen Menü-Knöpfe werden mit Hilfe von [[tkmenubutton]]
erzeugt. Die Objekte bekommen einen Namen, aus dem ihre Qualität
wie auch ihre Aufgabe zu ersehen ist. [[mb]] steht kurz für
[[menubutton]] und zum Beispiel [[Edit]] für das Menü zum Finden von
Dingen. Auf der Konstanten
@<<Knopfbreite>> ist eine standardisierte Breite einer
Box und auf @<<Font für Knöpfe>> ein Font abgelegt.
Es wird vereinbart, welche kurze Erklärung im Informationsfeld
angezeigt werden soll, wenn der Cursor auf den hier definierten Widgets steht.
Für Profis steht noch ein Menü mit Revweb-Funktionalitäten bereit.
Nach der Erzeugung der Elemente werden sie in den
bei der Generierung vereinbarten Frame von links nach rechts gepackt.
Zuerst die Menüelemente:
<<definiere Kopf-Frame>>=
mbFile<-tkmenubutton(fhead, text="File", font=<<Font für Knöpfe>>,
                     relief="flat", width=<<Knopfbreite>>) # alternativ groove
mbEdit<-tkmenubutton(fhead, text="Edit", font=<<Font für Knöpfe>>,
                     relief="flat", width=<<Knopfbreite>>)
mbOptions<-tkmenubutton(fhead, text="Options", font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
if(but.Wizardry == "all"){
  mbRevweb<-tkmenubutton(fhead, text="Wizardry", font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
}

@
Für die Kurzhilfe sei eine kleine Hilfsfunktion beschrieben,
die eine Funktion zur Setzung der kurze Hilfe als Funktion definiert.
Sie wird eingesetzt zur Definition der Folge des Event: Cursor betritt Feld.
In einem solchen Fall wird die Kurzhilfe gezeigt.
Im Falle des Verlassens muß eine Rücksetzung erfolgen.
<<definiere Kopf-Frame>>=
f<-function(mess) function()set.tclvalue("tvmess",mess)
tkbind(mbFile, "<Enter>", f("file operations and exit"))
tkbind(mbEdit, "<Enter>", f("searching and other operations"))
tkbind(mbOptions,  "<Enter>", f("change settings"))
if(but.Wizardry=="all")  tkbind(mbRevweb,  "<Enter>", f("process document and specials"))
tkbind(mbFile, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(mbEdit, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(mbOptions, "<Leave>", <<relax-zeige-Funktion>>)
if(but.Wizardry=="all")tkbind(mbRevweb, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(finfo, "<Enter>", f("entry / message field"))
tkbind(finfo, "<Leave>", <<relax-zeige-Funktion>>)

@
<<relax-zeige-Funktion>>=
function(){ set.tclvalue("tvmess","relax") }
@
Zum Schluß können die neuen Elemente in den Frame gepackt werden.
<<definiere Kopf-Frame>>=
tkpack(mbFile,mbEdit,mbOptions,side="left")
if(but.Wizardry=="all")tkpack(mbRevweb,side="left")
implement.but("Help.R", "fhead", "show online documentation of R object",job=fHelp.R)
implement.but("Examples", "fhead", "show arguments and examples of objects",
              job=fExamples)

@
\paragraph{Datei- und andere dateinahe Operationen.}
Ein sauberer Ausstieg wird immer benötigt. Hierfür wird ein
Menüeintrag geschaffen.

@
Das Menü muss zunächst initialisiert werden.
<<definiere Kopf-Frame>>=
mbFile.menu<-tkmenu(mbFile,font=<<Font für Knöpfe>>)
tkconfigure(mbFile, menu=mbFile.menu)

@
Jetzt lässt sich der Menüeintrag zur Programmbeendigung eintragen.
<<definiere Datei-Menü-Eintrag zur Programmbeendigung>>=
tkadd(mbFile.menu, "command", label="Exit:   quit RELAX",
      command=Exit)
@
Die Beschreibung der zugehörigen Wirkungsfunktion
befindet sich im Abschnitt Implementationen.

@
\paragraph{Bearbeitungsoperationen -- Unterpunkte von [[Edit]].}
Gesucht werden könnten im Arbeitsfenster Zeichenketten oder Namen von
Code-Chunks oder aber ausgehend von Keywords nach R-Funktionen.
Dieses führt zu drei Einträgen im [[Edit]]-Menü.
<<definiere Kopf-Frame>>=
mbEdit.menu<-tkmenu(mbEdit,font=<<Font für Knöpfe>>)
tkconfigure(mbEdit, menu=mbEdit.menu)
tkadd(mbEdit.menu, "command", command=ShowAboutRelax,
      label="ShowAboutRelax:   what's relax?")
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "command", command=ShowShortCuts,
        label="ShowShortCuts:   show short cuts for text field")
}
tkadd(mbEdit.menu, "command", command=<<generiere interaktives icon>>,
      label="ShowInteractiveIcon:   show an interactive icon")
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "separator")
  tkadd(mbEdit.menu, "command", command=ReloadPlots,
        label="ReloadPlots:   reload jpeg-plot of text field")
  tkadd(mbEdit.menu, "command", command=RefreshChunkNumbers,
        label="RefreshChunkNumbers:   refresh the chunks numbers after chunk names")
  tkadd(mbEdit.menu, "command", command=ReloadReportWidget,
        label="ReloadReportWidget:   reconstruct REPORT WINDOW in case of strange appearances")
  tkadd(mbEdit.menu, "separator")
}
tkadd(mbEdit.menu, "command", command=GoToLine,
        label="GoToLine:   go to line ... ")
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "command", command=Replace, 
        label="SearchReplace:  search and replace text strings") #100917
}
tkadd(mbEdit.menu, "command", command=FindRFns,
      label="FindRFns:   search R function by keyword")
tkadd(mbEdit.menu, "command", command=FindReportText,
      label="FindReportText:   search text string in text field  (Crtl+F)")
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "command", command=FindReportChunk,
        label="FindReportChunk:   search code chunk in text field")
  tkadd(mbEdit.menu, "command", command=FindLaTeXSection,
        label="FindLaTeXSection:   search for \\section, \\subsection and \\subsubsection")
  tkadd(mbEdit.menu, "command", command=ListUsedPlots,
        label="ListUsedPlots:   list graphics files of directory / referenced in the report")
  tkadd(mbEdit.menu, "separator")
  tkadd(mbEdit.menu, "command", command=InsertLaTeXEnv,
        label="InsertLaTeXEnv:   insert LaTeX environment")
}

@
<<unused>>=
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=InsertPlot,
      label="InsertPlot:   copy plot to ps / jpeg-file")
tkadd(mbEdit.menu, "command", command=InsertTeX,
      label="InsertTeX:    insert TeX-formated lines")
tkadd(mbEdit.menu, "separator")

@
\paragraph{Optionale Parameter.}
Zu den wichtigen Parametern, die unbedingt beeinflußbar sein sollten, zählen
Größe des Zeichensatzes, die Veränderung von Postscript-Bildmaßen
und die maximale Größe des Outputs.
<<definiere Kopf-Frame>>=
mbOptions.menu<-tkmenu(mbOptions, font=<<Font für Knöpfe>>)
tkconfigure(mbOptions, menu=mbOptions.menu)
tkadd(mbOptions.menu,"command", command=SetOutputLength,
      label="SetOutputLength: define maximal lines of output")
if(but.Wizardry!="simple") 
  tkadd(mbOptions.menu, "separator")
tkadd(mbOptions.menu,"command", command=SetFontType,
      label="SetFontType:   define font type")
tkadd(mbOptions.menu,"command", command=SetFontSize,
      label="SetFontSize:   define font size")
if(but.Wizardry!="simple") {
  tkadd(mbOptions.menu, "separator")
  tkadd(mbOptions.menu,"command", command=SetRelaxWinSize,
        label="SetRelaxWinSize:  redefine width x height of relax window")
  tkadd(mbOptions.menu, "separator")
  tkadd(mbOptions.menu,"command", command=SetPlotHeight,
        label="SetPlotHeight:  define height of plot (-> latex)")
  tkadd(mbOptions.menu,"command", command=SetPSDesignWidth,
        label="SetPSWidth:   define width of ps-graphics")
  tkadd(mbOptions.menu,"command", command=SetPSDesignHeight,
        label="SetPSHeight:  define height of ps-graphics")
  tkadd(mbOptions.menu,"command", command=SetPSRotation,
        label="SetPSRotation:  define non normal PS rotation")
  tkadd(mbOptions.menu,"command", command=SetJPGSize,
        label="SetJPGSize:  define size of jpeg-graphics")
  tkadd(mbOptions.menu,"command", command=SetPPMResolution,
        label="SetPPMResolution:  define resolution of ppm-graphics")
  tkadd(mbOptions.menu, "separator")
  tkadd(mbOptions.menu,"command", command=ConvertEncodingToLocal,
        label="ConvertEncodingToLocal:  convert encoding to local one")
  tkadd(mbOptions.menu,"command", command=ConvertEncodingFromLocal,
        label="ConvertEncodingFromLocal:  convert encoding to a new one")
  tkadd(mbOptions.menu,"command", command=ConvertGermanUmlauteToLocalEncoding,
        label="ConvertGermanUmlauteToLocalEncoding:  try to convert German-Umlaute to locale encoding")
  tkadd(mbOptions.menu, "separator")
}
tkadd(mbOptions.menu,"command", command=ConfigRelax,
      label="Configure Relax: view or change parameters of relax")

@
<<unused>>=
tkadd(mbOptions.menu,"command", command=SetPSWidth,
      label="SetPlotWidth:   define width of plot (-> latex)")
tkadd(mbOptions.menu,"command", command=SetPSWidth,
      label="SetPlotWidth:   define width of plot (-> latex)")

@
\paragraph{Revweb-Funktionalitäten.}
Die logische Variable [[but.Wizardry]] wird über den Funktionsaufruf gesetzt.
<<definiere Kopf-Frame>>=
if(but.Wizardry=="all"){
 mbRevweb.menu<-tkmenu(mbRevweb,font=<<Font für Knöpfe>>)
 tkconfigure(mbRevweb, menu=mbRevweb.menu)
 tkadd(mbRevweb.menu,"command", command=ProcessReport,
      label="ProcessReport:  SaveReport, WeaveReport, and LatexReport")
 tkadd(mbRevweb.menu,"command", command=ViewReport,
      label="ViewReport:   show formated report")
 tkadd(mbRevweb.menu,"command", command=ProcessChunk,
      label="ProcessChunk:  SaveChunk as 'local-chunk', WeaveChunk, and LatexChunk")  ## experimental
 tkadd(mbRevweb.menu,"command", command=ProcessBeginEndEnv,
      label="ProcessBeginEndEnv:  Save Latex Environment as 'local-chunk', Weave, and Latex")  ## experimental
 tkadd(mbRevweb.menu, "separator")
 tkadd(mbRevweb.menu,"command", command=LaTeX.head,
      label="LaTeX.head:   include simple LaTeX head")
 tkadd(mbRevweb.menu,"command", command=LatexReport,
      label="LatexReport:   format Latex file")
 tkadd(mbRevweb.menu,"command", command=ShowLogFile,
      label="ShowLogFile:   open Latex log file by editor")
 tkadd(mbRevweb.menu,"command", command=DvipdfReport,
      label="DvipdfReport:   translate dvi- in pdf-file")
 tkadd(mbRevweb.menu, "separator")
 tkadd(mbRevweb.menu,"command", command=ProcessWithSexpr,
      label="ProcessWithSexpr:   save, weave source file, eval \\Sexpr{...}, latex")
 tkadd(mbRevweb.menu,"command", command=WebReport,
      label="WebReport:   save, weave and tangle source file")
 tkadd(mbRevweb.menu,"command", command=WeaveReport,
      label="WeaveReport:   save, weave source file")
 tkadd(mbRevweb.menu,"command", command=WeaveReportNoCode,
      label="WeaveReportNoCode:   save, weave source file, hide code")
 tkadd(mbRevweb.menu,"command", command=WeaveReportNoText,
      label="WeaveReportNoText:   save, weave source file, hide text")
 tkadd(mbRevweb.menu,"command", command=WeaveReportEchoCode,
      label="WeaveReportEchoCode:   save, weave source file, hide code if code name contains echo=FALSE")
 tkadd(mbRevweb.menu,"command", command=TangleReport,
      label="TangleReport:   save, tangle source file")
 tkadd(mbRevweb.menu,"command", command=TangleReportChunk,
      label="TangleReportChunk:   save, tangle source file ask for root chunk")
 tkadd(mbRevweb.menu,"command", command=TangleReportNoComments,
      label="TangleReportNoComments:   save, tangle source file without added comment lines")
 tkadd(mbRevweb.menu, "separator")
 tkadd(mbRevweb.menu, "command", command=RunAllandIncludeResults,
      label="RunAllandIncludeResults:   simple Sweave: <filename>-out.tex and LaTeX file")
 tkadd(mbRevweb.menu, "command", command=RunBeginEndEnvandIncludeResults,
      label="RunBeginEndEnvandIncludeResults:   simple Sweave of environment: <filename>-out.tex and LaTeX file")
 tkadd(mbRevweb.menu,"command", command=SWEAVE,
      label="SWEAVE:   save, Sweave and LaTeX file")
 tkadd(mbRevweb.menu,"command", command=SWEAVEB,
      label="SWEAVE:   save, Sweave (new process) and LaTeX file")
 ##tkadd(mbRevweb.menu, "separator")
 <<definiere ggf.\ Eintrag [[FormatTeXLines]]>>
 ##erstelle Menüeintrag für Funktionstasten-Puffer##
 ## tkadd(mbRevweb.menu, "separator")
 ## tkadd(mbRevweb.menu,"command", command=LoadRwtools,
     ## label="LoadR-wtools:   load some functions: stem.leaf, ... and some data sets")
}

@
<<definiere ggf.\ Eintrag [[FormatTeXLines]]>>=
FTL.ok<-FALSE
if( <<das OS ist Windows>> ){
      libpath<-file.path(relax.path,"lib")
      if(file.exists(file.path(libpath,"pnmcrop.exe")) &&
         file.exists(file.path(libpath,"ppmtojpeg.exe")) &&
	 file.exists(file.path(libpath,"netpbm.dll")) &&
	 file.exists(file.path(libpath,"libjpeg.dll"))) FTL.ok<-TRUE
}
if(<<das OS ist Linux>>){
   if(0<length(system("which convert",TRUE,TRUE)) &&
      0<length(system("which dvips",TRUE,TRUE))) FTL.ok<-TRUE
  }
if(FTL.ok){
  tkadd(mbRevweb.menu, "separator")
  tkadd(mbRevweb.menu, "command", command=FormatTeXLines,
        label="FormatTeXLines:   format text chunk by LaTeX and insert  jpeg-file")
}

@
\subsubsection{[[finfo]]: Der Frame für den Informationsaustausch}

Zwischen dem Kopf\-frame und dem zur Steuerung des Arbeitsfensters
ist ein schmaler Streifen für den Informationsaustausch vorgesehen.
In diesem sollen zum Beispiel die Erklärungstexte zu den Knöpfen oder
Zustandsmeldungen erscheinen.
Die Info-Zeile besteht aus dem Schlüsselwort [[Info:]] und
aus einem Label-Widget [[linfo]], das die jeweilige Nachricht anzeigt.
<<definiere Info-Frame>>=
## linfo.name <- tklabel(finfo, text=" ", font=#<Font für Knöpfe>#) ##
linfo      <- tklabel(finfo, text=" ", textvariable="tvmess", relief="ridge")
  ###                      width=#<Infofeldbreite>#,
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>
#tkbind(linfo,"<ButtonPress>",#<generiere interaktives icon>#)
@
brelax<-tkbutton(finfo,relief="flat",text="icon",command=<generiere interaktives icon>)
tkpack(brelax,side="left")

@
<<generiere interaktives icon>>=
function(){
  if(FALSE){
    res<-tkmessageBox(message=if(language=="german") "Soll das interaktive Icon aktiert werden?"
                              else "Do you want to activate interactive icon?",
                      title="RELAX-ICON",icon="warning",type="yesnocancel",default="no")
    if("externalptr"==mode(res))  res<-tclvalue(res)
    if(res=="cancel") return()
    if(res=="no") return()
  }
chair<-function(xcenter=1.2,xspread=1,ycenter=1.2,yspread=1,lwd=4){
  # cat("chair: ", xcenter,xspread,ycenter,yspread)
  x<-seq(0,1.6,length=(n<-40))
  xshift<-.5;ystretch<-1.2; height<-.4/yspread
  y<-0.5*cosh(ystretch*x-xshift);
  y<-scale(y-y[1]-.06,-ycenter,1/yspread)
  x<-scale(x/1.6,-xcenter,1/xspread)
  segments(x[1],y[1],x[1]*.1+x[n]*.9,y[1]-height,lwd=lwd,xpd=NA,col="blue")
  segments(x[1],y[1]-height,x[n],y[n],lwd=lwd,xpd=NA,col="blue")
  lines(x,y,lwd=lwd,xpd=NA,col="blue")
}
tree<-function(xcenter=.51,xspread=1.5,ycenter=0,yspread=2,lwd=3,n=5,n.l=10){
  # cat(xcenter,xspread,ycenter,yspread)
  yspread<-yspread/2.5; ycenter<-ycenter+.15
  leaf<-function(von,start,delta,len,n.l=10,krum.par){
   xy.mat<-matrix(von,2,n.l)
   h<-start*2*pi/360
   xy.delta<-c(cos(h),sin(h))/n.l
   delta<-delta*2*pi/360*len/n.l
   for(i in 2:n.l){
    w<-delta
    xy.delta<-matrix(c(cos(w),-sin(w),sin(w),cos(w)),2,2)%*%xy.delta
    xy.mat[,i]<-xy.mat[,i-1]+xy.delta
   }
   delta.y<-qbeta((0:n.l)/n.l,2,3)
   delta.y<-.04*cumsum(sin((0:(n.l-1))/(n.l)*2*pi))
   xy<-t(xy.mat) # +von-xy.mat[,1])
   xy[,1]<-scale(xy[,1]*xspread/2,-xcenter,1)#2/xspread)
   xy[,2]<-(xy[,2]*yspread+ycenter)
   delta.y<-(delta.y*yspread)
   #lines(xy[,1],xy[,2],lwd=3) #lines(xy[,1],xy[,2]+delta.y,lwd=3)
   polygon(c(xy[,1],rev(xy[,1])),c(xy[,2],rev(xy[,2]+delta.y)),col="green",border=NA,xpd=NA)
  }
  x<-seq(-50,90,length=floor(n/2))
  for(i in x){
    leaf(von=c(0,0),start=i,delta=5,len=10,n.l=n.l)
    x<-seq(-50,90,length=ceiling(n/2))
  }
  for(i in x) leaf(von=c(0,0),start=190-i,delta=-5,len=10,n.l=n.l)
  segments(xcenter-0.02*xspread,ycenter,
           xcenter-0.05*xspread,ycenter-1.5*yspread,lwd=1)
  segments(xcenter+0.02*xspread,ycenter,
           xcenter+0.05*xspread,ycenter-1.5*yspread,lwd=1)
} # end of tree
redo<-function(...){
  ytrsc<-xtrsc<-slider(no=1); xchsc<-slider(no=2)
  ychsc<-slider(no=3);hori<-slider(no=4);n.leafs<-slider(no=5)
  leaf.sty=slider(no=6)
  h<-slider(obj.name="tree.center"); xtrcenter<-h[1]; ytrcenter<-h[2]
  h<-slider(obj.name="chair.center"); xchcenter<-h[1]; ychcenter<-h[2]
#  a<-par(family="mono") # 121217
  plot(-2:2,-2:2,type="n",axes=FALSE,xlab="",ylab=""); # text(.6,1.8,"relax",cex=4)
  #polygon(2*c(-2,-2,2,2),c(hori,-3,-3,hori),col="#fcf1a2",border=NA,xpd=NA) # strand
  #polygon(2*c(-2,-2,2,2),c(hori,3,3,hori),col="#c8e6f2",border=NA,xpd=NA)   # air
  n <- 1000; xa<-rep(-4,n); xb <- xa + 8
  y <- seq(hori,-3.5,length=n); segments(xa,y,xb,y,col=rainbow(n,start=0.11,end=0.18),xpd=NA)
  y <- seq(hori, 3.5,length=n); segments(xa,y,xb,y,col=rainbow(n,start=0.53,end=0.70),xpd=NA)
  b<-as.numeric(unlist(strsplit(sub(".*([0-9][0-9]:[0-9][0-9]:).*","\\1",date()),":")))
  b[2]<-b[2]/60; bb<-b; b[1] <- b[1]+6; b <- (sum(b)%%12)/12
  cen <- c(-2*cos(pi*b),sin(pi*b)*(2-hori)+hori+.5)
  points(cen[1],cen[2],cex=15,col=heat.colors(18)[6+floor(abs(20*min(b,1-b)))],pch=16,xpd=NA)
  h <- 2*pi*(sum(bb)/12); h <- cen + c(sin(h),cos(h))*0.3
  arrows(cen[1],cen[2],h[1],h[2],.08,col="blue",lwd=4,xpd=NA)
  h <- 2*pi*(bb[2]); h <- cen + c(sin(h),cos(h))*0.4
  arrows(cen[1],cen[2],h[1],h[2],.08,col="blue",lwd=4,xpd=NA)
  tree(xcenter=xtrcenter,xspread=xtrsc,n=n.leafs,n.l=leaf.sty,
       ycenter=ytrcenter,yspread=ytrsc,lwd=3)
  chair(xcenter=xchcenter,xspread=xchsc,
        ycenter=ychcenter,yspread=ychsc,lwd=3)
  # text(1.6,-2,"relax",xpd=NA) # 121217 letters: RELAX:
  f <- .1; lwd <- f*30; fr <- 1.5; dx <- -2.5; dy <- 2.5; xdel <- .15
  segments(dx-0.5*xdel+fr*f*c(0,0,0,0,1),dy+fr*f*c(0,1,1,2,1),
           dx-0.5*xdel+fr*f*c(0,1,1,1,1),dy+fr*f*c(2,0,1,2,2),lwd=lwd,xpd=NA)#R
  dx <- dx + xdel
  segments(dx+f*c(0,0,0,0),dy+f*c(0,0,1,2),dx+f*c(0,1,1,1),dy+f*c(2,0,1,2),lwd=lwd,xpd=NA)#E
  dx <- dx + xdel
  segments(dx+f*c(0,0),dy+f*c(2,0),dx+f*c(0,1),dy+f*c(0,0), lwd=lwd,xpd=NA)#L
  dx <- dx + xdel
  segments(dx+f*c(0,0.5,.25),dy+f*c(0,2,.8),dx+f*c(0.5,1,0.75),dy+f*c(2,0,.8),
           lwd=lwd,xpd=NA)#A
  dx <- dx + xdel
  segments(dx+f*c(0,0), dy+f*c(0,2),dx+f*c(1,1),dy+f*c(2,0), lwd=lwd,xpd=NA)#X
#   par(family=a)
}
  slider(obj.name="tree.center",obj.value=c(-1.1,.8))
  slider(obj.name="chair.center",obj.value=c(.3,-1.2))
  set.tree<-function(...){
    # cat("click on desired position in graphics device!!!\n")
    # xy<-unlist(locator(n=1)); xy<-c(xy$x,xy$y)
    xy<-c(runif(1,-1,1),runif(1,-1.5,1.0))
    slider(obj.name="tree.center",obj.value=xy)
    redo()
  }
  set.chair<-function(...){ #   xy<-locator(n=1); xy<-c(xy$x,xy$y)
    xy<-c(runif(1,-1,1),runif(1,-1.5,0))
    slider(obj.name="chair.center",obj.value=xy)
    redo()
  }
  if("tkrplot" %in% list.files(.libPaths())) sl <- gslider else sl <- slider
  sl(redo,
    c("tree scale factor", "x scale chair",
      "design of chair", "size of beach",
      "number of leafs", "style of leafs"),
    c(.1,.1,.1,-2,7,5),c(5,2.4,2.4,2,17,30),
    c(.1,.1,.1,.1,1,1),c(3.5,1.2,1.2,-0.7,9,12),
    list(set.tree,set.chair,redo),
    but.names=c("tree location","new chair location","update clock")
  )
  if("tkrplot" %in% list.files(.libPaths())) "relax" else redo()
  "relax"
}

@
Da dieser Frame für unterschiedliche Dinge genutzt wird, muß
zur Normalisierung dieser wieder reinitialisiert werden. Deshalb wird
das Packen als isolierter Chunk bereitgestellt.
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>=
# tkpack(linfo.name,linfo,side="left",fill="x",expand="yes")
tkpack(linfo,side="left",fill="x",expand="yes")

@
Außerdem sollen im Frame [[finfo]]
Antworten auf Steuerungsfragen, wie Dateinameneingabe, abgehandelt werden.
Für solche Dialoge werden dann temporär das Label-Widget [[linfo.tmp]]
für den Frage-Text und das Entry-Widget [[einfo.tmp]]
für das Eingabefeld in den Info-Frame gepackt.
Das Eingabefeld wird mit der Variable [[tvinfo]] verbunden.
Diese Elemente erscheinen aber nur im Bedarfsfall.
<<definiere Info-Frame>>=
einfo.tmp <- tkentry(finfo,textvariable="tvinfo",background="#7ff",
                     width=floor(as.numeric(<<Infofeldbreite>>)*3/5))
linfo.tmp <- tklabel(finfo)

@
\subsubsection{[[fworkcmds]]: [[Up]], [[Down]], [[TrashROutput]], [[PlanRCode]],
               [[EvalRCode]]}
Die wesentliche Arbeit wird im Arbeitsfenster, das im Folgenden auch als
Reportfenster bezeichnet wird, geschehen.
Über diesem sollen sich Knöpfe für Aktionen befinden, die unmittelbar
für die Arbeit mit dem Report wichtig sind.
Weiterhin erscheint als Information der aktuelle Name des Reports.

Die Kommandos zur Speicherung von Bildern, zum Kopieren eines alten Code-Chunk,
zur Vorbereitung eines neuen Code-Chunk und zum Start des letzten Code-Chunk
werden von rechts beginnend in den Frame gepackt.
Die Variable [[workname.sys]] speichert den Reportnamen,
[[lworkname.sys]] den Namen des Labelfeldes, in dem der Name angezeigt wird.

<<definiere Report-Aktionsframe>>=
implement.but("TrashROutput", "fworkcmds", "trash output (after line of cursor)",
              job=fTrashROutput) ## 071115
implement.but("WarnEval",   "fworkcmds", "evaluate code (even if warnings occur)",
              job=fWarnEval)
implement.but("EvalRCode",   "fworkcmds", "evaluate code (stop in case of warnings)",job=fEvalRCode)
implement.but("PlanRCode",    "fworkcmds", "insert new empty code chunk",job=fPlanRCode)

tkpack(tklabel(fworkcmds, text="Line:",
       pady=<<negativer y-Platz>>,font=<<Font für Knöpfe>>),
       # ipady=7,
       side="left")
llineno.sys<-tklabel(fworkcmds, text=" ",width="4") # 
tkpack(llineno.sys, side="left")                    ###100208
lworkname.sys<-tklabel(fworkcmds, text=paste(workname.sys,""),
                    pady=<<negativer y-Platz>> ) ### (, relief="ridge")
tkpack(lworkname.sys, side="left")

implement.but("Down",   "fworkcmds", "jump downwards",side="left",bwf=0.40,job=fDown)
implement.but("Up",   "fworkcmds", "jump backwards",side="left",bwf=0.40,job=fUp)

implement.but("RemoveOut",foutcmds,"clear output field",job=fRemoveOut) ## 071115
implement.but("FindText",foutcmds,"find text string in report field",job=fFindText)
implement.but("SavePlot",foutcmds,
          "save plot as ppm, jpg and postscript file",job=fSavePlot)
implement.but("Insert",foutcmds,"insert output into report",job=fInsert)

### tkpack(tklabel(foutcmds, text=" Result(s):",pady=#<negativer y-Platz>#,
###	font=#<Font für Knöpfe>#), side="left")  #ipady=7,  ###100208



@
\subsubsection{[[fworkwin]]: Der Frame zur Reportbearbeitung}
Als Fenster zur Bearbeitung des aktuellen Reports dient ein einfaches
Text-Widget.
Die Breite des Fensters wurde zunächst
über die {\sc Tcl}-Variable [[twinwidth]]
gesteuert, die Höhe über [[tworkheight]].
Jedoch erwies sich die explizite Eingabe der Maße als zu lästig, so daß
jetzt das Arbeitsfenster über Mausaktionen verändert werden kann.
Das Report-Fenster paßt sich in der Breite und der Höhe automatisch an.
Weiterhin wird für Windows-Freunde PASTE über [[Ctrl-v]] realisiert.
% Control-V, Control_V, Control-C, Control_C, Ctrl-C, ctrl-c

Für Apple-Apfel-v wird die Zwischenablage von Apple gelesen
und an der Stelle der Schreibmarke eingefügt.
Für Apfel-c wird nach einer kurzen Zeitverzögerung 
das Clipboard von tcl/tk gelesen und der Apple-Zwischenablage übergeben,
Für Apfel-x wird die identische Funktion aufgerufen,
da das Ausschneiden selbst schon durch tcl/tk
realisiert wird.
Leider kommen die Events Apfel-c [[<Meta_L><c>]] und Apfel-v [[<Meta_L><v>]]im
Tcl/Tk-Fenster nicht durch. Darum geht nicht:
[[  tkbind(tworkwin,"<Meta_L><v>",mac.paste) ]]
und man muss sich mit Ctrl-C bzw. Ctrl-V begnügen.

Textplatzierung im Fenster durch eine relative Angabe (z.B. 0.5 = 50\% / Mitte) durch:
[[tclvalue(tkyview(tworkwin,"moveto","0.5"))]]

Text eine Seite hochscrollen zum Ausgleich beim Mac:
[[tclvalue(tkyview(tworkwin,"scroll","-1","pages"))]] 

<<definiere Report-Text-Frame>>=
tworkwin<-tktext(fworkwin, background="#f7fffF", font=tfont.sys) #cff#d0f0ff#c81e6ff23#f0fffF
try(tkconfigure(tworkwin, undo=1)) # 050704
workbar<-tkscrollbar(fworkwin)
tkconfigure(tworkwin,yscrollcommand=function(...) tkset(workbar,...))
tkconfigure(workbar, command=function(...) tkyview(tworkwin,...))
tkpack(workbar ,side="right",fill="y")
tkpack(tworkwin,fill="both",expand="yes")
tkinsert(tworkwin,"0.0",paste("% New Report:",date(),"\n"))
### CLIPBOARD-Funktion PASTE a la windows / clipboard
  ### tkevent.add("@<<Paste>>", "<Control_L><v>")
if(<<OS ist Mac-Mini>> ){
  mac.paste<-function(...){  ## Ctrl-V  # mac-PASTE
     try({.Tcl("clipboard append hello"); .Tcl("clipboard clear")
          news<-base::scan(file=pipe("pbpaste","r"),what="",sep="\n",blank.lines.skip=FALSE)
          tkinsert(tworkwin,"insert",paste(news,collapse="\n"))})
          tksee(tworkwin,"insert - 7 lines");  tksee(tworkwin,"insert + 7 lines") #090706 
  }  #  for shifting view:  tclvalue(tkyview(tworkwin,"scroll","-1","pages"))
  tkbind(tworkwin,"<Control_L><v>",mac.paste)
  mac.copy<-function(...){  ## Ctrl-C  # mac-COPY
     news<-""
     try(news<-tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa empty} {set aa full}")))
     if(news=="empty") return()
     try({news<-tclvalue(.Tcl("set aaa [selection get -selection CLIPBOARD]"))
          base::cat(news,file=<<tmp>>); system(paste("pbcopy < ",<<tmp>>))
          .Tcl("clipboard append hello"); .Tcl("clipboard clear")})
  }
  tkbind(tworkwin,"<Control_L><c>",mac.copy)
  tkevent.add("@<<extract>>",  "<Control_L><c><KeyRelease>")   # mac-extract
  tkbind(tworkwin,"@<<extract>>",mac.copy)
}else{
  tkevent.add("@<<Paste>>",   "<Control_L><v>")
  tkbind(tworkwin,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")
}
@
Fehlerversion
<<old and unused>>=
  # mac-PASTE, ctrl-v
  mac.paste<-function(...){
     try({.Tcl("clipboard append hello")
          .Tcl("clipboard clear")
          news<-base::scan(file=pipe("pbpaste","r"),what="",
                           sep="\n",blank.lines.skip=FALSE)
          tkinsert(tworkwin,"insert",paste(news,collapse="\n"))})
          tclvalue(tkyview(tworkwin,"scroll","-1","pages"))
  }
  ### tkevent.add("@<<Paste>>", "<Control_L><v>")
  tkbind(tworkwin,"<Control_L><v>",mac.paste)
  # mac-COPY
  mac.copy<-function(...){  ## Ctrl-C
     news<-""
     try(news<-tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa empty} {set aa full}")))
     if(news=="empty") return()
     try({news<-tclvalue(.Tcl("set aaa [selection get -selection CLIPBOARD]"))
          base::cat(news,file=<<tmp>>)
          system(paste("pbcopy < ",<<tmp>>))
          .Tcl("clipboard append hello")
          .Tcl("clipboard clear")})
  } 
  tkbind(tworkwin,"<Control_L><c>",mac.copy) 
  ###tkevent.add("@<<Copy>>",  "<Control_L><c><KeyRelease>")
  ###tkbind(tworkwin,"@<<Copy>>",mac.copy) 
  # mac-extract
  ###tkevent.add("@<<extract>>",  "<Control_L><c><KeyRelease>")
  ### tkbind(tworkwin,"@<<extract>>",mac.copy) 
  tkbind(tworkwin,"<Control_L><x>",mac.copy) 

@
Im Netz gefundene Strategie zur Feststellung, ob CLIPBOARD leer ist.
\begin{verbatim}
.Tcl("clipboard clear")
.Tcl("clipboard append hello")
tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa leer} {set aa voll}"))
[1] "voll"

.Tcl("clipboard clear")
#.Tcl("clipboard append hello")
tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa leer} {set aa voll}"))
[1] "leer"
\end{verbatim}

@
<<alte Version: Verwendung von [[.Tk.ID]]>>=
#tkconfigure(tworkwin,yscrollcommand=paste(.Tk.ID(workbar) ,"set"))
#tkconfigure(workbar,        command=paste(.Tk.ID(tworkwin),"yview"))
@
Es sei noch aufgelistet, wie die Editor-Kommandos funktionieren:
\begin{verbatim}
D-5: Cut, Copy and Paste in the Tcl Console Window

The Tcl Console window uses the default bindings for the Tcl text widget, 
which is not compatible with the Windows standard of

    * Ctrl-x: cut
    * Ctrl-c: copy
    * Ctrl-v: paste

Instead, the Tcl Console window (by default) uses the following bindings:

    * Ctrl-x: deletes selected text
    * Ctrl-w: cut
    * Alt-w: copy
    * Ctrl-y: paste

-Eric Foster-Johnson
Quelle:
http://ourworld.compuserve.com/homepages/efjohnson/tclwin.htm
\end{verbatim}

@
\subsubsection{[[foutwin]]: Der Frame zur Ergebnisanzeige}
Als Fenster zur Anzeige von Ergebnissen reicht ebenfalls ein einfaches
Text-Widget. Die Konstruktion ist identisch zu der des Report-Frame.
Dem üblen Gummi-Effekt unter manchen Windows-Versionen,
wird auch in diesem Chunk zu Leibe gerückt.
<<definiere Report-Text-Frame>>=
toutwin<-tktext(foutwin,height=8,background="#ffffee", font=outfont.sys) #fff080 #fc8f16a23#ffffcc
outbar<-tkscrollbar(foutwin)

tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")

if(<<das OS ist Windows>>) #{}
{ # 110505
# fout<-get("fout",envir=revive.sys); toutwin<-get("toutwin",envir=revive.sys)
 tkbind(fout,"<Configure>","")
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin) #; tkbind(toutwin,"<Configure>","")
      Sys.sleep(.01)
      if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
        tkpack(toutwin,fill="both",expand="yes")
      }
  }
 }
 tkbind(fout,"<Configure>",config.fns)
}
if(<<OS ist Mac-Mini>> ){  #121109
  tkbind(toutwin,"<Control_L><v>",mac.paste)
  tkbind(toutwin,"<Control_L><c>",mac.copy) 
  tkbind(toutwin,"@<<extract>>",mac.copy) 
}

@
<<definiere Report-Text-Frame, neu aber mit Gummieffekt>>=
toutwin<-tktext(foutwin,height=8,background="#fc8f16a23", font=outfont.sys) #fff080
outbar<-tkscrollbar(foutwin)
tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")
if(<<das OS ist Windows>>)
{ # 260405
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin) # ;tkbind(outbar,"<Configure>","")
      Sys.sleep(.2)
      if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
        tkpack(toutwin,fill="both",expand="yes")
      }
  }
 }
 tkbind(outbar,"<Configure>",config.fns)
}
@
<<definiere Report-Text-Frame-old>>=
toutwin<-tktext(foutwin,height=8,background="#fc8f16a23", font=outfont.sys) #fff080
outbar<-tkscrollbar(foutwin)
tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")
if(<<das OS ist Windows>>){
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin);tkbind(TopW,"<Configure>","")
  }
 }
 tkbind(TopW,"<Configure>",config.fns)
 tkbind(TopW,"<Motion>",function(...){
  if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
    width <-tclvalue(tkwinfo("width", TopW))
    height<-tclvalue(tkwinfo("height",TopW))
    Sys.sleep(.05)
    if(height==tclvalue(tkwinfo("height",TopW))
       &width==tclvalue(tkwinfo("width",TopW))){
      tkpack(toutwin,fill="both",expand="yes")
      tkbind(TopW,"<Configure>",config.fns)
    }
  }
 })
}

@
Zur Abhebung von Texten und Code-Stücken sollen die unterschiedlichen
Qualitäten in etwas unterschiedlicher Weise dargestellt werden.
Farbegestaltung: Text $\to$ schwarz, Code $\to$ rot, Output $\to$ blau,
Code-Chunk-Header $\to$ dunkelrot und etwas emporgehoben.
Dazu helfen die {\sc Tcl/Tk}-Prozeduren [[emphline]] (z.Z.\ unbenutzt),
[[marklinetypes]] (zur Feststellung der Qualität einer Zeile) und
[[markclear]] (zur Entfernung von Markierungen für Aktualisierungen).
Früher wurde die Funktion [[markreport]] der Handlichkeit wegen definiert
-- sie wurde nur an dieser Stelle verwendet. Inzwischen
wurde sie durch eine namenslose ersetzt.

@
Durch den Aufruf [[.Tcl(proc)]] werden die Prozeduren an [[Tcl/Tk]]
übergeben.
Längere Suche hat ergeben, dass bei der Konfiguration des Vorder- wie des Hintergrundes
die Setzungen des "sel"-Tags (Selektion) in den Vordergrund gehoben werden müssen.
Dieses leistet [["$w tag raise sel"]]. Andernfalls sind markierte Stücke nicht zu erkennen.
<<definiere Report-Text-Frame>>=
( # def. namenslose Funktion:
function(tworkwin){
 tktag.configure(tworkwin,"tld",   foreground="#C8162315126C", relief="raised",
                 borderwidth="2") # alternativ: #aaa222111
 tktag.configure(tworkwin,"tex", background="#e9ffff", 
                 relief="raised", borderwidth="3")
 tktag.configure(tworkwin,"code", background="#ffffff", 
                 foreground="#d21", font=outfont.sys) 
  # ddd222222
 tktag.configure(tworkwin,"output",foreground="#111222999", font=outfont.sys)
 tktag.configure(tworkwin,"emph", background="#999999999")
 tktag.configure(tworkwin,"jpeg", background="#ffffee",borderwidth="2",relief="raised")
 tktag.configure(tworkwin,"atsign", borderwidth="1",
              #   font="-Adobe-helvetica-Medium-R-Normal--10-100-*",
                 relief="raised"  # ,spacing1="2",spacing3=3,lmargin1=2
 )
 proc<-paste(
  "proc emphline {w mustera musterz} {",
    "scan [$w index end] %d anzzeilen", "set emphline 0\n",
    "for {set i 1} {$i < $anzzeilen} {incr i} {",
      "set actline [$w get $i.0 $i.end]",
      "if {[regexp $mustera $actline]} {",
        "if {[regexp $musterz $actline]} {",
          "uplevel $w tag add emph $i.0 $i.end",
        "}",
      "}",
    "}",
  "}", # type-semantics: 0=text, 1=tld, 2=code, 3=output
  "proc marklinetypes {w} {",
    "scan [$w index end] %d anzzeilen",
    "set type 0\n",
    "for {set i 1} {$i < $anzzeilen} {incr i} {",
     "set zeile [$w get $i.0 $i.end]",
     "set iv [ expr $i-1 ]","set in [ expr $i+1 ]",
     "if {$type==1}                           {\n set type 2\n}",
     "if {[regexp \"^@\"             $zeile]} {\n set type 0\n}",
     "if {[regexp \"^@<<.*>>=\"     $zeile]} {\n set type 1\n}",
     "if {[regexp \"^>\"     $zeile]} {\n set type 11\n}", # 091029
     "if {[regexp \"^\\\\\\\\s(u|e)(b|c)\" $zeile]} {\n set type 4\n}",#121127  
     "if {[regexp \"^......img src\"  $zeile]} {\n set type 5\n}",
     "if {[regexp \"^output-start\"  $zeile]}  {\n set type 3\n}",
     "if {[regexp \"^\\\\\\\\begin\\{verbatim\\}\" $zeile]} {\n set type 3\n}",
 "if {$type==0} {\n uplevel $w tag add atsign $i.0 $in.0 \n}",
 "if {$type==4} {\n uplevel $w tag add atsign $i.0 $in.0 \n}",
     # "if {$type==2} {\n uplevel $w tag add code    $i.0    $i.end \n}",
     # "if {$type==2} {\n uplevel $w tag add code    $iv.end $i.end \n}",
     "if {$type==2} {\n uplevel $w tag add code    $iv.end $in.0 \n}",
     # "if {$type==1} {\n uplevel $w tag add tld     $i.0 $i.end \n}",
     "if {$type==1} {\n uplevel $w tag add tld     $i.0 $i.end ",
                                                 "; set type 2 \n}",
     "if {$type==11} {\n uplevel $w tag add tld     $i.0 $i.1 ", # 091029
                     ";  uplevel $w tag add code    $i.1 $i.end ",
                                                 "; set type 2 \n}",
     ### "if {$type==1} {\n uplevel $w tag add tld     $i.0 $i.end \n ; ",
     ###               " \n uplevel $w tag add code $i.end $i.end \n ; ",
     ###                                            "; set type 2 \n } ",
     "if {$type==3} {\n uplevel $w tag add output  $i.0 $i.end \n}",
     "if {$type==4} {\n uplevel $w tag add tex     $i.0 $i.end","; set type 0 \n}",
     #"if {$type==4} {\n uplevel $w tag add tex     $i.0 $in.0", "; set type 0 \n}",
     "if {$type==5} {\n uplevel $w tag add jpeg    $i.0 $i.end","; set type 0 \n}",
     "if {[regexp \"^output-end\"  $zeile]} {\n set type 0\n}",
     "if {[regexp \"^\\\\\\\\end\\{verbatim\\}\" $zeile]} {\n set type 0\n}",
     "$w tag raise sel",
    "}",
  "}",
  "proc markclear w {",
    "$w tag remove tld    1.0 end",
    "$w tag remove tex    1.0 end",
    "$w tag remove code   1.0 end",
    "$w tag remove output 1.0 end",
    "$w tag remove atsign 1.0 end",
  "}", sep="\n")
  .Tcl(proc)
 tktag.bind(tworkwin,"jpeg","<Enter>", #081121
            function() set.tclvalue("tvmess","press RETURN to display jpeg by browser!"))
 tktag.bind(tworkwin,"jpeg","<Leave>",<<relax-zeige-Funktion>>)
 ## tktag.bind(tworkwin,"jpeg","<ButtonRelease>",
 tktag.bind(tworkwin,"jpeg","<Return>",
   function(){
     <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
     res<-tkmessageBox(message=
             if(language=="german") 
                paste("jpeg-Datei im Browser angezeigen?")
	     else paste("show jpeg graphics by browser"),
             title="Display JPEG?",icon="warning",type="yesnocancel",default="yes")
     res<-tclvalue(res); if(res=="cancel"||res=="no") return()
     fname<-tclvalue(tkget(tworkwin,paste(line,"0",sep="."),paste(line,"40",sep=".")))
     fname<-sub("^.*img src..","",fname)
     fname<-sub("(.jpg).*$","\\1",fname)
     browser.sys<-get("browser.sys",envir=revive.sys)
     cat(fname, "will be displayed by browser in a few seconds!\n")
     if( <<das OS ist Windows>> ){
       browser.exe<- if(browser.sys=="") "start " else browser.sys
	   res<-try(shell(paste(browser.exe, fname),wait=FALSE))  
       if(res!=0){ cat("ERROR: browser hasn't been started successfully \n") }
     } else {
       if(browser.sys!=""){
              try(system(paste(browser.sys,fname),wait=FALSE))
       }
     }
     "relax"
  }
)
}  # und Aufruf der namenslosen Funktion:
)(tworkwin)

@
ca. Zeile 6720
%w<-get("tworkwin",revive.sys)
%tkinsert(w,"1.end-2char", "hallo")
Zunächst werden die alten Setzungen entfernt. Dann wird für alle
Fälle der Output-Font neu gesetzt, denn für den Output wurde er
im Rahmen der Tag-Festlegung vereinbart.
<<aktualisiere Texthervorhebungen>>=
melde("ak texthervor",1)
tcl("markclear",tworkwin)
tktag.configure(tworkwin,"output",foreground="#111222999", font=outfont.sys)
tktag.configure(tworkwin,"code",  foreground="#ddd222222", font=outfont.sys)
tcl("marklinetypes",tworkwin)
melde("ak texthervor",2)

@
\nopagebreak
Damit ist die Oberfläche für ein normales Arbeiten skizziert.
Jetzt müssen die Wirkungen implementiert werden.

@
\subsection{Implementation der Funktionalitäten}

In der Kopfzeile sind Menüeinträge vorbereitet worden,
mit denen einige Einstellungen verändert werden können, die das Auf\-finden
verschiedener Dinge unterstützen sollen, und damit das Programm ordnungsgemäß
verlassen werden kann. Genauer sind die Funktionen zu den Punkten
[[File]], [[Edit]], [[Options]] und [[Help.R]] zu definieren.
Für die Steuerung des Arbeitsfeldes müssen die Funktion zu den Knöpfen
[[EvalRCode]], [[PlanRCode]], [[Up]], [[Down]] sowie
[[TrashROutput]] definiert werden.

@
\paragraph{Technische Bemerkungen:}
Vorwegschickt sei, dass später eine Funktion [[melde]] definiert wird,
die für Debugging-Zwecke anzeigt, welche Funktion gerade arbeitet oder
gibt einfach nur Text-Strings aus.
[[melde( xyz ,"cmd.msg")]] legt den Befehl [[xyz]] auf einem Befehlsspeicher
ab, so dass die zuletzt durchgeführte Operation rekonstruierbar ist.
Weiter zeigt eine Tcl-Variable [[tvexit]] an, ob [[relax]] beendet worden ist.
Die Tcl-Variable [[tvinfo]] speichert vom Anwender eingebene Namen,
Größen oder Texte.
Die Funktion [[set.tclvalue]] hilft bei der Setzung von Tcl/Tk-Variablen.

@
\subsubsection{Kopfzeile: [[File]]}

Als einziger Eintrag in dem Aktionsmenü ist bisher [[Exit]] beschreiben worden.

@
\subsubsection{Kopfzeile: [[File]] --- [[Exit]]}
\paragraph{[[Exit]] zur Beendigung des Programms.}

Die wesentliche Arbeit für die Programmbeendigung leistet die Funktion
[[tkdestroy]]. Für alle Fälle wird die Variable [[tvexit]] neu
gesetzt, so daß sich davon abhängige Widgets beenden können.
Wie auch bei allen weiteren Funktionen wird zur Erleichterung von
Fehleruntersuchungen am Beginn und am Ende mit Hilfe der Funktion
[[melde]] eine Zustandsinformation festgehalten.
Mit Hilfe der Konstruktion [[melde("q","cmd.msg")]] wird die Exit-Operation
in wiederholbarer Form kodiert.
@
<<definiere Kopf-Zeilen-Funktionen>>=
Exit<-function(){
  melde("Exit",1)
  res<-tkmessageBox(message=
            if(language=="german") "Report-Manager ohne erneute Speicherung beenden?"
	    else "Quit RELAX without saving again?",
                    title="Exit",icon="warning",type="yesnocancel",default="no")
  if("externalptr"==mode(res))  res<-tclvalue(res)
  if(res=="cancel") return()
  if(res=="no") SaveReport()
  set.tclvalue("tvexit","fertig"); tkdestroy(TopW)
  ## remove("print",pos=which(path.package("relax")==searchpaths())) ## 111103 # 130325 .path.package defunct
  melde("==================================================\n")
  melde("RELAX --- EXIT                    \n")
  # melde("copy of report saved as: \n")
  # melde(" report-UnDo-bak.rev                           \n")
  melde("restart RELAX by: \n relax()           \n")
  melde("==================================================\n")
  melde("q","cmd.msg")
  melde("Exit",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]]}
Für das Menü zur Änderung von Parametern sind folgende fünf Funktionen
zu definieren:
[[SetPSWidth]],
[[SetPlotHeight]],
[[SetFontType]],
[[SetFontSize]] und
[[SetOutputLength]].

\subsubsection{Kopfzeile: [[Optionen]] --- [[SetPSWidth]] und [[SetPlotHeight]]}
\paragraph{[[SetPSWidth]] und [[SetPlotHeight]]
           zur Veränderung der Breite und Höhe einer PS-Graphik.}
Diese Funktionen befragen den Anwender und setzen die Variablen
[[pswidth.sys]] und [[psheight.sys]] in der Umgebung [[revive.sys]] neu.
Hier ist zum ersten Mal ein Dialog zu erkennen. Nach Belegung von
[[frage]] und nach Speicherung des alten Wertes auf [[tvinfo]]
wird die Antwort erfragt.
Außerdem wird dafür Sorge getragen, daß bei einem {\sc Escape}-Druck sich
der Normalzustand wieder einstellt.
An einen {\sc Return}-Druck wird eine Rücksetzung gebunden und außerdem
wird die eingelesene Information auf der Variablen
[[pswidth.sys]] abgelegt. Zum Schluß erfolgt eine wiederholbare
Kodierung des ausgeführten Befehls.
<<definiere Kopf-Zeilen-Funktionen>>=
SetPSDesignWidth<-function(){
  melde("SetPSDesignWidth",1)
  frage<-"ps design width?"; set.tclvalue("tvinfo",psdesignwidth.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("psdesignwidth.sys",h,envir=revive.sys)
      melde(paste('> assign("psdesignwidth.sys","',psdesignwidth.sys,'",envir=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSDesignWidth",2)
}
@
Die Weite wird nicht mehr explizit gesetzt, sondern von \LaTeX\ angepasst.
<<unused>>=
SetPSWidth<-function(){
  melde("SetPSWidth",1)
  frage<-"ps width?"; set.tclvalue("tvinfo",pswidth.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      pswidth.sys<-tclvalue("tvinfo")
      assign("pswidth.sys",pswidth.sys,envir=revive.sys)
      melde(paste('> assign("pswidth.sys","',pswidth.sys,'",envir=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSWidth",2)
}

@
Möglicherweise kann später als Erweiterung eine Funktion
[[SetPSWidth.bat]] mit angeboten werden, mit der sich
die Variable [[pswidth.sys]] direkt setzen läßt. Entsprechendes
läßt sich auch für andere Knöpfe erfinden. Hier das Muster:
<<unused: future version>>=
SetPSWidth.bat<-function(pswidth.sys){
      assign("pswidth.sys",pswidth.sys,envir=revive.sys)
      melde(paste("> pswidth.sys <-",pswidth.sys),"cmd.msg")
}
environment(SetPSWidth.bat)<-revive.sys


@
Viele der im folgenden definierten Funktionen haben einen sehr ähnlichen
Aufbau. Deshalb bietet es sich an, einige wiederkehrende Sequenzen als
Code-Chunks zu definieren.

Zur Veränderung des
Arbeitsfeldes sollte dem Anwender eine entsprechende Frage gestellt
und ein Defaultwert angeboten werden. Durch Definition eines
Frage-Antwort-Moduls werden
weitere Frage-Antwort-Situationen wartungsfreundlich gelöst.
Als Kanal dient -- wie bereits angekündigt -- die {\sc Tcl}-Variable [[tvinfo]].

In dem Moment, in dem der Anwender eine Eingabe machen kann, wird die
Wirkung der {\sc Return}-Taste umdefiniert
(siehe dazu in der letzten Sektion: [[tkbind(TopW,"<Return>",...]]).
Durch Druck der {\sc Escape}-Taste soll die Eingabe ohne schädliche Wirkung
verlassen werden.

Die Fragestellung führt zur Umdefinition des Inhalts des zweiten Streifens.
Die gestellte Frage wird eingeblendet, ebenso der Defaultwert der Eingabe.
Außerdem wird {\sc Escape} zum vorzeitigen Verlassen der Eingabeauf\-forderung
definiert.
<<frage [[frage]], biete [[tvinfo]] als Antwort an>>=
tkconfigure(linfo.tmp,text=frage)
# tkpack("forget",linfo.name,linfo); Sys.sleep(0.01)
tkpack("forget",linfo); Sys.sleep(0.01)
tkpack(linfo.tmp,einfo.tmp,side="left"); Sys.sleep(0.01)
tkfocus(einfo.tmp)
tkselection.range(einfo.tmp,"0","end") ## 051219
<<definiere {\sc Escape} bei Texteingabe als Notausgang>>

@
{\sc Escape} setzt den Info-Frame zurück.
<<definiere {\sc Escape} bei Texteingabe als Notausgang>>=
tkbind(TopW,"<Escape>",function(){
    <<setze Manager nach {\sc Return} in Normalzustand>>
  }
)

@
Zurücksetzen bedeutet, das Eingabefeld und die Frage zu entfernen
und die ursprünglichen Widgets in den Frame hineinzupacken.
<<setze Manager nach {\sc Return} in Normalzustand>>=
tkbind(TopW,"<Return>","")
tkpack("forget",einfo.tmp,linfo.tmp); Sys.sleep(0.01)
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>

@
[[SetPlotHeight]] sieht entsprechend aus.
Weiter werden im Folgenden noch die Funktionen
zur Rotation von PS-Graphiken und zur JPEG-Größensetzung
formuliert.
<<definiere Kopf-Zeilen-Funktionen>>=
SetPlotHeight<-function(){
  melde("SetPlotHeight",1)
  frage<-"ps height?"; set.tclvalue("tvinfo",psheight.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      psheight.sys<-tclvalue("tvinfo")
      assign("psheight.sys",psheight.sys,envir=revive.sys)
      melde(paste('> assign("psheight.sys","',psheight.sys,'",envir=revive.sys)',sep="")
            ,"cmd.msg")
    }
  )
  melde("SetPlotHeight",2)
}
SetPSDesignHeight<-function(){
  melde("SetPSDesignHeight",1)
  frage<-"ps design width?"; set.tclvalue("tvinfo",psdesignheight.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("psdesignheight.sys",h,envir=revive.sys)
      melde(paste('> assign("psdesignheight.sys","',psdesignheight.sys,'",envir=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSDesignHeight",2)
}

SetPSRotation<-function(){
  melde("SetPSRotation",1)
  choices<-c("vertical / standard","horizontal") 
  activate<-1+pshorizontal.sys
  <<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>
  if(choice!=0){
      pshorizontal.sys<-2==choice
      assign("pshorizontal.sys",pshorizontal.sys,envir=revive.sys)
      melde(paste(
           '> assign("pshorizontal.sys","',pshorizontal.sys,'",envir=revive.sys)'
           ,sep=""),"cmd.msg")
  }
  melde("SetPSRotation",2)
}
SetPPMResolution<-function(){ #121114
  melde("SetPPMResolution",1)
  frage<-"ppm resolution (10..100)?"; set.tclvalue("tvinfo",ppmresolution.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("ppmresolution.sys",h,envir=revive.sys)
      melde(paste(
  '> assign("ppmresolution.sys","',ppmresolution.sys,'",envir=revive.sys)',
         sep=""), "cmd.msg")
    }
  )
  melde("SetPPMResolution",2)
}
SetJPGSize<-function(){
  melde("SetJPGSize",1)
  frage<-"jpg design size (3..8)?"; set.tclvalue("tvinfo",jpgdesignsize.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("jpgdesignsize.sys",h,envir=revive.sys)
      melde(paste(
  '> assign("jpgdesignsize.sys","',jpgdesignsize.sys,'",envir=revive.sys)',
         sep=""), "cmd.msg")
    }
  )
  melde("SetJPGSize",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[SetFontType]]}
\paragraph{[[SetFontType]] zur Auswahl eines Zeichensatzes.}
Dem Anwender werden nur die beiden Möglichkeiten
gegeben, die Größe und den Typ des Zeichensatzes zu verändern.
Dabei darf er wiederum jeweils nur aus einer begrenzten Menge
Möglichkeiten wählen. Um die Mißverständnisse klein zu halten,
sind in dem Optionenmenü deshalb zwei Eintragungen vorgesehen worden.

Besonders muß bei der Veränderung dieser Funktionen auf die Unterstützung
deutscher Umlaute geachtet werden. Für andere Anlagen kann der folgende
Vorschlag natürlich Anpassungen erfordern.

Der eingestellte Zeichensatz wird auf der Variablen [[tfont.sys]]
gehalten. Durch eine einfache Substitution wird gemäß der Anwenderwahl
eine neue Teilzeichenkette transplantiert. Bei dieser handelt es sich im
Fall des Typs zum Beispiel um [[helvetica]], im anderen um [[24-240]].
<<definiere Kopf-Zeilen-Funktionen>>=
SetFontType<-function(){
  melde("SetFontType",1)
  choices<-c("helvetica","courier","new century schoolbook","times")
  activate<-which(strsplit(tfont.sys,"-")[[1]][3]==choices)
  <<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>
  if(choice!=0){
    font<-choices[choice]
    tfont.sys<-sub("be-.+-Me",paste("be-",font,"-Me",sep=""),tfont.sys)
    tkconfigure(tworkwin,font=tfont.sys)
    assign("tfont.sys",tfont.sys,envir=revive.sys)
    ## if(exists("trevwin")) tkconfigure(trevwin, font=tfont.sys)
  }
  melde(paste("> font type changed"))
  melde("SetFontType",2)
}
@
Das Anzeigen der Wahlmöglichkeiten soll über einen eigenen Chunk erfolgen,
da es an anderer Stelle noch gebraucht wird.
<<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>=
menuwidget <- tkmenu(TopW); set.tclvalue("tvchoice","0")
for(i in choices) tkadd(menuwidget,"radiobutton",label=i,variable="tvchoice")
tkpost(menuwidget,"0","0"); tkactivate(menuwidget,activate)
tkbind(menuwidget,"<Escape>",function(){
       tkdestroy(menuwidget);set.tclvalue("tvchoice","0")})
<<warte, falls das OS NICHT Windows ist>>
choice <- tclvalue("tvchoice")
choice <- if(choice!="0") choice<-which(choice==choices) else 0

@
Die Festlegung der Größe der Zeichen verläuft entsprechend.
<<definiere Kopf-Zeilen-Funktionen>>=
SetFontSize<-function(){
  melde("SetFontSize",1)
  sizes<-c("8-80","10-100","12-120","14-140","18-180","24-240","*-2000")
  choices<-c("1 tiny","2 very small","3 small","4 normal","5 large",
             "6 very large","7 huge")
  activate<-which(substring(sub("(.*)Normal..","",tfont.sys),1,3)==substring(sizes,1,3))
  <<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>
  if(choice!=0){
    size<-sizes[choice]
    tfont.sys<-sub("al--.+-.+-\\*",paste("al--",size,"-*",sep=""),tfont.sys)
    tkconfigure(tworkwin,font=tfont.sys)
    assign("tfont.sys",tfont.sys,envir=revive.sys)
    outfont.sys<-sub("al--.+-.+-\\*",paste("al--",size,"-*",sep=""),outfont.sys)
    assign("outfont.sys",outfont.sys,envir=revive.sys)
    <<aktualisiere Texthervorhebungen>>
    tkconfigure(toutwin,font=outfont.sys)
    melde(paste("> font size changed"))
  }
  melde("SetFontSize",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[SetRelaxWinSize]]}
\paragraph{[[SetRelaxWinSize]] nicht interaktive Fenstergrößenveränderung.}
Unter Windows sträubt sich manchmal die Fensterverwaltung dagegen, dass man per Maus
die Größe des Relax-Fensters verändern kann. Deshalb wird alternativ eine
Menüoption angeboten.
<<definiere Kopf-Zeilen-Funktionen>>=
SetRelaxWinSize<-function(){
  melde("SetRelaxWinSize",1)
  frage<-"Size of relax window (width x height)?"
  set.tclvalue("tvinfo",paste(tclvalue(tkwinfo("width",TopW)),tclvalue(tkwinfo("height",TopW)),sep="x"))
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-tclvalue("tvinfo"); h <- gsub("[^0-9x]*","",h); h <- unlist(strsplit(h,"x"))
      if(2!=length(h) || any(0==nchar(h)) ) return()
      h <- try(as.numeric(h)); if(class(h)=="try-error") return(); h <- paste(pmax(h,250),collapse="x")
      tkwm.geometry(TopW,h); cat("relax window set to size",h)
      melde(paste("> maxol.sys <-",maxol.sys),"cmd.msg")
    }
  )
  melde("SetRelaxWinSize",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[SetOutputLength]]}
\paragraph{[[SetOutputLength]] zur Festsetzung der maximalen Outputlänge.}
Die Festlegung der
maximalen Output-Länge wird wie die der PS-Größen abgehandelt.
Wieder dient [[tvinfo]] als Kanal.
<<definiere Kopf-Zeilen-Funktionen>>=
SetOutputLength<-function(){
  melde("SetOutputLength",1)
  frage<-"maximum number of output character?"; set.tclvalue("tvinfo",maxol.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      if(!is.na(h)) assign("maxol.sys",h,envir=revive.sys)
      melde(paste("> maxol.sys <-",maxol.sys),"cmd.msg")
    }
  )
  melde("SetOutputLength",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[ConfigRelax]]}
\paragraph{[[ConfigRelax]] zur Setzung von Configurationsparametern.}
<<definiere Kopf-Zeilen-Funktionen>>=
ConfigRelax<-function(){
  melde("ConfigRelax",1)
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+15");tkpack(tt<-tktext(.newl))
      tkpack(fcmd<-tkframe(.newl))
      Save<-tkbutton(fcmd,width=15,text="save settings",command=function(){
		 newsettings<-paste(tclvalue(tkget(tt,"0.0","end")),"\n")
		 filename<-file.path(path.package("relax"),"config/settings.relax") # 130325 .path.package defunct
		 try(cat(file=filename,newsettings))
		 tkmessageBox(title="", icon="warning",
                          message="to get new settings work, relax has to be restarted")
		 print("new settings saved")
      })
      Exit<-tkbutton(fcmd,width=15,text="Exit",command=function(){
		 tkdestroy(.newl); set.tclvalue("tvscandone",2)
      })
      ReloadOld<-tkbutton(fcmd,width=15,text="reload old",command=function(){
		 settings<-get("settings",envir=revive.sys)
		 tkdelete(tt,"0.0","end")
                 try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      })
      LoadOrig<-tkbutton(fcmd,width=15,text="load original",command=function(){
	filename<-file.path(path.package("relax"),"config/settings.init") # 130325 .path.package defunct
        settings<-scan(file=filename,what="",sep="\n")
        try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      })
      tkpack(Save,ReloadOld,LoadOrig,Exit,side="left")
      tkwm.title(.newl,"view and change settings of relax: config/settings.relax")
      filename<-file.path(path.package("relax"),"config/settings.relax") # 130325 .path.package defunct
      settings<-scan(file=filename,what="",sep="\n")
      assign("settings",settings,envir=revive.sys)
      try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      tkbind(.newl,"<Escape>", function(){
		 tkdestroy(.newl); set.tclvalue("tvscandone",2)
	       })
      tkfocus(.newl)
      set.tclvalue("tvmess","relax")
  melde("ConfigRelax",2)
}
@
\subsubsection{Kopfzeile: [[Edit]]}
Bislang gibt es drei Einträge für Recherchen. Für diese sind
[[FindReportText]],
[[FindReportChunk]] und
[[FindRFns]]
zu definieren.

@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindReportText]]}
\paragraph{[[FindReportText]] zur Erleichterung der Navigation im
Arbeitsfenster.}
Zunächst wird von der aktuellen Zeile nach unten gesucht.
Wird dort nichts gefunden, beginnt die Suche am Anfang des Dokumentes.
Wird der eingegebene Suchstring gefunden, wird die Schreibmarke am Fundort
plaziert. Achtung: vgl. Funktion [[fFindText]].
<<definiere Kopf-Zeilen-Funktionen>>=
FindReportText<-fFindText
@
Zeitweise wurden die Funktionen unterschiedlich definiert,
doch aus Gründen der Vereinfachung sind nun die Funktionen
[[FindReportText]] und die Knopffunktion [[fFindText]] identisch.
Die Funktion [[fFindText]] wird zwar im Papier erst später definiert,
jedoch kommt sie durch die Zusammenbaulogik eher zum Zuge.
Die Definition der [[Tcl]]-Funktion ist nun hinter der Funktion [[fFindText]]
platziert worden.

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<FindReportText>>", FindReportText)
tkbind(TopW,"<F3>", function(){  # 050628
      set.tclvalue("tvmess","relax")
      if(!exists("string.sys",envir=revive.sys)) return()
      such.orig<-such<-get("string.sys",envir=revive.sys)
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      <<bearbeite Suchmuster [[such]] für Textsuche>>
      if(length(found<-grep(such,worktext))>0){
        <<ermittle Cursor-Zeile [[cline]] und Position [[cline.pos]]>>
        <<ermittle Text-Match nach Cursor: [[line]] und [[line.pos]]>>
        tksee(tworkwin,paste(line,".1",sep="")); h<-paste(line,".",line.pos,sep="")
        tkmark.set(tworkwin, "insert", h); tkfocus(tworkwin)
      } else set.tclvalue("tvmess",paste("Warning: search string >",
                                         such.orig,"< not found!!!"))
    } # end of function
)
@
Index-Anfang: immer 1!
<<ermittle Text-Match nach Cursor: [[line]] und [[line.pos]]>>=
# if nothing found in the cursor line or later go to the beginning of the document
line <- if(any(h<-(cline<found))) found[h][1] else found[1]
# look always for the first occurence, index origin: 1
h<-worktext[line]; hh<-1:nchar(h)
line.pos<- -1+which(such.orig==substring(h,hh,hh-1+nchar(such.orig)))[1]
# if cursor line and match line are equal you have to look at the positions
if(any(found==cline)){
  h<-worktext[cline]; hh<-1:nchar(h)
  found.pos<- -1+which(such.orig==substring(h,hh,hh-1+nchar(such.orig)))
  if(any(h<-(cline.pos<found.pos))) {line<-cline; line.pos<-found.pos[h][1]}
}

@
<<old-version>>=
tkbind(TopW,"<F3>", function(){  # 050628
      set.tclvalue("tvmess","relax")
      if(!exists("string.sys",envir=revive.sys)) return()
      such.orig<-such<-get("string.sys",envir=revive.sys)

      repl.pat<-gsub("(.)","\\\\\\1","^!$%&/()=?{}}+*#,.-;:\\_[") ## 070830
      repl.pat<-paste("([",repl.pat,"])",collapse="")
      such<-gsub(repl.pat,"\\\\\\1",such)
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      if(nchar(such)==0) {
        tcl("findclear",tworkwin); tkfocus(tworkwin); return()
      }
      if(length(found<-grep(such,worktext))>0){
        cline.pos <- as.character(tkindex(tworkwin,"insert"))
        cline <- floor(as.numeric(cline.pos))
        cline.pos<-as.numeric(sub(".*\\.","",cline.pos))
        line <- found[1]; in.act.line<-FALSE
        if(any(h<-(found>cline))) line<-found[h][1]
        if(any(found==cline)){
          h<-worktext[cline]
          found.pos<-which(such.orig==
                           substring(h,1:nchar(h),(1:nchar(h))-1+nchar(such.orig)))-1 
          if(any(found.pos>(cline.pos+2))){line<-cline; in.act.line<-TRUE}
        }
        tksee(tworkwin,paste(line,".1",sep=""))
        h<-worktext[line]
        # h<--1+charmatch(such,substring(h,1:nchar(h))); if(is.na(h)) h<-0 # 060605
        h<-which(such.orig==
                 substring(h,1:nchar(h),(1:nchar(h))-1+nchar(such.orig)))-1 # 091023
        h<-if(in.act.line) h[h>(cline.pos+1)][1] else h[1]; if(is.na(h)) h<-0
        h<-paste(line,".",h,sep="")
        tkmark.set(tworkwin, "insert", h[1]); tkfocus(tworkwin)

      } else set.tclvalue("tvmess",paste("Warning: search string >",
                                         such.orig,"< not found!!!"))
    } # end of function
)
@
<<unused>>=
FindReportText<-function(){
  melde("FindReportText",1)
  frage<-"search string?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      such.orig<-such<-string.sys<-tclvalue("tvinfo")
      repl.pat<-gsub("(.)","\\\\\\1","^!$%&/()=?{}}+*#,.-;:\\_[") ## 070830
      repl.pat<-paste("([",repl.pat,"])",collapse="")
      such<-gsub(repl.pat,"\\\\\\1",such)
      assign("string.sys",string.sys,envir=revive.sys)
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      if(nchar(such)==0) {
        tcl("findclear",tworkwin); tkfocus(tworkwin); return()
      }
      if(length(found<-grep(such,worktext))>0){
        line <- floor(as.numeric(tkindex(tworkwin,"insert")))
        line <- if(any(found>line)) found[found>line][1] else found[1]
        tksee(tworkwin,paste(line,".1",sep=""))
        h<-worktext[line]
        ## h<--1+charmatch(such,substring(h,1:nchar(h))); if(is.na(h)) h<-0 # 060605
        h<-which(such.orig==
                 substring(h,1:nchar(h),(1:nchar(h))-1+nchar(such.orig)))-1 # 091023
        if(is.na(h<-h[1])) h<-0
        h<-paste(line,".",h,sep="")
        tkmark.set(tworkwin, "insert", h[1]); tkfocus(tworkwin)
	# tworkwin<-get("tworkwin",envir=revive.sys)
        tktag.configure(tworkwin,"found",background="#000999fff",relief="raised")
        tcl("findmatches",tworkwin,such)
      } else set.tclvalue("tvmess",paste("Warning: search string >",tclvalue("tvinfo"),"< not found!!!"))
    } # end of function
  )
  melde("FindReportText",2)
}
# unused, too
proc<-c(  # 050628
   "proc findmatches {w pattern} {",
   "$w tag remove found    1.0 end",
   "  scan [$w index end] %d numLines",
   "  for {set i 1} {$i < $numLines} {incr i} {",
   "    $w mark set last $i.0",
   "    while {[regexp -indices $pattern \\",
   "       [$w get last \"last lineend\"] indices]} {",
   "     $w mark set first \"last + [lindex $indices 0] chars\"",
   "     $w mark set last \"last  + 1 chars\\",
   "                              + [lindex $indices 1] chars\"",
   "     uplevel [$w tag add found first last]",
   "     }",
   "  }",
   "}",
    "proc findclear w {",
      "$w tag remove found    1.0 end",
    "}"
  )
.Tcl(paste(proc,collapse="\n"))


@
<<definiere Kopf-Zeilen-Funktionen>>=
GoToLine<-function(){
  melde("GoToLine",1)
  if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
  tworkwin<-get("tworkwin",envir=revive.sys)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  frage<-"GOTO line?"; set.tclvalue("tvinfo",line)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      line<-string.sys<-tclvalue("tvinfo")[1]
      assign("string.sys",string.sys,envir=revive.sys)
      line<-as.numeric(line)
      if(!is.na(line)){
        tksee(tworkwin,h<-paste(line,".1",sep=""))
        tkmark.set(tworkwin, "insert", h); tkfocus(tworkwin)
      } else set.tclvalue("tvmess",paste("Warning: line",tclvalue("tvinfo"),"< not found!!!"))
    } # end of function
  )
  melde("GoToLine",2)
}
@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<GoToLine>>", GoToLine)

@
\subsubsection{Kopfzeile: [[Edit]] --- [[Search/Replace]]}
\paragraph{[[Search/Replace]] -- for searching and replacing.}
Search and Replace via tcltk.
code found on: http://wiki.tcl.tk/15612 proposed by Richard Suchenwirth 2006-03-17.
See also: http://wiki.tcl.tk/17294
<<definiere Kopf-Zeilen-Funktionen>>=
Replace<-function(){ #100917
  melde("Replace",1)
  tworkwin<-get("tworkwin",envir=revive.sys)
  .Tcl(paste("searchrep",tworkwin$ID))
  melde("Replace",2)
}

@
The Tcl procedure [[searchrep]] has to be implemented.
<<definiere Report-Text-Frame>>=
.Tcl("         
  # http://wiki.tcl.tk/15612
  proc searchrep {t {replace 1}} {
    set w .sr
    if ![winfo exists $w] {
        toplevel $w
        wm title $w \"Search\"
        grid [label $w.1 -text Find:] [entry $w.f -textvar Find] [
           button $w.bn -text Next -command [list searchrepnext $t]
                 ] -sticky ew
        bind $w.f <Return> [list $w.bn invoke]
        if $replace {
           grid [label $w.2 -text Replace:] [entry $w.r -textvar Replace] [
              button $w.br -text Replace -command [list searchreprep1 $t] 
                 ] -sticky ew
           bind $w.r <Return> [list $w.br invoke]
           grid [label $w.3 -text \"Please:\"] [
                 label $w.4 -text \" use <Next> first!\"] [
              button $w.ba -text \"Replace all\" -command [list searchrepall $t]
                 ] -sticky ew
        }
        grid x [checkbutton $w.i -text \"Ignore case\" -variable IgnoreCase] [
              button $w.c -text Cancel -command \"destroy $w\"
                 ] -sticky ew
        grid $w.i -sticky w
        grid columnconfigure $w 1 -weight 1
           $t tag config hilite -background yellow
    } else {raise $w}
 }
#-- Find the next instance
 proc searchrepnext w {
     foreach {from to} [$w tag ranges hilite] {
         $w tag remove hilite $from $to
     }
     set cmd [list $w search -count n -- $::Find insert+2c]
     if $::IgnoreCase {set cmd [linsert $cmd 2 -nocase]}
     set pos [eval $cmd]
     if {$pos ne \"\"} {
         $w mark set insert $pos
         $w see insert
         $w tag add hilite $pos $pos+${n}c
     }
 }
#-- Replace the current instance, and find the next
 proc searchreprep1 w {
     if {[$w tag ranges hilite] ne \"\"} {
         $w delete insert insert+[string length $::Find]c
         $w insert insert $::Replace
         searchrepnext $w
         return 1
     } else {return 0}
 }
#-- Replace all
 proc searchrepall w {
     set go 1
     while {$go} {set go [searchreprep1 $w]}
 }
")

@
\subsubsection{Kopfzeile: [[Revweb]]: [[LaTeX.head, WebReport, LatexReport, ViewReport]]}
Für die Verarbeitung zum \LaTeX-Dokument werden verschiedene
Menüpunkte für Profis angeboten. Dazu muss [[latex]] und [[yap]] sowie
eine Spezialform des noweb-Systems unter Windows installiert sein.

\paragraph{Web-Funktionalitäten.}
<<definiere Kopf-Zeilen-Funktionen>>=
### if(but.Wizardry=="all"){ }
 WebReport<-function(){
  melde("WebReport",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,replace.umlaute=replace.umlaute.sys))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  try(tangleR(workname.sys))
  cat(sub(".rev$",".R",workname.sys),"generated\n")
  melde("WebReport",2)
 }
 WeaveReport<-function(){
  melde("WeaveReport",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,replace.umlaute=replace.umlaute.sys))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  melde("WeaveReport",2)
 }
 ProcessWithSexpr<-function(){
  melde("ProcessWithSexpr",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,replace.umlaute=replace.umlaute.sys,eval_Sexpr = TRUE))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  LatexReport()
  melde("ProcessWithSexpr",2)
 }
 WeaveReportNoCode<-function(){
  melde("WeaveReportNoCode",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,show.code=FALSE,replace.umlaute=replace.umlaute.sys))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  melde("WeaveReportNoCode",2)
 }
 WeaveReportEchoCode<-function(){
  melde("WeaveReportNoCode",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,show.code="echo",replace.umlaute=replace.umlaute.sys))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  melde("WeaveReportNoCode",2)
 }
 WeaveReportNoText<-function(){
  melde("WeaveReportNoText",1)
  <<speichere Report als rev-Datei>>
  try(weaveR(workname.sys,show.text=FALSE,replace.umlaute=replace.umlaute.sys))
  cat(sub(".rev$",".tex",workname.sys),"generated\n")
  melde("WeaveReportNoText",2)
 }
 TangleReport<-function(){
  melde("TangleReport",1)
  <<speichere Report als rev-Datei>>
  try(tangleR(workname.sys))
  cat(sub(".rev$",".R",workname.sys),"generated\n")
  melde("TangleReport",2)
 }
 TangleReportNoComments<-function(){
  melde("TangleReportNoComments",1)
  <<speichere Report als rev-Datei>>
  try(tangleR(workname.sys,insert.comments=FALSE))
  cat(sub(".rev$",".R",workname.sys),"generated\n")
  melde("TangleReportNoComments",2)
 }
 TangleReportChunk<-function(){
  melde("TangleReportChunk",1)
  <<speichere Report als rev-Datei>>
  revfile<-readLines(workname.sys)
  codechunks<-grep(paste("^<","<.*",">",">","=",sep=""),revfile) 
  if(length(codechunks)==0) return()
  codechunks<-revfile[codechunks]; codechunks<-unique(codechunks)
  if(0==(ind<-menu(codechunks))) return()
  TLD<-codechunks[ind]; TLD<-sub(paste("^<","<(.*)",">",">","=",sep=""),"\\1",TLD)
  try(tangleR(workname.sys, expand.roots=TLD,expand.root.start=FALSE))
  cat("Remark: processing without saving of",workname.sys,"\n")
  cat(sub(".rev$",".R",workname.sys),"generated\n")
  melde("TangleReportChunk",2)
 }
 LaTeX.head<-function(){
  melde("LaTeX.head",1)
  # news<-scan(file=paste(path.package("relax"),"lib/LaTeX-head.tex",sep="/"),what="",sep="\n")
  news<-readLines(paste(path.package("relax"),"lib/LaTeX-head.tex",sep="/")) # 2.1.0 # 130325 .path.package defunct
  news<-sub("NOWEBSTYLEFILE",file.path(relax.path,"lib","noweb"),news)
  news<-sub("JOBPATH",getwd(),news); news<-c(news,"")
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  line<-"2.0"
  <<schreibe [[news]] hinter [[line]]>>
  melde("LaTeX.head",2)
 }
# LatexReport<-function(){
  LatexReport<-function(...,filename){ ## test???
  melde("LatexReport",1)
  if(!missing(filename)) workname.sys <- filename
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","tex",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".tex"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"not found!!!\n");return()
  }
  melde("latex process starts, messages: see output window\n") 
  # 060116: show logfile
  if(<<das OS ist Windows>>){
      latex<-paste(latex.command.windows," ",filename,sep="")
      ok<-try(shell(latex,wait=TRUE))
  }else{ 
      latex<-paste(latex.command.linux," ",filename,sep="")
      ok<-try(system(latex))
  }
  if(ok!=0){ 
        fname<-sub("tex$","log",filename); txt<-readLines(fname)
        ind<-c(grep("(^[!])",txt)[1],grep("^[?].q",txt)[1])
        ind<-ind[!is.na(ind)]
        if(0==length(ind)) ind<-length(txt)-10
        ind<-(-8+min(ind)):(-1+max(ind)); txt<-txt[ind]
        line<-grep("(^l[.][0-9])",txt,value=TRUE)
        line<-line[!is.na(line)]
        if(0<length(line)){
          line<-paste("......\n-> find error line by pressing <Ctrl/Strg> <G>  + line number:",
                      sub("..([0-9]*).*","\\1",line))
        }else{
          line<-"-> Wizardry -> ShowLogFile "
        }
        txt<-c(
                "!!!ERROR in LaTeX process !!!\n-- for details look at the log file\n",
                " \nExtract of LaTeX log file:\n......",txt,line
             )
        cat(txt,sep="\n")
  }
  cat("latex process finished:",filename)
  melde("LatexReport",2)
 }
 ShowLogFile<-function(){
  melde("ShowLogFile",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","log",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".log"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){ cat("ERROR: file",filename,"not found!!!\n");return() }
  cmd <-paste(editor.sys, filename)
  if(<<das OS ist Windows>>){
      try(shell(cmd,wait=FALSE))
  }else{
    if( <<OS ist Mac-Mini>> ){
      cmd<-paste(view.command.mac,filename)
    } 
    try(system(paste(cmd," &")))
  }
  melde("ShowLogFile",2)
 }
 ViewReport<-function(){
  melde("ViewReport",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","dvi",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".dvi"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(<<OS ist Mac-Mini>> ){
        filename<-sub("dvi$","pdf",filename)   
  }    
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"not found!!!\n");return()
  }
  if(<<das OS ist Windows>>){
      view<-paste(view.command.windows," ",filename,sep="")
      try(shell(view,wait=FALSE))
  }else{
      if(<<das OS ist Linux>>) 
        view<-paste(view.command.linux,"  ",filename," &",sep="")
      if(<<OS ist Mac-Mini>> ){
        view<-paste(view.command.mac,"  ",filename," &",sep="")
      }
      try(system(view))
  }
  melde("ViewReport",2)
 }
 DvipdfReport<-function(){  #050607
  melde("DvipdfReport",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","dvi",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".dvi"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){
      cat("ERROR: file",filename,"not found!!!\n");return()
  }
  if(<<das OS ist Windows>>){
      dvipdf<-paste(dvipdf.command.windows," ",filename,sep="")
      try(shell(dvipdf,wait=FALSE))
  }else{
      dvipdf<-paste(dvipdf.command.linux,"  ",filename," &",sep="")
      try(system(dvipdf))
  }
  cat("\"",dvipdf,"\" has been started!\n")
  melde("DvipdfReport",2)
 }
 ProcessReport<-function(){
    <<speichere Report als rev-Datei>>    
    if(0==length(grep("documentclass", worktext)))
      cat("Warning: there is no \\documentclass-command in the file:",
           "LaTeX needs a preamble for processing tex-files!",sep="\n")
    Sys.sleep(0.25)
    try(weaveR(workname.sys,replace.umlaute=replace.umlaute.sys))
    Sys.sleep(0.5)
    LatexReport()
 }
 <<definiere [[ProcessChunk]]>>
 SWEAVE<-function(){ ###060112
    workname.Rnw<-sub("rev$","rnw",workname.sys)
    if(file.exists(filename<-file.path(getwd(),workname.sys))){
      res<-tkmessageBox(message=
                 if(language=="german") 
                    paste("Datei",workname.sys,"oder",workname.Rnw,
                              "existiert. Soll(en) sie ersetzt werden?")
	         else paste(filename,"or",workname.Rnw,
                                 "exists. Do you want to replace it/them?"),
                 title="Save File",icon="warning",type="yesnocancel",default="yes")
      if("externalptr"==mode(res))  res<-tclvalue(res)
      if(res=="cancel") return(); if(res=="no") return() 
    }
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
    Sys.sleep(0.25)
    file.copy(workname.sys,workname.Rnw,overwrite = TRUE)
    frage<-"add additional arguments for Sweave then return:"
    set.tclvalue("tvinfo",sweave.args.sys)
    <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
    tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      sweave.args.sys<-tclvalue("tvinfo")
      assign("sweave.args.sys",sweave.args.sys,envir=revive.sys)
      if(nchar(sweave.args.sys)!=0) {
        sweave.call<-paste("Sweave(\"",workname.Rnw,"\",",sweave.args.sys,")",sep="")
      } else sweave.call<-paste("Sweave(\"",workname.Rnw,"\")",sep="")
      try(eval(parse(text=sweave.call),envir=revive.env))
      Sys.sleep(0.5); LatexReport()
      cat("check R-window for messages!\n")
    } # end of function
  )
 } # end of SWEAVE
SWEAVEB<-function(){ ###060112
    workname.Rnw<-sub("rev$","rnw",workname.sys)
    if(file.exists(filename<-file.path(getwd(),workname.sys))){
      res<-tkmessageBox(message=
                 if(language=="german") 
                    paste("Datei",workname.sys,"oder",workname.Rnw,
                              "existiert. Soll(en) sie ersetzt werden?")
	         else paste(filename,"or",workname.Rnw,
                                 "exists. Do you want to replace it/them?"),
                 title="Save File",icon="warning",type="yesnocancel",default="yes")
      if("externalptr"==mode(res))  res<-tclvalue(res)
      if(res=="cancel") return(); if(res=="no") return() 
    }
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
    Sys.sleep(0.25)
    file.copy(workname.sys,workname.Rnw,overwrite = TRUE)
    frage<-"add additional arguments for Sweave then return:"; set.tclvalue("tvinfo",sweave.args.sys)
    <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
    tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      sweave.args.sys<-tclvalue("tvinfo")
      assign("sweave.args.sys",sweave.args.sys,envir=revive.sys)
      if(nchar(sweave.args.sys)!=0) {
        sweave.call<-paste("Sweave(\"",workname.Rnw,"\",",sweave.args.sys,")",sep="")
      } else sweave.call<-paste("Sweave(\"",workname.Rnw,"\")",sep="")
      infile<-tempfile("sweavein"); outfile<-tempfile("sweaveout")
      cat(file=infile,sweave.call,"\n")
   cmd<-paste(R.home(),"/bin/Rcmd BATCH ",infile," ",
                outfile,sep="")
if(<<das OS ist Windows>>){
   shell(cmd)
}else{
    system(cmd)
}
      news<-readLines(outfile)
      <<schreibe [[news]] ans Ende des Outputfeldes>>
      Sys.sleep(0.5); LatexReport()
      cat("check R-window for messages!\n")
    } # end of function
  )
 } # end of SWEAVEB


@
Manchmal will man aus einem langen Dokument nur einen kleine Ausschnitt sehen.
[[ProcessChunk]] ermittelte anhand des Cursors den nächsten Code und fügt 
Präambel, Text-Stück und Code zusammen und verarbeitet diese. Dazu wir das
Extrakt auf "local-chunk-rev" abgelegt.
<<definiere [[ProcessChunk]]>>=
ProcessChunk<-function(){
  filename <- "local-chunk.rev"
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  code.start <- grep(paste("^<","<.*>",">=",sep=""),worktext)
  text.start <- grep("^@",worktext)
  doc.start <- grep("^.begin.document.",worktext)
  if(0 == doc.start) { cat("relax warning: no begin document found"); return()}
  if(0 < length(code.start)){  # if 0 no code at all => process complete report
    code.h <- code.start[code.start <= line] 
    if(0 == length(code.h)){ 
      # no code in front of cursor => process from beginning to first code chunk
      code.start <- code.start[1]
      text.h <- c(text.start,length(worktext)+1)
      code.end <- text.h[code.start < text.h][1] - 1
      worktext <- worktext[1:code.end]
    } else {
      cursor.in.code <- TRUE
      text.h <- text.start[text.start <= line] 
      if(0<length(text.h) && code.h[length(code.h)] < text.h[length(text.h)] ){
        # cursor is in text chunk => take text beginning after the end of the last code chunk
        extract.start <- text.h[code.h[length(code.h)] < text.h][1]
        code.h <- code.start[line < code.start] 
        if(0 == length(code.h)){
          # no code after cursor
          extract.end <- length(worktext)
        } else {
          text.h <- text.start[code.h[1] < text.start]
          extract.end <- if(0 == length(text.h)) length(worktext) else text.h[1] - 1
        }
        worktext <- c(worktext[1:doc.start],worktext[extract.start:extract.end])
      } else {
        # cursor is in code chunk => take code end before text chunk up to the end of the code chunk
        if(1 == length(code.h)) extract.start <- doc.start + 1 else {
          code.h <- code.h[length(code.h) - 1]
          extract.start <- text.h[code.h < text.h][1]        
        }
        text.h <- text.start[line < text.start] 
        extract.end <- if(0 == length(text.h)) length(worktext) else text.h[1]-1
        worktext <- c(worktext[1:doc.start],worktext[extract.start:extract.end])
      }
    }
  }
  TcltoWin.write <- get("TcltoWin.write",envir=revive.sys)
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  Sys.sleep(0.25)
  try(weaveR(filename,replace.umlaute=replace.umlaute.sys))
  Sys.sleep(0.5)
  ## LatexReport()
  LatexReport(filename=filename)
  cat("look at formated file or log file of  'local-chunk'")  
}

@
Manchmal ist kein Chunk das Ziel zum Ausschneiden, sondern es könnte auch eine Gruppe oder
ein Abschnitt sein. Deshalb wird noch eine Alternative bereitgestellt, die eine Begin-End-Gruppe 
extrahiert. Bspw.\ könnte es sich hierbei um eine Center-, Minipage-, Fussypar- o.ä.\ Umgebung handeln.
Wenn man keine weitere Störung des Dokumentes haben will, geht auch die Abgrenzung durch
[[\begingroup]] und [[\endgroup]]. Der Normalanwender wird wahrscheinlich eher auf
Minipage-Konstruktionen zurückgreifen: [[\begin{minipage}{\textwidth}]].
<<definiere [[ProcessChunk]]>>=
ProcessBeginEndEnv<-function(){
  filename <- "local-chunk.rev"
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<extrahiere Begin-End-Umgebung in [[worktext]] mittels Cursor-Zeile [[line]]>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  Sys.sleep(0.25)
  try(weaveR(filename,replace.umlaute=replace.umlaute.sys))
  Sys.sleep(0.5)
  LatexReport(filename=filename)
  cat("look at formated file or log file of  'local-chunk'")  
}

@
Für das relax-eigene Sweave von Dokumentteilen wird die Extraktion der Umgebung, in der 
sich der Cursor aufhält als eigener Chunk formuliert.  
<<extrahiere Begin-End-Umgebung in [[worktext]] mittels Cursor-Zeile [[line]]>>=
  worktext <- sub("%.*$","",worktext)
  doc.start   <- grep("^.begin.document.",worktext)
  if(0 == length(doc.start)) { cat("relax warning: no begin document found"); return()}
  env.start <- grep("\\\\begin\\{",worktext) ; env.start <- env.start[env.start != doc.start] # } for symmetry
  env.end   <- grep("\\\\end\\{",worktext)  # } for symmetry
  idx.start <- idx.end <- rep(0,length(worktext))
  idx.start[env.start] <- 1; idx.end  [env.end  ] <- 1
  counter <- 0*idx.start; depth <- 0
  for( i in 1:length(counter)){
    counter[i] <- depth <- max(0, depth - idx.end[i] + idx.start[i])
  }
  #  counter <- cumsum(idx.start) - cumsum(idx.end) # fail if there are too much ends
  extract.start <- which(counter == 0 & seq(along=counter) < line)
  extract.start <- if(0 < length(extract.start)) max(extract.start) + 1 else doc.start + 1
  extract.end   <- which(counter == 0 & seq(along=counter) >= line)
  extract.end   <- if(0 < length(extract.start)) min(extract.end)       else length(worktext)  
  worktext <- c(worktext[1:doc.start],worktext[extract.start:extract.end],"\\end{document}")

@
Zum Testen kann folgender Chunk in den Report-Manager geladen werden. Dann muss nicht jedesmal 
das gesamte Paket übersetzt werden.
<<teste ProcessChunk>>=
ol <- ls(envir=revive.sys)
for(o in ol){ ## print(o)
  if(0<length(grep("tmp",o))) next
  if(0<length(grep("file.name",o))) next
  try(eval(parse(text=paste(o," <- get('",o,"',envir=revive.sys)",sep=""))))
}
system("notangle -R'definiere [[ProcessChunk]]' ../relax.rev > testchunk")
txt <- readLines("testchunk")
eval(parse(text=txt)); eval(parse(text=txt),envir=revive.sys) 
# ProcessChunk() # aus Report
# eval(parse(text="ProcessChunk()"),envir=get("revive.sys",revive.env)) # aus Konsole
 
@
\paragraph{Demo-Funktion.}
<<definiere Kopf-Zeilen-Funktionen>>=
ConstructDemoFunction<-function(){
  melde("ConstructDemoFunction",1)
  <<speichere Report als rev-Datei>>    
  if(!file.exists(workname.sys)){
    cat(paste("Error: File",workname.sys,"not found!!!"));return()
  }
#  cat("Remark: processing without saving of",workname.sys,"\n")
  try(tangleR(workname.sys))
  workname<-sub(".rev$",".R",workname.sys)
  cat(workname,"generated\n")
  chunks<-where<-""
  txt<-scan(workname,"",sep="\n")
  <<DemoFunctionHead>>
  fh<-deparse(fh); fh<-fh[-length(fh)]
  <<DemoFunctionTail>>
  ft<-deparse(ft)[-(1:2)]
  ft<-sub("WoRkNaMe",workname,ft)
  fname<-gsub("[^A-Za-z]","",sub(".R$",".demo",workname))
  txt<-gsub("\\\\","\\\\\\\\",txt)
  txt<-gsub("\"","\\\\\"",txt)
  txt<-paste(',"',txt,'"',sep=""); txt[1]<-substring(txt[1],2)
  txt<-c(paste(fname,"<-"),fh,"chunks<-c(",txt,")",ft
         ,paste("cat(\"Demo will be started by > ",fname,"()\\n\")",sep="")
         ,paste(fname,"()\n",sep="")
      )
  workname<-sub(".R$",".demo.R",workname)
  cat(txt,file=workname,sep="\n")
  cat("Demo in file ",workname," saved, load demo by source(\"",workname,"\") \n",sep="")
  melde("ConstructDemoFunction",2)
}

@
Natürlich könnte es auch hilfreich sein, unabhängig von [[relax()]] eine
Demo-Funktion auf Basis eines [[rev]] oder [[snw]]-Files zu erstellen.
Durch Ersetzung des Anfangs von [[ConstructDemoFunction]] ist diese kein
Problem.
<<*>>=
ConstructDemo <- function(file=""){
  require(tcltk)
  if(file==""){ cat("sorry, please call ConstructDemo with name of R-, rev- or a Snw-file\n");            
                return() } 
  <<checke, ob .R-file existent oder probiere .R-file zu generieren>>

  workname <- file; chunks <- where <- ""
  txt <- scan(workname,"",sep="\n")
  <<DemoFunctionHead>>; fh <- deparse(fh); fh<-fh[-length(fh)]; <<DemoFunctionTail>>
  ft <- deparse(ft)[-(1:2)]; ft <- sub("WoRkNaMe",workname,ft)
  fns.name <- gsub("[^A-Za-z]","",sub(".R$",".demo",workname))
  txt <- gsub("\\\\","\\\\\\\\",txt); txt <- gsub("\"","\\\\\"",txt)
  txt <- paste(',"',txt,'"',sep=""); txt[1]<-substring(txt[1],2)
  txt <- c(paste(fns.name,"<-"),fh,"chunks<-c(",txt,")",ft
           ,paste("cat(\"Demo will be started by > ",fns.name,"()\\n\")",sep="")
           ,paste(fns.name,"()\n",sep="")
      ) 
  workname<-sub(".R$",".demo.R",workname)
  cat(txt,file=workname,sep="\n")
  cat("Demo saved in file ",workname,", load demo by source(\"",workname,"\") \n",sep="")
}

@
Der Mechanismus wiederholt sich, jedoch gibt es verschiedene Aufrufsituationen. Deshalb werden
hier ein paar Aufrufe zum Testen aufgelistet.
<<teste ConstructDemo und CodeChunkPlayer>>=
#  R --vanilla
library(relax,lib.loc="/home/wiwi/pwolf/R/work/relax/install.dir/lib")
CodeChunkPlayer()
file.remove("out.R"); CodeChunkPlayer("out.R")
file.remove("out.R"); CodeChunkPlayer("out.rev")
file.remove("out.R"); CodeChunkPlayer("out")
file.remove("out.R"); file.copy("out.rev","out.SNW"); CodeChunkPlayer("out.SNW")
file.remove("out.R"); file.copy("out.rev","out.xxxxx.hallo"); CodeChunkPlayer("out.xxxxx.hallo")
file.remove("out.demo2.R"); file.copy("out.rev","out2.nw"); CodeChunkPlayer("out2.nw")
ConstructDemo()
file.remove("out.demo.R"); ConstructDemo("out.R"); source("out.demo.R")
file.remove("out.demo.R"); ConstructDemo("out.rev"); source("out.demo.R")
file.remove("out.demo.R"); ConstructDemo("out"); source("out.demo.R")
file.remove("out.demo.R"); file.copy("out.rev","out.SNW"); ConstructDemo("out.SNW"); source("out.demo.R")
file.remove("out.xxxxx.demo.R"); 
file.copy("out.rev","out.xxxxx.hallo"); ConstructDemo("out.xxxxx.hallo"); source("out.xxxxx.demo.R")
file.remove("out.demo2.R"); 
file.copy("out.rev","out2.nw"); ConstructDemo("out2.nw"); source("out2.demo.R")

@
\paragraph{StartCodeChunkPlayer.}
[[ConstructDemoFunktion()]] konstruiert eine neue Demo-Funktion, 
mit der dann unabhängig von relax die einzelnen Chunks aktiviert werden können. 
Innerhalb von relax kann eine solche Funktion ebenfalls hilfreich sein, 
um in einen anderen Arbeitsmodus zu gelangen.
Beispielsweise kann ausgehend von dem Papier aus relax heraus, die Konzentration rein auf die Code-Chunks, 
deren Aktivierung sowie die Auswertung der Ergebnisse gelenkt werden: 
Present And Start Code And Look: PASCAL!
Diese Möglichkeit wird von [[StartCodeChunkPlayer()]] umgesetzt.
<<definiere Kopf-Zeilen-Funktionen>>=
StartCodeChunkPlayer<-function(){
  melde("StartCodeChunkPlayer",1)
  cat("Code-Chunk-Player saves actual version of",workname.sys,"\n") 
  <<speichere Report als rev-Datei>>
  try(tangleR(workname.sys)); workname<-sub(".rev$",".R",workname.sys); cat(workname,"generated\n")
  chunks<-where<-""; txt<-scan(workname,"",sep="\n")
  # construct structure of function
  <<DemoFunctionHead>>; fh<-deparse(fh); fh<-fh[-length(fh)]; <<DemoFunctionTail>>
  ft<-deparse(ft)[-(1:2)]; ft<-sub("WoRkNaMe",workname,ft)
  # modify function for StartCodeChunkPlayer
  txt<-c("CCPlayer<-",fh,"    chunks<-readLines(file)",ft,"CCPlayer()")
  # set file argument
  txt[2] <- sub("file",paste("file = '",workname,"'",sep=""),txt[2]) 
  # use argument no as start chunk number
  idx <- grep("^    no .. 0",txt); txt[idx] <- sub("0","no #set start chunk",txt[idx])
  # modify title
  idx <- grep("tkwm.title",txt); txt[idx] <- sub("Peter Wolf.","",txt[idx])
  txt[idx] <- sub("demo of file","Code-Chunk-Player, file:",txt[idx])
  # modify exit message
  idx <- grep("Demo function stopped",txt); 
  txt[idx] <- sub("Demo function stopped without","Code-Chunk-Player stopped without",txt[idx])
  # set evaluation should take place in revive.env
  idx <- grep("environment",txt); txt[idx] <- sub("environment..","revive.env",txt[idx])
  # print viewer function for debugging
  melde(paste(txt,collapse="\n"),2)
  # start of history viewer
  try(eval(parse(text=txt),envir=revive.env))
  melde("StartCodeChunkPlayer",2)
}

@
Ein Code-Chunk-Player soll auch als eigenständige Funktion zur Verfügung stehen. 
Für diesen Fall wird eine leicht modifizierte Version gegenüber der Menüfunktion Code-Chunk-Player geschaffen. Für den Fall, dass ein .R-file übergeben wird, wird dieser verwendet.
Zum Testen con CodeChunkPlayer siehe: [[<teste ConstructDemo und CodeChunkPlayer>]].
<<*>>=
CodeChunkPlayer<-function(file=""){
  require(tcltk)
  if(file==""){ cat("sorry, please call player with name of R-, rev- or a Snw-file\n");            
                return() } 
  <<checke, ob .R-file existent oder probiere .R-file zu generieren>>
  if( !file.exists(file) ){
    cat("sorry, .R-file not found or unable to construct .R-file\n");return() 
  } 
  workname <- file; chunks<-""; where<-""
  txt<-scan(workname,"",sep="\n")
  # construct structure of function
  <<DemoFunctionHead>>; fh<-deparse(fh); fh<-fh[-length(fh)]; <<DemoFunctionTail>>
  ft<-deparse(ft)[-(1:2)]; ft<-sub("WoRkNaMe",workname,ft)
  # modify function
  txt<-c("CCPlayer<-",fh,"    chunks<-readLines(file)",ft,"CCPlayer()")
  # set file argument
  txt[2] <- sub("file",paste("file = '",workname,"'",sep=""),txt[2]) 
  # set no argument as start chunk number
  idx <- grep("^    no .. 0",txt); txt[idx] <- sub("0","no #set start chunk",txt[idx])
  # modify title
  idx <- grep("tkwm.title",txt); txt[idx] <- sub("Peter Wolf.","",txt[idx])
  txt[idx] <- sub("demo of file","Code-Chunk-Player, file:",txt[idx])
  # modify exit message
  idx <- grep("Demo function stopped",txt); 
  txt[idx] <- sub("Demo function stopped without","Code-Chunk-Player stopped without",txt[idx])
  # print viewer function for debugging:    print(txt)
  # start of Code-Chunk-Player
  try(eval(parse(text=txt)))
  invisible(NULL)
}

@
<<checke, ob .R-file existent oder probiere .R-file zu generieren>>=
if(  ( 0 == length(grep(".R$",file))) || !file.exists(file) ){ 
    # .R must be generated&   
    file <- sub("\\.R$",".rev",file)  # rev name of not existing file if .R file
    if(!file.exists(file)){
      file <- sub("\\.rev$","",file)  # base name of file if .rev file
      if(!file.exists(file)) file <- paste(file,".rev",sep="")  
      if(!file.exists(file)) file <- sub("\\.rev$",".Snw",file)  
      if(!file.exists(file)) file <- sub("\\.Snw$",".snw",file) 
      if(!file.exists(file)) file <- sub("\\.snw$",".nw",file)   
      if(!file.exists(file)) file <- sub("\\.nw$",".SNW",file)  
      if(!file.exists(file)) file <- sub("\\.SNW$","",file)   
      if(!file.exists(file)){
        cat(paste("sorry, error: File",file,"not found!!!"));return()
      }
    } 
    cat("function will work on file",file,"\n") 
    # construct a .R file
    try(tangleR(file))
    # file <- sub(".rev$","",file); file <- sub(".[sS]{0,1}[nN][wW]$","",file)
    file <- sub("\\.[a-zA-Z]+$","",file)
    file <- paste(file,".R",sep=""); cat(file,"generated\n")
}

@
\paragraph{Historie-Funktion.}
Manchmal hat man diverse Chunks aktiviert, hat jedoch die Übersicht verloren, was so alles
passiert ist. Deshalb ist es hilfreich, wenn man sich durch die vergangenen Evaluierungen
durchklicken könnte. Die Zaubereieintrag [[ShowHistory]] konstruiert aufgrund der gespeicherten
Code-Chunks, die zur Aktivierung anstanden eine History-Rev-Datei und tanglet diese.
Weiter wird eine Funktion konstruiert, die das getanglte Ergebnis einliest und wie bei der 
Demofunktion eine kleine Oberfläche zum Durchklicken bereitstellt, und startet sie zum Abschluss.
Das kleine neue Fenster besitzt auch einen Aktivierungsknopf, der zu einer Aktivierung 
in der Umgebung [[revive.env]] führt.

Hinweis: Beim Evaluieren werden Ausdrücke, die zu Warnungen führen, ohne den Hinweis auf diese Warnungen evaluiert!
<<definiere Kopf-Zeilen-Funktionen>>=
assign("relax.history",
       c(if(0<length(ls(pattern="relax.history",envir=revive.sys))) # to extend existing history
         get("relax.history",envir=revive.sys) else NULL,           # to extend existing history
         list(c("@",paste("<","<*>",">=",sep=""),paste("# relax history file --",date())))
       )                                                           # to extend existing history
       ,envir=revive.sys)
ShowHistory<-function(){
  melde("ShowHistory",1)
  <<check, save and tangle history>>
  # construct history viewer
  chunks<-where<-"" # to reduce warnings during package construction
  <<DemoFunctionHead>>; fh<-deparse(fh); fh<-fh[-length(fh)]; <<DemoFunctionTail>>
  ft<-deparse(ft)[-(1:2)]; ft<-sub("WoRkNaMe",workname,ft)
  txt<-c("relax.hist<-",fh,"    chunks<-readLines(file)",ft,"relax.hist()")
  # adapt arguments
  txt[2] <- sub("TRUE","FALSE",txt[2])
  txt[2] <- sub("[1]",length(relax.history),txt[2])
  txt[2] <- sub("file",paste("file = '",workname,"'",sep=""),txt[2])
  # starting chunk: newest one
  idx <- grep("^    no .. 0",txt); txt[idx] <- sub("0","no #set start chunk",txt[idx])
  # modify title
  idx <- grep("tkwm.title",txt); txt[idx] <- sub("demo of file","history saved in file",txt[idx])
  # simplify exit.function of viewer
  idx <- grep("exit.function.*function",txt)
  txt[idx] <- paste(txt[idx]," tkdestroy(top);return() }; exit.demo <- function(){")
  # evaluation should take place in revive.env
  idx <- grep("environment",txt); txt[idx] <- sub("environment..","revive.env",txt[idx])
  # print viewer function during debugging
  melde(paste(txt,collapse="\n"),2)
  # start of history viewer
  try(eval(parse(text=txt),envir=revive.env))
  melde("ShowHistory",2)
}

@
<<check, save and tangle history>>=
  # check history
  if(0==length(grep("relax.history",ls(envir=revive.sys)))){ 
    cat("relax warning: no history found"); return() 
  }
  # save history in file
  relax.history<-get("relax.history",envir=revive.sys); txt<-unlist(relax.history)
  workname<-sub(".rev$",".history.rev",get("workname.sys",envir=revive.sys))
  base::cat(txt,file=workname,sep="\n")
  # tangle history file
  try(tangleR(workname)); workname<-sub(".rev$",".R",workname)
  cat(sub(".R$",".rev",workname),"/",workname,"generated\n")

@
<<definiere Kopf-Zeilen-Funktionen>>=
SaveHistory<-function(){
  melde("SaveHistory",1)
  <<check, save and tangle history>>
  melde("SaveHistory",2)
}

@
Speicherung des Reports ist vor manchen Jobs erfordlich.
<<speichere Report als rev-Datei>>=
    if(file.exists(filename<-file.path(getwd(),workname.sys))){
      res<-tkmessageBox(message=
                 if(language=="german") 
                    paste("Datei",filename,"existiert. Soll sie ersetzt werden?")
	         else paste(filename,"exists. Do you want to replace it?"),
               title="Save File",icon="warning",type="yesnocancel",default="yes")
      if("externalptr"==mode(res))  res<-tclvalue(res)
      if(res=="cancel")return()
      if(res=="no"){msg<-SaveReport(); if(msg=="cancel") return()}  #050607
    }
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
    if(ok){
      melde(paste("report file",filename,"saved\n"),0)
      melde(paste("w",workname.sys),"cmd.msg")
    } else {
      cat("ERROR: write operation failed!!!\n"); return()
    }





@
<<unused>>=
fname<-"ErgebnisSpeicherung.log"
txt<-readLines(fname)
ind<-grep("(^[!])|(^[?].q)|(^l[.][0-9])",txt)
ind<-(-8+min(ind)):(-1+max(ind))
txt<-txt[ind]
line<-grep("(^l[.][0-9])",txt,value=TRUE)
if(0<length(line)){
  line<-paste("...\n-> find error line by pressing <Ctrl/Strg> + line number:",
              sub("..([0-9]*).*","\\1",line))
}else{
 line<-"-> Wizardry -> ShowLogFile "
}
txt<-c("LaTeX-Error-Message from log file:\n...",txt,line)
cat(txt,sep="\n")

@
Die Demo-Funktion ist im Rahmen des Buches
Wolf, Naeve, Tiemann: Crash-Kurs Statistik: aktiv mit R
entwickelt worden.
<<DemoFunctionHead>>=
fh<-function(file,no=1,start=TRUE){
  # initial code of demo function
  require("tcltk"); where<-environment()
}

@
Die Logik für das CLIPBOARD ist angepasst entnommen von: [[<definiere Report-Text-Frame>]].
<<DemoFunctionTail>>=
ft<-function(){
  # end of code of demo function
  ## activate start chunk
  if(start==TRUE){
    no.0<-"0"
    no.start.0<-grep(paste("^#",no.0,":$",sep=""),chunks)
    no.end.0<-grep(paste("^#:",no.0,"$",sep=""),chunks)
    code.0<-chunks[no.start.0:no.end.0]
    eval(parse(text=code.0),envir=where)
  }
  ## activate chunk no
  # eval(parse(text=code),envir=where)
  secno<-tclVar("1") # 0
  show.next.number<-function(...){
   no<-as.character(as.numeric(tclvalue(secno))+1)
   <<hole chunk Nummer>>
   if(0<length(code)) {
    tkdelete(ttext,"0.0","end")  
    tkinsert(ttext,"0.0",code)
    tclvalue(secno)<-as.character(no)
    }
  }
  show.back.number<-function(...){
   no<-as.character(as.numeric(tclvalue(secno))-1)
   <<hole chunk Nummer>>
   if(0<length(code)) {
    tkdelete(ttext,"0.0","end")  
    tkinsert(ttext,"0.0",code)
    tclvalue(secno)<-as.character(no)
   }
  }
  show.number<-function(...){
   no<-as.character(as.numeric(tclvalue(secno)))
   <<hole chunk Nummer>>
   if(0<length(code)) {
    tkdelete(ttext,"0.0","end")  
    tkinsert(ttext,"0.0",code)
    tclvalue(secno)<-as.character(no)
   }
  }
  eval.code<-function(...){
    code<-tclvalue(tkget(ttext,"0.0","end"))
    code.orig<-code<-unlist(strsplit(code,"\n"))
    code<-code[!substring(code,1,1)=="#"]
    ##?## code<-unlist(strsplit(code,";"))  ##110429 Fehler bei sep=";"
    if(length(code)==0){ cat("ok\n"); return() }
    result<-try(eval(parse(text=code),envir=where))
    code.orig<-sub("#([0-9]+):","##wnt-Code-Chunk:\\1-begin#",code.orig)
    code.orig<-sub("#:([0-9]+)","##wnt-Code-Chunk:\\1-end#",code.orig)
    h<-get("allcodechunks",envir=where)
    h<-c(h,paste("<","<*>",">=",sep=""),code.orig,"\n@\n")
    assign("allcodechunks",h,envir=where)
    code<-sub("^ *","",code)
    code<-code[nchar(code)>0]
    lexpr<-rev(code)[1]; lexpr<-substring(lexpr,1,4)
    if(length(code)==0||is.null(lexpr)||is.na(lexpr)) return()
    plot.res<-c("plot","boxp","par(","abli","pie(","hist","axis","show",
           "lsfi","pair","ylab","help",
           "qqli","qqno","qqpl","rug(","lege","segm","text","xlab", 
           "poin","line","titl","eda(","imag","vgl.","curv")
    if(any(plot.res==lexpr)){
       cat("Plot erstellt\n"); return()
    }
    if(is.null(result)||is.na(result)||lexpr=="prin"||lexpr=="cat("){
      cat("ok\n"); return() }
    if(is.list(result)&& length(names(result))> 0 && 
                               names(result)[1]=="ID") return()
    ## if(is.list(result)&& TRUE) return()
    no<-as.character(as.numeric(tclvalue(secno)))
    cat("Result of code chunk",no,":\n") 
   if(class(result)=="try-error"){
     class(result)<-"character"
     cat(result,"\n")
   }else{
    print(result)
   }
   cat("ok\n")
   }
  exit.function<-function(){
     tkdestroy(top)
     filename<-tkgetSaveFile(filetypes="{{Paper Files} {.rev}}",
                                           title="Do you want to save the activated R statements?")
     if(!is.character(filename)) filename<-tclvalue(filename)
     if(filename==""){
       cat("Demo function stopped without saving\n")
       return()
     }
     if(0==length(grep("rev$",filename))) filename<-paste(filename,".rev",sep="")
     h<-get("allcodechunks",envir=where)
     try(cat(h,sep="\n",file=filename))
     cat(paste("Remark: activated statements saved in\n   ",filename,"\n"))
     return()
  }
  allcodechunks<-paste(
          "@\nReport of activated R-chunks from: ",date(),
          "\n(demo function constructed by relax (c) Peter Wolf 2007)\n\n  ", sep="")
  no<-0
  <<hole chunk Nummer>>
  h<-paste(rep("#",60),collapse="")
  code<-sub("#0:",h,code); code<-sub("#:0",h,code)
  allcodechunks<-c(allcodechunks,"\n@\n@<<start@>>=",code,"\n@")
  assign("allcodechunks",allcodechunks,envir=where)
  top<-tktoplevel()
  ttext<-tktext(top,height=19,background="#f7fffF",
                font="-Adobe-courier-Medium-R-Normal--18-180-*")
  tf<-tkframe(top) 
  tkwm.title(top, "demo of file WoRkNaMe, constructed by relax (c) Peter Wolf 2011")
  tkpack(tf,side="bottom"); tkpack(tf,ttext,side="bottom",fill="both",expand="y") # 091026
  tkevent.add("@<<Paste>>",   "<Control_L><v>")
## ok:  tkbind(ttext,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")
if(<<OS ist Mac-Mini>> ){
  mac.paste<-function(...){  ## Ctrl-V  # mac-PASTE
     try({.Tcl("clipboard append hello"); .Tcl("clipboard clear")
          news<-base::scan(file=pipe("pbpaste","r"),what="",sep="\n",blank.lines.skip=FALSE)
          tkinsert(ttext,"insert",paste(news,collapse="\n"))})
          tksee(ttext,"insert - 7 lines");  tksee(ttext,"insert + 7 lines") #090706 
  } 
  tkbind(ttext,"<Control_L><v>",mac.paste)
  mac.copy<-function(...){  ## Ctrl-C  # mac-COPY
     news<-""
     try(news<-tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa empty} {set aa full}")))
     if(news=="empty") return()
     try({news<-tclvalue(.Tcl("set aaa [selection get -selection CLIPBOARD]"))
          tmp.file.name <- tempfile("rt-tmp")
          base::cat(news,file=tmp.file.name); system(paste("pbcopy < ",tmp.file.name))
          .Tcl("clipboard append hello"); .Tcl("clipboard clear")})
  }
  tkbind(ttext,"<Control_L><c>",mac.copy)
  tkevent.add("@<<extract>>",  "<Control_L><c><KeyRelease>")   # mac-extract
  tkbind(ttext,"@<<extract>>",mac.copy)
}else{
  tkevent.add("@<<Paste>>",   "<Control_L><v>")
  tkbind(ttext,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")
}


  bexit<-tkbutton(tf,text="QUIT",width=9)
  beval<-tkbutton(tf,text="EVALUATE",width=9)
  bnext<-tkbutton(tf,text="NEXT",width=9)
  bback<-tkbutton(tf,text="BACK",width=9)
  tkbind(top, "@<<EvalRCode>>", eval.code)
  if( ! <<OS ist Mac-Mini>> ) {
    tkbind(top, "@<<Next>>", show.next.number)
    tkbind(top, "@<<Back>>", show.back.number)
  }
  lno  <-tkentry(tf,textvariable=secno,width=9)
  linfo<-tklabel(tf,text="chunk number:")
  tkpack(linfo,lno,beval,bnext,bback,bexit,side="left")
  tkconfigure(bexit,command=exit.function)
  tkconfigure(bnext,command=show.next.number)
  tkconfigure(bback,command=show.back.number)
  tkconfigure(beval,command=eval.code)
  # tkbind(lno,"<Return>",show.number)
  tkbind(lno,"<KeyRelease>",show.number)
  tclvalue(secno)<-as.character(no)
  show.number()
  ### tkwait.window(top)
}

@
<<hole chunk Nummer>>=
no.start<-grep(paste("^#",no,":$",sep=""),chunks)
no.end<-grep(paste("^#:",no,"$",sep=""),chunks)
if(length(no.end)==0||is.na(no.end) ||is.na(no.start)||
     is.nan(no.end)||is.nan(no.start)){
     cat("# sorry, chunk number '",no,"' wrong!\n"); return()
}
### cat("# aktueller chunk:",no,"\n")
code<-paste(chunks[no.start:no.end],collapse="\n")
@
ENDE VON demo....

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<ProcessReport>>", ProcessReport)

@
Hier ist ein Vorschlag für einen Kopf eines LaTeX-Dokumentes:
% entfernt:
%  --- for noweb users
% \usepackage{NOWEBSTYLEFILE}\noweboptions{webnumbering,smallcode}
<<LaTeX-head>>=
\documentclass[a4paper]{article} %  --- LaTeX preamble ==============
%  --- title page ===================================================
   \title{Report: \rule{30mm}{.1mm}}                        
   \author{File: \jobname.rev\\in: JOBPATH}                 
%   \date{}
%  --- sizes of non text elements ===================================
\renewcommand{\textchunkcommands}{\normalsize}
\renewcommand{\codechunkcommands}{\small}
\renewcommand{\Routputcommands}{\footnotesize}
%  ==================================================================
%  --- packages  \usepackage{graphicx,mathpazo,courier,alltt,amssymb}
\usepackage{graphicx}
%  --- fonts 
% \usepackage[scaled=.95]{helvet}
\usepackage[T1]{fontenc}
%  --- commands to control the layout of text and code chunks 
\parskip1ex \parindent0mm
%  --- end of preamble ==============================================
\begin{document}  \maketitle
% object index -- remove next line to disable object index
@@index.of.objects
% list of code chunks -- remove next line to disable list of chunks
@@list.of.chunks
%  --- begin of document ============================================

@
Früher wurde über die Variable [[rtrevweb.home]] festgelegt, in welchem Paket sich unter
Windows das Verzeichnis mit den noweb-Funktionen befindet.
Der Inhalt des Verzeichnisses ist an anderer Stelle beschrieben, siehe
zum Beispiel: rw.rev.

Die alte rtrevweb-Lösung mittels noweb:
<<old definition of [[rtrevweb]]>>=
 rtrevweb<-function(name,DIR=getwd(),binpath){
  # cat(paste("Aufruf: rtrevweb(name=\"",name,"\",DIR=\"",DIR,"\")\n",sep=""))
  scan<-get("scan",pos="package:base"); formals(scan)$comment.char<-""
  name<-sub(".rev$","",name)
  revname<-paste((name<-paste(DIR,name,sep="/")),"rev",sep=".")
  if(!file.exists(revname)){
    cat(paste("Error: File",revname,"not found!!!"));return()
  }
  if( <<das OS ist Windows>> ){
    if(missing(binpath)){
      binpath<-paste(path.package(<<relax>>),"rtrevweb",sep=.Platform$file.sep) # 130325 .path.package defunct
      binpath<-gsub("/","\\\\",binpath)
    }
    vol<-strsplit(binpath,":")[[1]]
    vol<-if(1==length(vol)) "c:" else vol[1]

    tmpfile<-scan(revname,what="",sep="\n",blank.lines.skip=TRUE)
    cat(tmpfile,file=paste(binpath,"work.rev",sep="/"),sep="\n")
    if(!file.exists(paste(binpath,"/rtrevweb.bat",sep=""))){
      cat("Error: rtrevweb.bat not found!!!"); return()
    }
    try(system(paste(binpath,"/rtrevweb ",binpath," ",vol,sep=""),TRUE))
    tmpfile<-scan(paste(binpath,"work.sch",sep="/"),what="",sep="\n")
    cat(tmpfile,file=paste(name,"sch",sep="."),sep="\n")
    tmpfile<-scan(paste(binpath,"work.tex",sep="/"),
                  what="",sep="\n",blank.lines.skip=TRUE)
    cat(tmpfile,file=paste(name,"tex",sep="."),sep="\n")
    tmpfile<-scan(paste(binpath,"work.htm",sep="/"),what="",sep="\n")
    cat(tmpfile,file=paste(name,"htm",sep="."),sep="\n")
    cat("fertig\n")
  }else { # LINUX:
    if(0==system(paste("which",path.revweb))&&!exists("weaveR.flag")){
     try(system(paste(path.revweb," ",name)))
    }else{
     try(weaveR(revname,
                     replace.umlaute=replace.umlaute.sys))
     try(tangleR(sub(".rev$","",revname)))
    }
  }
 } # end of old rtrevweb



@
Windows Only: Konfigurationen.
Für die Verarbeitung von Papieren müssen verschiedene Service-Programme
angestoßen werden. Deren Ort kann nicht allgemein festgelegt werden.
Deshalb wurde zuerst eine Konfigurationsfunktion ([[get.config()]]) entworfen, mit der
verschiedene spezielle Setzungen ermittelt werden können.
Inzwischen stehen spezielle Pfade usw.\ unter [[config/settings.relax]].

@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindReportChunk]]}
\paragraph{[[FindReportChunk]] zur Erleichterung der Navigation im
Arbeitsfenster.}
Zum Auf\-finden eines Code-Namen müssen zunächst die verwendeten Namen
festgestellt werden. Dann werden sie in einem vom Top-Level abhängigen
Menü mit [[Radiobuttons]] aufgelistet. Der Anwender kann dann durch
Anklicken seinen gesuchten Chunk-Namen erreichen.
Neue Version mit [[listbox]].
<<definiere Kopf-Zeilen-Funktionen>>=
FindReportChunk<-function(){
  melde("FindReportChunk",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("^@<<(.*)>>=",worktext); if(0==length(no)) return()

  cchoices<-paste(worktext[no],worktext[no+1],sep=":: ")
  cchoices<-substring(cchoices,1,pmin(nchar(cchoices),60))
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"code chunk? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in cchoices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     h<-as.numeric(tkcurselection(tl))+1; cchoice<-cchoices[h]; 
     cchoice<-sub("::.*$","",cchoice)
     <<lese Arbeitsfenster auf [[worktext]] ein>>
     line<-which(cchoice==substring(worktext,1,nchar(cchoice)))[1]
     # line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindReportChunk",2)
}
@
<<old-version>>=
FindReportChunk<-function(){
  melde("FindReportChunk",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("^@<<(.*)>>=",worktext); if(0==length(no)) return()

  choices<-paste(worktext[no],worktext[no+1],sep=": ")
  choices<-substring(choices,1,pmin(nchar(choices),60))
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"code chunk? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindReportChunk",2)
}

@
<<definiere Kopf-Zeilen-Funktionen>>=
InsertLaTeXEnv<-function(){
  melde("InsertLaTeXEnv",1)
  newtop<-tktoplevel();tkwm.title(newtop,"LaTeX-environment? -- Esc=Exit, Return=Selection")
  tkwm.geometry(newtop,"+0+15")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=7,width=70,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  choices<-c("center","quote","itemize","enumerate","eqnarray","verbatim")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     choice<-as.numeric(tkcurselection(tl))+1; # tkdestroy(newtop)
     if(!is.na(choice) && any(choice==1:6)){
       news<-c("\\begin{center}\n\n\\end{center}\n",
                      "\\begin{quote}\n\n\\end{quote}\n",
		      "\\begin{itemize}\n\\item \n\\item \n\n\\end{itemize}\n",
		      "\\begin{enumerate}\n\\item \n\\item \n\n\\end{enumerate}\n",
		      "\\begin{eqnarray*}\n\n\\end{eqnarray*}\n",
		      "\\begin{verbatim}\n\n\\end{verbatim}\n")[choice]
       <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
       line <- paste(line+1,"0",sep=".")
       <<schreibe [[news]] hinter [[line]]>>
     }
     if(!is.na(line)){
       tksee(tworkwin,line)
       tkmark.set(tworkwin, "insert", line)
       tkfocus(tworkwin)
     }
  })
  melde("InsertLaTeXEnv",2)
}
@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindLaTeXSection]]}
\paragraph{[[FindLaTeXSection]] zur Suche nach einer LaTeX-Section.}
@
Es zeigte sich, dass es vorteilhaft ist, das Auswahlfenster stehen zu lassen. 
Damit wird eine wiederholte Suche erleichtert. Auch wurde das Design der 
Darstellung leicht modifiziert.
<<definiere Kopf-Zeilen-Funktionen>>=
FindLaTeXSection<-function(){ # 091023
  melde("FindLaTeXSection",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("\\\\s(.*)ection",worktext); if(0==length(no)) return()

  tchoices<-paste(worktext[no],worktext[no+1],sep=":: ")
  tchoices<-substring(tchoices,1,pmin(nchar(tchoices),60))
  tchoices<-sub("\\\\subsubsection","->->",tchoices)
  tchoices<-sub("\\\\subsection","->",tchoices)
  tchoices<-sub("\\\\section","",tchoices)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"section? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
                yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in tchoices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     h<-as.numeric(tkcurselection(tl))+1
     tchoice<-tchoices[h]; 
     tchoice<-paste("section",tchoice,sep="")
     tchoice<-paste("\\",sub("^section->","subsection",
                             sub("^section->->","subsubsection",tchoice)),sep="")
     tchoice<-sub("::.*$","",tchoice)
     <<lese Arbeitsfenster auf [[worktext]] ein>>
     line<-which(tchoice==substring(worktext,1,nchar(tchoice)))[1]
     # line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindLaTeXSection",2)
}
@
<<definiere Kopf-Zeilen-Funktionen---old version>>=
FindLaTeXSection<-function(){
  melde("FindLaTeXSection",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("\\\\s(.*)ection",worktext); if(0==length(no)) return()

  choices<-paste(worktext[no],worktext[no+1],sep=": ")
  choices<-substring(choices,1,pmin(nchar(choices),60))
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"code chunk? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindLaTeXSection",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[ShowShortCuts]]}
\paragraph{[[ShowShortCuts]] Anzeige von speziellen Short-Cuts.}
<<definiere Kopf-Zeilen-Funktionen>>=
ShowAboutRelax<-function(){
  melde("ShowAboutRelax",1)
  doc<-c("=================================================",
         "RELAX -- R Editor for Literate Analysis and lateX",
         "=================================================","",
         paste("version:",<<Version von [[relax]]>>),"",
               "relax() is designed to support processes of data analysis, report writing,",
               "presentation, and programming. On start relax() creates a Tk/Tcl window",
               "consisting a report and an output field. You can write down your ideas as",
               "well as some chunks of code into the report field. The R statements will be",
               "activated by pressing the button <EvalRCode> and the output will occur in",
	       "the output field. By clicking <Insert> the output is appended to the",
	       "report field and you can add your interpretations of the results.","",
	       "This style of work will lead to correct reports and after formatting by",
	       "LaTex you may get a very nice documentation of your analysis.","",
	       "The saved reports can be reloaded again in cause of checken, modification",
	       "and presentation of the results.","", 
	       "Have a look at the help page of relax and visit",
	       "http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html","",
	       "Copyright (C) 2005 Hans Peter Wolf.","",
	       "This software is licensed under the GPL (version 2 or newer) terms.",
               "It is free software and comes with ABSOLUTELY NO WARRANTY.","",
              # "The windows version may use some ingredients",
	      # "of the noweb system",
	      # " (Norman Ramsey -- http://www.eecs.harvard.edu/~nr/noweb/intro.html),",
	      # "of the Img package of Jan Nijtmans (see:",
              # "http://wiki.tcl.tk/1404,",
              # "http://home.kpnplanet.nl/~J.Nijtmans@kpnplanet.nl/img.html",
              # "and http://members.chello.nl/~j.nijtmans/img.html",
              # "the package is found in http://sourceforge.net/projects/tkimg).",
	      # "and gawk (http://www.gnu.org/software/gawk/gawk.html).",
              # "If used the license terms concerning the img package are found in the source", 
              # "file of the package, see: relax/src/tkimg1.3.tar.gz.","",
	       "---------------------------------------------------------","",""
               )
  try(doc<-c(doc,scan(file=paste(path.package("relax"),"lib/gpl.txt",sep="/"),what="",sep="\n"))) # 130325 .path.package defunct
  .newl<-tktoplevel();tkwm.geometry(.newl,"+0+15")
  tkpack(tt<-tktext(.newl,height="33")) ## ((length(doc)))
  tkwm.title(.newl,paste("What's relax? ","Exit by Return or Escape!"))
  try(tkinsert(tt,"0.0",paste(doc,collapse="\n")))
  abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
  tkbind(.newl,"<Escape>", function(){
               tkdestroy(.newl)
  })
  tkbind(.newl,"<Return>", function(){
               tkdestroy(.newl)
  })
  tkfocus(.newl)
  melde("ShowAboutRelax",2)
}

ShowShortCuts<-function(){
  melde("ShowShortCuts",1)
  keys<-c("Shortcuts of relax:","",
          if(<<das OS ist Windows>> | <<das OS ist Linux>>)
              c("Alt-D:  move cursor one code chunk DOWN",
                "Alt-U:  move cursor one code chunk UP",
                "Alt-P:  plan new code chunk",
                "Alt-E:  eval code chunk",
                "Alt-W:  eval code chunk / ignore warnings",
                "Alt-I:  insert output into report",
                "Alt-S:  copy plot and generate postscript / JPEG file",
                "Alt-R:  clear output field",
                "Alt-T:  delete inserted output from report",
                "Alt-H:  R help",
                "Alt-F, Crtl-F:  Find text in report field"),
          if(<<OS ist Mac-Mini>>)
              c(#"Alt-D:  move cursor one code chunk DOWN",
                #"Alt-U:  move cursor one code chunk UP",
                "Apple-P:  plan new code chunk",
                "Apple-E:  eval code chunk",
                # "Apple-W:  eval code chunk / ignore warnings", # will destroy relax window
                "Apple-I:  insert output into report",
                "Apple-S:  copy plot and generate postscript / JPEG file",
                "Apple-R:  clear output field",
                "Apple-T:  delete output of text field",
                # "Alt-H:  R help",
                "Crtl-G:  Goto line number",
                "<Fn><F3>:  Find text in report field again",
                "Alt-F, Crtl-F:  Find text in report field") 
           else
              c("Crtl-G:  Goto line number",
                "<F3>:  Find text in report field again"),  ## end of if
          "Crtl-S:  Save Report",
          "Crtl-P:  Process Report: save, weave, and latex Report",
		"","Shortcuts of tcltk, may depend on OS / tcl/tk version:","",
                "Crtl-Z:  UNDO",
                "Crtl-C:  copy marked text",
                "Crtl-V:  paste marked text",
                "Crtl-Y:  paste marked text (=Crtl-V)",
		"Crtl-X:  delete marked text",
                "Crtl-W:  copy and delete marked text",
                "Crtl-Shift-7:  mark all",
               # "Crtl-F:  unmark text",
               # "Crtl-A:  unmark text",
               # "Crtl-P:  unmark text",
                "Crtl-O:  break line",
                "Crtl-E:  move cursor to the end of line",
                "Crtl-A:  move cursor to the beginning of line",
                "Crtl-B:  move cursor one character to the left",
                "Crtl-F:  move cursor one character to the right",
                "Crtl-N:  move cursor to the next line",
                "Crtl-Pos1:  move cursor to the beginning of text",
                "Crtl-End:  move cursor to the end of text",
               # "Crtl-P:  move cursor one line back",
		"Crtl-I:  insert tab",
		"Crtl-T:  exchange characters",
                "Crtl-D:  delete character right of cursor",
                "Crtl-H:  delete character left of cursor",
                "Crtl-K:  delete characters from cursor to end of line"     )
  .newl<-tktoplevel();tkwm.geometry(.newl,"+0+15")
  tkpack(tt<-tktext(.newl,height=length(keys)))
  tkwm.title(.newl,paste("shortcuts of relax and text field,","Exit by Return or Escape!"))
  try(tkinsert(tt,"0.0",paste(keys,collapse="\n")))
  abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
  tkbind(.newl,"<Escape>", function(){
               tkdestroy(.newl)
  })
  tkbind(.newl,"<Return>", function(){
               tkdestroy(.newl)
  })
  tkfocus(.newl)
  melde("ShowShortCuts",2)
}
ShowInteractiveIcon<-""


@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindRFns]]}
\paragraph{[[FindRFns]] zum Auf\-finden einer R-Funktion.}
Zum Auf\-finden einer R-Funktion aufgrund eines Suchbegriffs wird die
R-Funktion [[help.search]] mißbraucht. Dazu wird sie als lokale Funktion
vereinbart und so verändert, daß der Output zugreifbar wird.
Der Output wird in einem temporären neuen Widget angezeigt,
das nach getaner Arbeit wieder entfernt wird. Bei
einer Änderung von [[help.search]] muß natürlich [[FindRFns]]
auch verändert werden!
<<definiere Kopf-Zeilen-Funktionen>>=
FindRFns<-function(){
  melde("FindRFns",1)
  frage<-"keyword for function search?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      such<-tclvalue("tvinfo")
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess",paste(tclvalue("tvinfo"),": bitte etwas Geduld!"))
      found<-help.search(such)[[4]][,1:2]
      found<-paste(paste(found[,1],
                         substring("         ",1,pmax(1,10-nchar(found[,1]))),
                         found[,2]),collapse="\n")
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+15");tkpack(tt<-tktext(.newl))
      tkwm.title(.newl,paste("zu >",such,"< gefundene Funktionen, ",
                             "Beendigung durch Escape oder Return!"))
      try(tkinsert(tt,"0.0",paste(found,collapse="\n")))
      abbruch<-function(){tkdestroy(.newl);set.tclvalue("tvndone",2)}
      tkbind(.newl,"<Return>",abbruch);tkbind(.newl,"<Escape>",abbruch)
      tkfocus(.newl);tkwait.variable("tvndone")
      set.tclvalue("tvmess","relax")
    } # end of function
  )
  melde("FindRFns",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[ReloadPlots]]}
\paragraph{[[ReloadPlots]] zur Aktualisierung von im Reportfenster angezeigten 
Graphiken.}
Es hat sich gezeigt, dass der Ladevorgang von Bildern ab einer
größeren Anzahl zu langsam ist und deshalb vermieden werden sollte.
Das Aktualisieren der Plots wird nun nur noch über das Edit-Menü 
angeboten.
<<definiere Kopf-Zeilen-Funktionen>>=
ReloadPlots<-function(){
  melde("ReloadPlots",1)
  <<kreiiere Bilder neu und zeige sie im Textfenster an>>
  melde("ReloadPlots",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RemoveSavedPlots]]}
\paragraph{[[RemoveSavedPlots]] löscht gespeicherte Graphiken.}
Oft sind gespeicherte Plots doch nicht so überzeugend und sollen gelöscht oder durch neue 
ersetzt werden. Hierfür ist eine Löschfunktion hilfreich. Das Vorgehen ist wie folgt:
Platziere den Cursor auf die [[includegraphics]]-, die Folge- oder die [[img src..]]-Zeile
und wähle dann im Edit-Menü [[RemoveSavedPlot]] an.
Dann wird der Link-Eintrag entfernt und die Dateien werden gelöscht.
<<definiere Kopf-Zeilen-Funktionen>>=
RemoveSavedPlot<-function(){
  melde("RemoveSavedPlot",1)
  # find cursor line
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  # check whether a plot is defined by cursor line
  if(1==length(grep("p..img src..p2", worktext[line])))   { line <- max(1,line - 2) } else 
    if(0==length(grep("includegraphics",worktext[line]))) { line <- max(1,line - 1) }
  if(0==length(grep("includegraphics",worktext[line]))){ cat("relax warning: no plot for deleting found"); return() }
  out.start <- line
  # extract name of plot
  picname <- sub("^.*includegraphics.*p[2]","p2",worktext[out.start])
  picname <- sub("\\}.*$","",picname)
  if(0==length(grep("^p[2].*[0-9][0-9]",picname))){ cat("relax warning: no plot for deleting found"); return() }
  # delete files 
  f.vec <- list.files(pattern=picname)
  if(0==length(f.vec)) { cat("relax warning: no plot for deleting found"); return() }
  for(pic in f.vec) { cat("file",pic,"deleted"); file.remove(pic) }
  # remove link lines from text
  out.end <- out.start 
  if(1==length(grep("p..img src..p2", worktext[out.start+1]))) out.end <- out.start+1
  if(1==length(grep("p..img src..p2", worktext[out.start+2]))) out.end <- out.start+2  
  worktext<-worktext[-(out.start:out.end)]
  # refresh report window
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  tkfocus(tworkwin)
  tkmark.set(tworkwin,"insert",paste(out.start-1,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("RemoveSavedPlot",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RemoveALLPLOTS]]}
\paragraph{[[RemoveALLPLOTS]] löscht gespeicherte Graphiken.}
Bei automatischen Reports kann die Situation vorkommen, dass alle Bilder entfernt werden sollen. 
Diesen Job leistet die Funktion [[RemoveALLPLOTS]]. Es werden alle Einträge im Reportfenster mit Bildern 
gesucht. Dann werden nach der Logik von [[RemoveSavedPlot]] Schritt für Schritt die Bilder gelöscht. 
Sicherheitshalber erfolgt eine Abfrage, ob denn wirklich alle Bilder gelöscht werden sollen.
Als Bilder werden alle Bilder erkannt, deren Namen mit p20 beginnen und deren Link-Zeile dem Eintrag von
SavePlot entspricht.
<<definiere Kopf-Zeilen-Funktionen>>=
RemoveALLPLOTS<-function(){
  melde("RemoveALLPLOTS",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  pic.lines.set <- grep("^ *\\\\begin[{]center[}]\\\\includegraphics.*[{]p20.*\\\\end[{]center[}]",
                        worktext) #} 
  if(0==length(pic.lines.set)) return()

  res<-tkmessageBox(message=paste(if(language=="german") 
                                    "Sollen wirklich ALLE Bilder dauerhaft ENTFERNT werden?\n"
                                  else 
                                     "All Pictures will be removed!\nAre you shure?\n",
                                  paste(sub("^.*(p20...*[0-9]+).*$","\\1",worktext[pic.lines.set]),
                                        collapse="\n ")),
                    title="Exit",icon="warning",type="yesnocancel",default="no")
  if("externalptr"==mode(res))  res<-tclvalue(res)
  if(res=="cancel") return(); if(res!="yes") return()

  for(LINE in rev(pic.lines.set)){
    out.start <- LINE
    # extract name of plot
    picname <- sub("^.*includegraphics.*[{]p[2]","p2",worktext[out.start])  
    picname <- sub("\\}.*$","",picname) 
    if(0==length(grep("^p[2].*[0-9][0-9]",picname))){ next }
    # delete files 
    f.vec <- list.files(pattern=picname)
    if(0==length(f.vec)) { next }
    for(pic in f.vec) { cat("file",pic,"deleted"); file.remove(pic) }
    # remove link lines from text
    out.end <- out.start 
    if(1==length(grep("p..img src..p2", worktext[out.start+1]))) out.end <- out.start+1
    if(1==length(grep("p..img src..p2", worktext[out.start+2]))) out.end <- out.start+2  
    worktext<-worktext[-(out.start:out.end)]
  }
  # refresh report window
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  tkfocus(tworkwin)
  tkmark.set(tworkwin,"insert",paste(out.start-1,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("RemoveALLPLOTS",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[ReloadReportWidget]]}
\paragraph{[[ReloadReportWidget]] zur Aktualisierung des Reportfensters.}
In R-2.8.0 hat sich gezeigt, dass der Start von relax()
bisweilen zu einem defekten Report-Fenster führt.
Zur Fehlerbehebung wurde verschiedene Versuche durchgeführt. 
Hier ist das Protokoll der Versuche.
<<ReportWidget-Fehleranalyse>>=
# GET Vars
revive.sys<-get("revive.sys",envir=revive.env);foutwin<-get("foutwin",envir=revive.sys);
fworkwin<-get("fworkwin",envir=revive.sys);fhandle<-get("fhandle",envir=revive.sys);
fout<-get("fout",envir=revive.sys);fworkcmds<-get("fworkcmds",envir=revive.sys);
foutcmds<-get("foutcmds",envir=revive.sys);tworkwin<-get("tworkwin",envir=revive.sys);
workbar<-get("workbar",envir=revive.sys);proc<-get("proc",envir=revive.sys)
@
1. Vergrößern, Verkleinern, Mitte verschieben: kein Erfolg;
   dann Minimieren, wieder darstellen: Erfolg

2. Minimieren, wieder darstellen: kein Erfolg
     dann Vergrößern: kein Erfolg

3. WD beider Punkte: wie oben

4. Datei-Ops / RefreshBilder: keine Erfolg
     dann Minimieren, Maximieren: Erfolg

5. [[tkpack(tworkwin)]]: kein Erfolg

6. [[tkpack.forget(tworkwin); tkpack(tworkwin)]]: Teilerfolg, verkleinertes Textfenster

7. [[tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes")]]: Teilerfolg, verkleinertes Textfenster

8. [[tkpack.forget(tworkwin); tkpack(tworkwin,fill="both")]]: kein Erfolg,\\
   [[dann tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes")]]: Teilerfolg, verkleinertes Textfenster

9. [[tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes",fill="both")]]: kein Erfolg,
   ebenfalls bei anderer Reihenfolge der Parameter 
   
10. [[tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes",fill="both")]]: kein Erfolg,
   Verschiebung der Grenzen: OK!

11. Erfolg:
<<ReportWidget-Fehleranalyse>>=
tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes",fill="both")
.Tcl(paste("place ",fworkwin$ID," -relheight 0.4"))
     
12. Erfolg:
<<ReportWidget-Fehleranalyse>>=
tkpack.forget(tworkwin); tkpack(tworkwin,expand="yes",fill="both")
.Tcl(paste("place ",fworkwin$ID," -relheight 0.45"))
.Tcl(paste("place ",fworkwin$ID," -relheight 0.50"))

13. Zusammenfassung / Kontrolle. Folgendes scheint zu laufen, zur Sicherheit wurden ein paar
Verzögerungen eingebaut.
<<ReportWidget-Fehleranalyse>>=
relax()
revive.sys<-get("revive.sys",envir=revive.env)
tworkwin<-get("tworkwin",envir=revive.sys); fworkwin<-get("fworkwin",envir=revive.sys)
del<-0.02; tkpack.forget(tworkwin); Sys.sleep(del)
tkpack(tworkwin,expand="yes",fill="both"); Sys.sleep(del)
.Tcl(paste("place ",fworkwin$ID," -relheight 0.35")); Sys.sleep(del)
.Tcl(paste("place ",fworkwin$ID," -relheight 0.50"))
  
@
Deshalb wird zur Reparatur ein Menü-Punkt angeboten.
<<definiere Kopf-Zeilen-Funktionen>>=
ReloadReportWidget<-function(){
  melde("ReloadReportWidget",1)
  revive.sys<-get("revive.sys",envir=revive.env)
  tworkwin<-get("tworkwin",envir=revive.sys); fworkwin<-get("fworkwin",envir=revive.sys)
  del<-0.02; tkpack.forget(tworkwin); Sys.sleep(del)
  tkpack(tworkwin,expand="yes",fill="both"); Sys.sleep(del)
  .Tcl(paste("place ",fworkwin$ID," -relheight 0.35")); Sys.sleep(del)
  .Tcl(paste("place ",fworkwin$ID," -relheight 0.50"))
  melde("ReloadReportWidget",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RefreshChunkNumbers]]} % 090212
\paragraph{[[RefreshChunkNumbers]] zur Aktualisierung des Chunk-Nummern.}
Durch manuelle Chunk-Einfügungen und Löschungen verfälschen sich die Chunk-Nummern.
Deshalb ist eine Reparaturfunktion angebracht. Hier ist sie.
<<definiere Kopf-Zeilen-Funktionen>>=
RefreshChunkNumbers<-function(){
  melde("RefreshChunkNumbers",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
  melde("RefreshChunkNumbers",1)
} 

@
\subsubsection{Kopfzeile: [[Edit]] --- [[ListUsedPlots]]} % 090212
\paragraph{[[ListUsedPlots]] Anzeige der verwendeten Graphiken.}
<<definiere Kopf-Zeilen-Funktionen>>=
ListUsedPlots<-function(){
  melde("ListUsedPlots",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  files.used<-NULL
  include.lines<-grep("\\includegraphics",worktext,value=TRUE)
  if(length(include.lines)>0){
    include.lines<-sub("..includegraphics","",include.lines)
    include.lines<-sub("[}].*$","",include.lines)
    include.lines<-sub(".*[{]","",include.lines)
    inclinclude.lines<-sub("[}].*$","",include.lines)
    # cat("files of includegraphics macros of report"); print(include.lines)
    files.used<-c(files.used,include.lines)
  }
  include.lines<-grep("% <p><img src[=]",worktext,value=TRUE)
  if(length(include.lines)>0){
    include.lines<-sub(".*[=].","",include.lines)
    include.lines<-sub(".>.*$","",include.lines)
    # cat("files of html img tags of report:"); print(include.lines)
    include.lines<-sub("....$","",include.lines)
    files.used<-unique(c(files.used,include.lines))
  }
  if(length(files.used)>0){
    cat("graphics files of includegraphics macros or html img tags") 
    print(files.used)
  } else {
    cat("no uses of graphics files of includegraphics macros or html img tags found")
    return()
  }
  files.found<-list.files(pattern="^p20[0-1]+[0-9]+")
  if(length(files.found)==0) {
    cat("no graphics files of directory found")
    return()
  }
  files.found<-sub("\\....$","",files.found); files.found<-sub("\\...$","",files.found)
  h<-files.found[!files.found %in% files.used]
  if(length(h)>0){
    cat("graphics files of the directory not referenced here:")
    print(h)
  }
  h<-files.used[!files.used %in% files.found]
  if(length(h)>0){
    cat("graphics files referenced here but not found in the directory:")
    print(h)
  }
  melde("ListUsedPlots",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[SavePlot]]}
\paragraph{[[SavePlot]] zur Speicherung von Graphiken als PS-Datei
und anderer Formate.}
In einen Report gehören natürlich Bilder. Deshalb muss es leicht sein,
mit R generierte Bilder in den Report zu übernehmen. Weiter wäre es schön,
wenn man die Bilder in dem Report-Fenster sehen könnte. Es entstehen damit
drei Problembereiche, die bei der Übertragung eines Bildes in einen Report
entstehen:
\begin{enumerate}
\item 
Kopieren des Bilder
\item 
Eintrag eines \emph{Links} im Report zu dem Bild bzw.\ zur Bilddatei
\item 
Darstellung des Bildes im Reportfenster
\end{enumerate}
Alle drei Problembereiche sind mit einander verknüpft.
Die jeweiligen Gegebenheiten (Betriebssystem/Software) bedingen den Weg
zur Lösung der Problembereiche. 

\paragraph{Ad 1.\ Kopieren des Bildes.}
Das Kopieren eines Bildes wird aus R-Sicht mittels [[dev.copy]] realisiert.

Für den Kopierprozess muss entschieden werden, in welchem Format ein Bild abgelegt werden soll.
Diese Entscheidung hängt von dem Möglichkeitsrahmen (Software), 
wie auch von der intendierten Verwendung ab. Zunächst wird ein Postscript-Bild erstellt. 
Denn ein Postscript-Bild kann grundsätzlich in alle möglichen Formate konvertiert werden und 
-- als zweites Argument -- enthält R einen Postscript-Device, 
so dass der Erstellung nichts im Wege steht.
Gleiches gilt auch für JPEG. Mit diesen diesen beiden Typen lassen sich Formatierungen per 
\LaTeX\ (latex bzw.\ pdflatex) und html-Browser umsetzen. 
Aus technischer Sicht ist zu beachten, dass der JPG-Device unter Windows anders 
anzusteuern ist als auf anderen Plattformen.

Für die Darstellung im Reportfenster lassen sich immer ppmraw- oder gif-Files verwenden,
ein jpg-File erfordert dagegen als das Tcl/Tk-Paket [[Img]]. 
Für die Erstellung eines gif-Bildes kann in der Mac-Welt auf das Kommando [[convert]] zurückgegriffen
werden. Eine ppm-Kopie wird von [[dev.copy()]] mittels [[bitmap()]] erzeugt, das wiederum [[ghostscript]] einsetzt.

Für die Erzeugung gilt also: ps- und jpg-Files werden immer generiert. 
Wenn Bilder im Reportfenster verlangt werden ([[no.plots==FALSE]]), 
werden gif-File in der Mac-Welt erzeugt.  
In anderen Welten werden ppm-Files nur dann erzeugt, wenn ghostscript gefunden wird, 
aber nicht das Img zur Verfügung steht. Denn dann können jpg-Bilder eingebunden werden.

Lassen sich die Bedingungen einfach prüfen? 
Für Betriebssysteme gibt es passende Chunks.
Beim Start wird die Existenz von ghostscript und des Img-Paketes festgestellt und das 
Ergebnis auf den Variablen [[ghostscript]] und [[Img.package.found]] abgelegt.
Siehe dazu:\\
[[<lade das [[Img]]-Paket für [[Tcl/Tk]]>]] sowie 
[[<checke unter windows, ob ghostscript existiert>]]

\paragraph{Ad 2.\ Eintrag einer Verbindung im Report zu einem Bild.}
Im Report wird bei der Erzeugung des ps-Bildes ein LaTeX-Einbindungsbefehl 
(mit dem Kern [[\includegraphics]]) eingesetzt. Dieser führt nach dem Formatieren zur Bildeinbindung. 
Für den html-Weg wird ein Link a la [[img src=..]] während der jpg-Erzeugung notiert.

\paragraph{Ad 3.\ Darstellung des Bildes im Reportfenster.}

Die Darstellung von Bildern in Text-Widgets funktioniert nur auf der Tcl/Tk-Ebene.
Zunächst muss eine interne Repräsentation eines Bildes gefunden werden. Eine solche lässt sich 
umsetzen durch:\\ 
[[  .Tcl("set imageno [image create photo -format ppm -file tmp0.ppm]")]]\\
Je nach Situation muss das Format (hier [[ppm]]) geeignet gesetzt werden.

Dann muss diese Repräsentation angezeigt werden:\\
[[  .Tcl("$w image create $place -image $imageno")]]\\ \kannweg{$}
Der letzte Befehl wird (s.u.) umgesetzt durch die Tcl/TK-Prozedur [[showsingleimage]]:\\
[[  NO <- tclvalue(.Tcl("set imageno")); tcl("showsingleimage",tworkwin,NO,"97.0")]]

Die Tcl/Tk-Prozedur [[createandshowimage]] erledigt die beiden Schritte in einem Durchgang. 
Für die Darstellung ist diese Funktion nur noch geeignet aufzurufen. 
Das geschieht in der Funktion [[fSavePlot]].

\paragraph{Erneutes Bildeinblenden.}
Durch ein Überschreiben des Inhalt des Reportfensters gehen die eingeblendeten Bilder verloren.
Deshalb müssen sie dann erneut integriert, aber nicht neu erzeugt werden.
Hierzu dient die Funktion [[show.plots.again]], die die Tcl/Tk-Prozedur [[showsingleimage]]
aufruft. [[show.plots.again]] wertet die Liste der bisher erstellten Reportfensterplots aus und 
realisiert erneut deren Integration im Reportfenster.
Für diesen Prozess sind keine Fallunterscheidungen erforderlich.
Siehe: [[<zeige Bilder im Textfenster an>]]

\paragraph{Bildrekonstruktion mit neuer Bildverwaltung.}
Falls einmal die Verwaltung zum erneuten Einblenden von Graphiken gestört ist, muss diese
repariert werden. Dazu dient die Funktion [[createandshow.all.plots]].

\paragraph{Zusammenfassung der wichtigen Routinen:}
Zur Darstellung von Bilder im Reportfenster gibt es die Funktionen:\\
*  createandshow.single.plot (verwendet tcltk--createandshowimagejpg,-gif,-ppm),\\
*  createandshow.all.plots   (verwendet tcltk--createandshowimage),\\
*  show.plots.again          (verwendet tcltk--showsingleimage),\\
*  exclude.plots.\\
Es kommen dabei die Tcl/TK-Prozeduren: \\
*  createandshowimagejpg, createandshowimagegif, createandshowimageppm,   showsingleimage \\
zum Einsatz.

@
\paragraph{Wie wird der Bild-Name ermittelt?}
Der Name eines Bildes wird auf Basis des Datums konstruiert.
Das Kopieren des Bildes wird in [[<lege Bild unter bildname ab>]] behandelt.
Zum Schluss wird ggf.\ das Bild im Reportfenster eingetragen.
Das Bild sollte in der Zeile [[insertline.0]] eingefügt werden können;
dieses beschreibt den Beginn der Leerzeile zwischen dem LaTeX- und dem 
html-Verweis auf die Graphik.
%  # tworkwin, no.plots must be available # no.plots<-get("no.plots",envir=revive.sys) #081125
<<definiere Funktion für Knopf: [[SavePlot]]>>=
fSavePlot<-function(){
  melde("fSavePlot",1)
  h<-gsub(" +"," ",date()); h<-strsplit(gsub(":","",h)," ")[[1]]
  bildname<-paste("p",h[5],"-",h[2],h[3],"-",h[4],".ps",sep="")
  <<lege Bild unter [[bildname]] ab>>
  # include links
  if(!is.null(bildname)&&nchar(bildname)>0){
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<schreibe [[news]] hinter aktuellen Chunk>>
    melde(paste("p", psname), "cmd.msg")
  }
  insertline<-insertline+3 # insertline is assigned during writing the pic link in the report
  base::cat(bildname,"is included into the report\n")
  if(!no.plots){
    if(<<OS ist Mac-Mini>>){ picname <- gifname; type <- "gif" } else 
    ##  if(Img.package.found)      { picname <- jpgname; type <- "jpg" } else ## 121114 jpg
        if(2<=nchar(ghostscript)){ picname <- ppmname; type <- "ppm" } else type <- NA
    # there had been situations in which the (windows) file system was to slow !!
    if(!is.na(type) ) Sys.sleep(0.2) 
    if(!is.na(type) && !file.exists(picname) && file.exists(sub("....$",".ps",picname))) Sys.sleep(0.2) 
    if(!is.na(type) && !file.exists(picname) && file.exists(sub("....$",".ps",picname))) Sys.sleep(0.4) 
    if(<<OS ist Mac-Mini>>) createandshow.single.plot(tworkwin,insertline,picname,type=type) else 
    ##  if(Img.package.found) createandshow.single.plot(tworkwin,insertline,picname,type=type) else ## 121113
        if(2<=nchar(ghostscript)) createandshow.single.plot(tworkwin,insertline,picname,type=type)
  }
  melde("fSavePlot",2)
}

@
Falls die Aufrufoption [[no.plots=TRUE]] gesetzt wurde, werden keine Bilder im Manager angezeigt. 
Das kann im Falle von Speicherproblemen oder aus Geschwindigkeitsgründen angeraten sein.

@
\paragraph{Kopieren eines Bildes.}
Für die Möglichkeit des Einfügens von Bildern im Report wurde ein eigener Chunk konzipiert.
Auf [[bildname]] darf ein Name mit oder ohne Endung [[.ps]] angegeben werden.
Nach einem Namenscheck werden postscript-, jpg- sowie ggf.\ ppm- und gif-Kopien mittels
[[dev.copy]]. Dabei werden Links eingetragen und ggf.\ Fehlermeldungen erzeugt.
 
Im Reportfenster wird ein für \LaTeX\ verständlicher Link eingetragen,
so dass später in der Druckversion das Bild automatisch in das Dokument integriert wird.
Die Link-Information für das Reportfenster geschieht mit einem Chunk,
der den Inhalt von [[news]] in den Arbeitstext nahe des Cursors schreibt.
Die Bilder selbst werden kopiert und per Funktion [[createandshow.single.plot]] 
angezeigt.
<<lege Bild unter [[bildname]] ab>>=
if(!is.null(bildname)&&nchar(bildname)>0){
# check name of picture
  n<-nchar(bildname<-gsub(" ","",bildname))
  bildname<-sub(".ps$","",bildname)
# postscript:
  psname <-paste(bildname,".ps", sep="")
  try.res<-try({dev.copy(postscript,psname,horizontal=pshorizontal.sys,
                         width=psdesignwidth.sys,height=psdesignheight.sys);dev.off()})
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok){ cat("Error: *ps file not generated by dev.copy!!!\n"); return() }
  news<-paste("@\n \\begin{center}","\\includegraphics[",
              "height=",psheight.sys,"]{",bildname,"}\\end{center}\n",sep="") #081121
# jpeg:
  jpgname<-paste(bildname,".jpg",sep="")
  if(<<das OS ist Windows>>){ # width=width in pixel, 72 dpi
    try.res<-try({dev.copy(jpeg,jpgname,width=jpgdesignsize.sys*72,
                           height=jpgdesignsize.sys*72,quality=100,pointsize=7);dev.off()})
  }else{
    try.res<-try({dev.copy(bitmap,type="jpeg",jpgname,
         width=jpgdesignsize.sys,height=jpgdesignsize.sys);dev.off()})
  }
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok) cat("Error: *jpg file not generated by dev.copy!!!\n")
  news<-paste(news,'\n% <p><img src="',jpgname,'">\n@\n', sep="" )
# ppm
  ppmname<-paste(bildname,".ppm",sep="")
  # if( <das OS ist Windows>  && 2<=nchar(ghostscript) && !Img.package.found && !no.plots){
  if(<<das OS ist Windows>> && 2<=nchar(ghostscript) && !no.plots){
    try.res<-try({dev.copy(bitmap,type="ppmraw",ppmname,res=ppmresolution.sys);dev.off()})
  }
  # if( <das OS ist Linux> && 2<=nchar(ghostscript) && !Img.package.found && !no.plots){ }
  if(<<das OS ist Linux>> && 2<=nchar(ghostscript) && !no.plots){ # 121113
    try.res<-try({dev.copy(bitmap,type="ppmraw",ppmname,res=ppmresolution.sys);dev.off()})
  }
# gif+ppm:
  if(<<OS ist Mac-Mini>> && !no.plots){
    gifname<-paste(bildname,".gif",sep="")
    try({dev2bitmap(type="ppmraw",ppmname,res=ppmresolution.sys); dev.off()}) #121218
    try.res<-try({system(paste("convert",jpgname,gifname))})
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(!ok) cat("Error: gif file not generated by dev.copy!!!\n")
  }
}

@
\paragraph{Ad ppm-Kopien und [[ghostscript]].}
Ab Version Sept.2011 werden bei nicht jpg-fähigen Tcl/Tks kleine ppm-Bilder eingeblendet.
Deren Erzeugung geschieht mit [[dev.copy]], das die Funktion [[bitmap]] aufruft, 
die wiederum [[ghostscript]] (unter Windows genauer: [[gswin32c.exe]]) startet. 
Damit der Vorgang erfolgreich ist, muss also unter windows [[gswin32c.exe]] gefunden werden. 
Das ist kein Problem, wenn der Suchpfad im System den Pfad zum [[gswin32c]] enthält. 
Zweitens ist es ausreichend, wenn es die Umgebungsvariable [[R_GSCMD]] passend gesetzt ist:\\
[[Sys.setenv("R_GSCMD"="C:\\Programme\\gs\\gs8.71\\bin\\gswin32c.exe")]]

@
Das vergebliche Anstoßen von [[gswin32c.exe]] hat schon andere beschäftigt:
{\footnotesize
\begin{verbatim}
On Fri, 14 Jan 2011, Jeremy Koster wrote:
> A colleague designed a script for a bar plot, which I'd like to
> export to my directory via the barplot command:
>
> bitmap(file="barplot.tif", type="tifflzw", height=4, width=6.5, res=1250)
>
> Unfortunately, this command produces the following error message:
>
> Error in system(paste(gsexe, "-help"), intern = TRUE, invisible = TRUE) :
>  'gswin32c.exe' not found
>
>> From consulting the archives and the help file, I deduced that I
>> needed to install Ghostscript, which I did.  Subsequent messages in
>> the archives suggest directing R toward Ghostscript using an
>> environmental variable, specifically R_GSCMD.
... [show rest of quote]

Please do read the help page.  You didn't tell us if you added
Ghostscript to your path: if you had done so this would not be needed
(as the help page says).

> Unfortunately, I haven't figured out how to use this command.  Can
> anyone provide assistance?

Sys.setenv(GS_CMD="C:/Program Files/gs/gswin32c.exe")
if what you say below is correct, but
Sys.setenv(GS_CMD="C:/Program Files/gs/bin/gswin32c.exe")
would be more standard for recent versions of Ghostscript.

> This is for R version 2.12.0 using Windows XP on a Dell laptop.

OK, but next time please consult the posting guide and give us the
'at a minimum' information asked for there (we need to know if this is
32- or 64-bit Windows on a 32- or 64-bit OS -- and although rare,
64-bit Windows XP does exist).

> The path for ghostscript in my program files folder is: C:\Program
> Files\gs
>
> Many thanks,
> Jeremy
> UC Anthropology

BTW, asking how to set environment variables is covered in the rw-FAQ
and is not an R-devel topic.

-- 
Brian D. Ripley,                  [hidden email] 
\end{verbatim}
} % end of footnotesize

@
\paragraph{Bilder wieder einblenden.}
Nach Erneuern des Reportfensterinhalts müssen die Bilder neu in Reportfenster eingetragen werden. 
In solchen Fällen werden zur Sicherheit alle Bilder entfernt und dann wieder eingefügt.
Für die Anzeige der Bilder in einem Fenster wurde die Funktionen [[show.plots.again]] entworfen.
Diese sucht im Text nach [[<img src=]], extrahiert die Namen der Bilder
und intergriert sie mit Hilfe der {\sc Tcl/Tk}-Prozedur [[showsingleimage]].
Dieser Prozedur ist der Name des Text-Widget, die Nummer des Image (Bildes)
und die Stelle mitzugeben.
Die Funktion [[exclude.plots]] entfernt die Graphiken aus dem Reportfenster.
<<zeige Bilder im Textfenster an>>=
if(!no.plots) { exclude.plots(tworkwin); show.plots.again(tworkwin) }

@
\paragraph{Bilderverwaltung erneuern und wieder einblenden.}
Falls verbesserte, neue Graphiken generiert worden sind, muss stimmt die Verwaltung nicht 
mehr und muss aktualisiert werden. Dieses leistet die Funktion
[[createandshow.all.plots()]].
<<kreiiere Bilder neu und zeige sie im Textfenster an>>=
if(!no.plots) { exclude.plots(tworkwin); createandshow.all.plots(tworkwin) }

@
\paragraph{Die Erzeugung einer Tcl/Tk-Repräsentation von Bildern.}
Die Tcl/Tk-Repräsentaten von Bildern müssen innerhalb von Tcl/Tk erzeugt werden.
Im Folgenden wird dazu für jedes Format eine Prozedur definiert:
[[createandshowimage...]] Je nach Situation
muss die entsprechende eingesetzt werden.
Es gibt verschiedene Anzeigesituationen: \\
a) Img-Tcl/Tk-Paket existiert, dann soll ein jpg-File verwendet werden (z.B.\ Linux),
b) ohne Img-Tcl/Tk-Paket, aber ghostview ist vorhanden: ppm-File, c) für Mac-Welt: verwende gif-File.
Die Tcl/Tk-Prozedur [[showsingleimage]] integriert ein Image in dem genannten Widget an der angegebenen
Stelle.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
# a new plot should be shown in a Tcl/Tk widget
.Tcl( paste(""
  ,"proc createandshowimagegif {w im place} {"
  ,"global imageno"
  ,"set imageno [image create photo -format gif -file $im]" 
  ,"$w image create $place -image $imageno"
  ,"}"
  ,"proc createandshowimagejpg {w im place} {"
  ,"global imageno"
  ,"set imageno [image create photo -format jpeg -file $im]" 
  ,"$w image create $place -image $imageno"
  ,"}"
  ,"proc createandshowimageppm {w im place} {"
  ,"global imageno"
  ,"set imageno [image create photo -format ppm -file $im]" 
  ,"$w image create $place -image $imageno"
  ,"}"
, sep="\n")) 
assign("pic.list.sys",NULL,envir=revive.sys)
# --------------------------------------------------------------------
# show an image 
try(.Tcl( paste(
  "proc showsingleimage {w imageno place} {",
     "$w image create $place -image $imageno",
  "}", sep="\n") ) )

@
\paragraph{Definition von [[createandshow.single.plot]].}
[[createandshow.single.plot]] ruft nach Format-Situation die passende Tcl-Tk-Funktion auf und 
aktualisiert die Bildverwaltung [[pic.list]]. [[pic.list]] ist ein zweispaltige Matrix
mit den Bildnamen in der ersten und der Tcl/TK-Bildnummern in der zweiten Spalte.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
createandshow.single.plot<-function(textwidget,row.of.plot,picname,type="jpg"){
  melde("createandshow.single.plot",1)
  # base::cat(picname,"will be included into report field\n") 
  if(!file.exists(picname)){cat("relax warning:",picname,"not found"); return()}
  # create and show image
  place<-paste(row.of.plot,".0",sep="")
  if(type=="jpg") try.res<-try(tcl("createandshowimagejpg",textwidget,picname,place))
  if(type=="gif") try.res<-try(tcl("createandshowimagegif",textwidget,picname,place))
  if(type=="ppm") try.res<-try(tcl("createandshowimageppm",textwidget,picname,place))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  # update pic list
  if(try.res=="ok"){
    imageno<-tclvalue(.Tcl("set imageno"))
    pic.list<-rbind(get("pic.list.sys",envir=revive.sys),c(picname,imageno))
    assign("pic.list.sys",pic.list,envir=revive.sys)
  }
  melde("createandshow.single.plot",2)
}

@
\paragraph{Definition von [[show.plots.again]].}
Das Arbeitsfenster wird eingelesen, die gewünschten Bilder werden ermittelt,
aus der Bildverwaltung [[pic.list]] werden die Bildnummern herausgesucht und dann werden
die Bilder eingeblendet.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
show.plots.again<-function(tworkwin){
    melde("show.plots.again",1)
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    rows   <-grep("<img src=",worktext); if(0==length(rows))return()
    pic.names.report  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), 
                             function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
    pic.list<-get("pic.list.sys",envir=revive.sys)
    ind<-match(sub("....$","",pic.names.report),sub("....$","",pic.list[,1]))
    image.ok<-!is.na(ind); ind<-ind[image.ok]
    if(0==length(ind))return()
    place<-paste(rows[image.ok]-1,".0",sep=""); imageno<-pic.list[ind,2]
    for(i in seq(imageno)){ 
         try(tcl("showsingleimage",tworkwin,imageno[i],place[i]))
    }
    melde("show.plots.again",2)
}

@
\paragraph{Definition von [[createandshow.all.plots]].}
Das Arbeitsfenster wird eingelesen, die gewünschten Bilder werden ermittelt,
die Bildverwaltung [[pic.list]] wird neu aufgebaut und dann werden
die Bilder eingeblendet.
Je nach Situation wird die geeignete Endung (das passende Format) bestimmt und dann 
mit den entsprechenden Tcl/Tk-Erzeugungsprozeduren die Generierung von Repräsentanten umgesetzt. 
In Vorbereitung ist ein Abschnitt, um fehlende Bilder ggf.\ auf Basis der
Postscript-Version neu zu generieren.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
# create and show all plots
createandshow.all.plots<-function(tworkwin){
   melde("createandshow.all.plots",1)
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    rows   <-grep("<img src=",worktext); if(0==length(rows))return()
    pic.names.report<-unlist(lapply(strsplit(worktext[rows],"<img src=\""), 
                             function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
    place<-paste(rows-1,".0",sep="")
    if(0==length(pic.names.report)) return()
    # fix pic name / file 
    if(<<OS ist Mac-Mini>>) picname<-sub(".jpg$",".gif",pic.names.report) else 
    ##  if(Img.package.found) picname<-pic.names.report  else ## 121113 jpg
        if(2<=nchar(ghostscript)) picname<-sub(".jpg$",".ppm",pic.names.report)
    # create missing files by postscript versions of the images
    if(!<<OS ist Mac-Mini>>){ #12114
      for(i in seq(picname)){
         melde(paste("generation of ppm",picname[i]),3)
         # ggf. new generation of plot
         if(file.exists(sub("....$",".ps",picname[i])) && (!file.exists(picname[i]))){
           ##  if(Img.package.found) 
           ##         pstojpg(sub("....$",".ps",picname[i]),picname[i]) else
           res <- try(pstoppm(sub("....$",".ps",picname[i]),picname[i])) #121114
         }
      }
    }
    # 
   image.nos<-rep("xx",length(picname))
   for(i in seq(picname)){
     melde(paste("integration of ppm",picname[i]),3) # resolution
     if(!file.exists(picname[i])){
       next
     }
     if(<<OS ist Mac-Mini>>) 
       try.res<-try(tcl("createandshowimagegif",tworkwin,picname[i],place[i])) 
     else
       ## if(Img.package.found)
       ##   try.res<-try(tcl("createandshowimagejpg",tworkwin,picname[i],place[i]))
       ## else ## 121113 jpg
       if(2<=nchar(ghostscript)) 
         try.res<-try(tcl("createandshowimageppm",tworkwin,picname[i],place[i])) 
     <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
     if(try.res=="ok") image.nos[i]<-tclvalue(.Tcl("set imageno"))
   }
   pic.list<-cbind(picname,image.nos)
   pic.list<-pic.list[pic.list[,2]!="xx",,drop=FALSE]
   assign("pic.list.sys",pic.list,envir=revive.sys)
   melde("createandshow.all.plots",2)
} 

@
\paragraph{Definition von [[exclude.plots]].}
Das Entfernen von Bildern ein Aufspüren der Bilder sowie anschließend die technische Entfernung.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
exclude.plots<-function(tworkwin){
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  rows<-grep("<img src=",worktext); if(0==length(rows))return()
  names  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), 
                  function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
  rows <- rows - 1   # + 1
  for(i in seq(along=rows)){
    anf<-paste(rows[i],".0",sep=""); end<-paste(rows[i],".end",sep="")
    a<-tclvalue(tkget(tworkwin,anf,end))
    tkdelete(tworkwin,anf,end)
    tkinsert(tworkwin,anf,paste(a,collapse="\n")) # 040922
#    tkdelete(tworkwin,paste(rows[i],".0",sep=""),paste(rows[i],".1",sep=""))
  }
}

@
\paragraph{Rekonstruktion fehlender Bilder.}
In Vorbereitung ist ein Abschnitt, um fehlende Bilder auf Basis ihrer
postscript-Versionen zu generieren. Dazu ist ghostscript erforderlich.

Technisch lässt sich bspw.\ ein jpg-Bild aus einem ps-Bild mittels [[ghostscript]] erzeugen durch:
\begin{verbatim}
  gs -dBATCH -sDEVICE=jpeg -sOutputFile=tmp1.jpg -quit -dNOPAUSE tmp1.ps
\end{verbatim}
Falls [[ppm]]- oder andere Typen nicht vorhanden sind können diese entsprechend aus den
[[ps]]-Dateien generiert werden:
\begin{verbatim}
  gs -dBATCH -sDEVICE=ppmraw -sOutputFile=tmp1.ppm -quit -dNOPAUSE tmp1.ps
\end{verbatim}
Zur Erzeugung kleiner Graphiken für das Reportfenster kann die Auf\-lösung gesetzt werden:
\begin{verbatim}
  gs -dBATCH -sDEVICE=ppmraw -r20x20 -sOutputFile=tmp1.ppm -quit -dNOPAUSE tmp1.ps
\end{verbatim}
Alternativ lassen sie sich ppm-Files durch Kopieren des graphischen Device erzeugen:
\begin{verbatim}
dev.copy(bitmap,"ppmraw",file="tmp0.ppm",res=20) 
\end{verbatim}
<<definiere Funktion für Knopf: [[SavePlot]]>>=
pstojpg<-function(psname,jpgname){
  return() # im Moment nicht im Dienst
  if(<<das OS ist Linux>>){
    gsexe <- Sys.getenv("R_GSCMD")
    if(is.null(gsexe) || nchar(gsexe) == 0) {
      gsexe <- "gs"; rc <- system(paste(gsexe, "-help > /dev/null"))
      if (rc != 0) return()
    }
  }
  if(<<das OS ist Windows>>){
    if(exists("ghostscript")&&2<=nchar(ghostscript)&&0<length(grep("[A-Za-z]",ghostscript))) 
      gsexe<-ghostscript else return()
  }
  type<-"jpeg"; width<-height<-13; res<-30
  cmd <- paste(gsexe, " -dNOPAUSE -dBATCH -q -sDEVICE=", type,
                      " -r", res,
                      " -g",ceiling(res*width),"x",ceiling(res*height),
                      " -sOutputFile=", jpgname, "  ",psname, sep = "")
  try(system(cmd)); invisible()
}
pstoppm<-function(psname,ppmname){
  # return() # im Moment nicht im Dienst // ginge auch mit convert
  melde("pstoppm startet",3)
  if(<<das OS ist Linux>>){
    gsexe <- Sys.getenv("R_GSCMD")
    if(is.null(gsexe) || nchar(gsexe) == 0) {
      gsexe <- "gs"; rc <- system(paste(gsexe, "-help > /dev/null"))
      if (rc != 0) return()
    }
  }
  if(<<das OS ist Windows>>){
    if(exists("ghostscript")&&2<=nchar(ghostscript)&&0<length(grep("[A-Za-z]",ghostscript))) 
      gsexe<-ghostscript else return()
  }
  type<-"ppmraw"; res<-ppmresolution.sys # 121114
  cmd <- paste(gsexe, " -dNOPAUSE -dBATCH -q -sDEVICE=", type,
                      " -r", res,
                      " -sOutputFile=", ppmname, "  ",psname, sep = "")
  melde(cmd,3)
  try(system(cmd))
  if(<<das OS ist Linux>> && 0 < nchar(system("which pnmcrop",intern=TRUE))){ # 121114
    system(paste("mv ",ppmname," tmptmp.ppm; pnmcrop tmptmp.ppm > ",ppmname,"; rm tmptmp.ppm"))    
  }                       
  invisible()
}

@
\paragraph{alte Dinge}
Zunächst die bekannte Struktur:
Ab 1.2008 wird bei der Speicherung eines neuen Plots nur dieser neu eingeblendet. 
An den übrigen soll sich nichts ändern.
Früher wurden alle Bilder mit dem Chunk [[zeige Bilder im Textfenster an]]
neu integriert.  
<<old version for integrating plots>>=
createandshow.single.plot<-function(textwidget,row.of.plot,jpgname,type="jpg"){ # up to 09/2011
  melde("createandshow.single.plot",1)
  # fix pic name / file 
  if(<<OS ist Mac-Mini>>) { 
    picname <- sub(".jpg$",".gif",jpgname) 
  } else {
    picname <- jpgname 
    # ggf. new generation of plot
    if(file.exists(sub("....$",".ps",picname)) && (!file.exists(picname))){
        if(Img.package.found) pstojpg(sub("....$",".ps",picname),picname)
        else                  pstoppm(sub("....$",".ps",picname),picname) 
        ## function calls with no effects
    }
  }
  cat("Bild:", picname,"einzubauen") #### ?????
  if(!file.exists(picname)) return()
  # create and show image
  place<-paste(row.of.plot,".0",sep="")
  try.res<-try(tcl("createandshowimage",textwidget,picname,place))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  # update pic list
  if(try.res=="ok"){
    imageno<-tclvalue(.Tcl("set imageno"))
    pic.list<-rbind(get("pic.list.sys",envir=revive.sys),c(picname,imageno))
    assign("pic.list.sys",pic.list,envir=revive.sys)
  }
  melde("createandshow.single.plot",2)
}
show.plots<-function(textwidget,is.reportwin=TRUE,path.of.plots){
   try(.Tcl( paste(
  "proc showimage {w im place} {",
   if(<<OS ist Mac-Mini>>) 
    "$w image create $place -image [image create photo -format gif -file $im]" else
    "$w image create $place -image [image create photo -format jpeg -file $im]"  ,
  "}", sep="\n") ) )
  if(is.reportwin){
    tworkwin <- textwidget
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    rows   <-grep("<img src=",worktext)
    if(0==length(rows))return()
    jpgnames  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), ## vorher "figure="
                    function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
  }
  picnames<-if(<<OS ist Mac-Mini>>) sub(".jpg$",".gif",jpgnames) else jpgnames
  for(i in seq(along=rows)){
    if(!<<OS ist Mac-Mini>>){
      if(file.exists(sub(".jpg$",".ps",picnames)[i])& (!file.exists(picnames[i]))){
        pstojpg(sub(".jpg$",".ps",picnames)[i],picnames[i])
      }
    }
    if(file.exists(picnames[i]))
      try(tcl("showimage",textwidget,picnames[i],paste(rows[i]-1,".0",sep="")))
  }
}
exclude.plots<-function(tworkwin){
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  rows   <-grep("<img src=",worktext)
    if(0==length(rows))return()
  names  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), ## vorher "figure="
                  function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
  rows <- rows - 1   # + 1
  for(i in seq(along=rows)){
    anf<-paste(rows[i],".0",sep=""); end<-paste(rows[i],".end",sep="")
    a<-tclvalue(tkget(tworkwin,anf,end))
    tkdelete(tworkwin,anf,end)
    tkinsert(tworkwin,anf,paste(a,collapse="\n")) # 040922
#    tkdelete(tworkwin,paste(rows[i],".0",sep=""),paste(rows[i],".1",sep=""))
  }
}

@
Für das Laden von [[relax]] vor dem Laden von [[Tcl/Tk]] muß der
Aufruf von [[.Tcl]] innerhalb einer Funktion stehen. Darum wird
die Prozedur [[.Tcl]] innerhalb [[show.plots]] aufgerufen.


@
\paragraph{Formeln als Bilder integrieren.}
Für Windows mußten einige Handstände mehr als für Linux absolviert werden.
Ziel ist es, einen Text-Chunk auf Knopfdruck zu formatieren und eine entsprechende
Graphik im jpeg-Format zu erstellen. Die einzelnen Schritte lauten:
\begin{enumerate}
\item ermittle Code-Chunk
\item formatiere Zeilen: erstelle dvi-Datei, erstelle PS-Datei, erstelle jpeg-Datei
\item erstelle jpg-Bild
\item integriere Bild
\end{enumerate}

Unter Windows ist die Erstellung der jpeg-Datei etwas aufwendiger,
da die PS-Datei von ihrem weißen Rahmen befreit werden muss.
Dazu wird zunächst eine riesige ppm-Datei mit [[ghostscript]] erstellt,
dann mit [[ppmcrop]] der Rahmen entfernt, um zum Schluss mittels [[ppmtojpeg]]
die ersehnte jpeg-Datei zu erhalten. Dazu sind folgende Hilfsprogramme
die im Verzeichnis [[../relax/lib]] abgelegt sind, erforderlich:
%[[libjpeg.dll]], [[ppmtojpeg]] in [[netPBM_v10.6_win32.zip]]
%über [[http://prdownloads.sourceforge.net/exoops/netPBM_v10.6_win32.zip?download]]

Erforderlich sind:
[[pnmcrop.exe]], [[netpbm.dll]], [[ppmtojpeg.exe]], [[libjpeg.dll]].
Diese müssen in [[library/relax/lib]] liegen.

Diese Programme scheinen miteinander verträglich zu sein.
Die Programme wurden gefunden über:\\
\verb+http://www.e-xoops.com/public/modules/mydownloads/singlefile.php?lid=27+\\
\verb+http://prdownloads.sourceforge.net/exoops.com/netPBM_v10.6_win32.zip?downloads+\\
\verb+http://prdownloads.sourceforge.net/exoops.com/netPBM_v10.6_win32.zip?use_mirror=heanet+\\
-- mit der neuesten netpbm-Version gelang kein Erfolg.

@
weitere Links zu dem Thema:\\
\verb+http://prdownloads.sourceforge.net/gallery/+\\
\verb+netpbm1.1-gallery1.0-win32.tgz?use_mirror=cesnet+\\
\verb+http://web.mit.edu/windows-graphics/bin/+
z.Z. unused
<<definiere Kopf-Zeilen-Funktionen>>=
FormatTeXLines<-function(){
  melde("FormatTeXLines",1)
  # ermittle neue Zeilen:
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  text.start<-h<-grep("^@",c(worktext,"@"))
  texbegin<-rev(text.start[text.start<line])[1]; if(is.na(texbegin)) return()
  texend<-text.start[text.start>line][1]
  code.start<-grep("^@<<(.*)>>=",worktext)
  c.start<-rev(code.start[code.start<line])[1]
  if(!is.na(c.start) &&  c.start>texbegin ) return()
  c.end<-code.start[code.start>line][1];  if(!is.na(c.end))texend<-min(texend,c.end)
  ttext<-worktext[(texbegin+1):(texend-1)]
  # formatiere Zeilen
  ttext<-c("\\documentclass{article}\\pagestyle{empty}\\parindent0mm",
           "\\begin{document}\\LARGE",ttext,"\\end{document}")
  cat(ttext,file="tmptmp.tex",sep="\n")
  # erstelle jpg-bild
  h<-gsub(" ","",gsub(":","",date())); h<-substring(h,4:nchar(h),4:nchar(h))
  jpgname<-paste(c("t",h[6:11],h[4:5],h[1:2],h[14:15],".jpg"),collapse="")
  ppmname<-paste(c("t",h[6:11],h[4:5],h[1:2],h[14:15],".ppm"),collapse="")
  if(<<das OS ist Linux>>){ #121114
    system("echo q | latex tmptmp.tex; dvips -E tmptmp.dvi")
    system(paste("convert tmptmp.ps ",jpgname))
    system(paste("convert tmptmp.ps tmptmp.ppm; pnmcrop tmptmp.ppm > ",ppmname))
    system("rm tmptmp.tex tmptmp.aux tmptmp.log tmptmp.ppm tmptmp.dvi tmptmp.ps")
  }
  if(<<das OS ist Windows>>){ #121114
    if(!(exists("ghostscript")&&2<=nchar(ghostscript)&&0<length(grep("[A-Za-z]",ghostscript)))) 
       return()
       if(!file.exists(paste(ghostscript,".exe",sep=""))){
          cat("ERROR: sorry, ghostscript not found!!!\n"); return()
       }
       ft.path<-file.path(relax.path,"lib")
       ft.path<-ft.path[file.exists(ft.path)][1]
       try(shell("echo q | latex tmptmp.tex"))
       try(shell("dvips -E tmptmp.dvi"))
       try(shell(paste(ghostscript,
  " -dBATCH -sDEVICE=ppmraw -quit -sOutputFile=tmptmp.ppm -dNOPAUSE tmptmp.ps", sep="")))
       try(shell(paste(ghostscript,
  " -dBATCH -sDEVICE=jpg -quit -sOutputFile=tmptmp.jpg -dNOPAUSE tmptmp.ps", sep="")))
       try(shell(file.path(ft.path,"\\pnmcrop   tmptmp.ppm   > tmptmp.crp")))
       try(shell(paste(ft.path,"\\ppmtojpeg tmptmp.crp   > ",jpgname,  sep="")))
       try(shell(paste("cp tmptmp.ppm   > ",ppmname,  sep="")))
       try(shell("del tmptmp.tex tmptmp.aux tmptmp.log tmptmp.ppm tmptmp.crp tmptmp.dvi tmptmp.ps"))
  }
  # passe workttext an, integriere Bild
  insertline<-texend+3
  news<-paste("\n%<!--latex-end-->\n\n% <p><img src=\"",jpgname,"\">\n",sep="")
  line<-paste(texend,".0",sep="")
  <<schreibe [[news]] hinter [[line]]>>
  line<-paste(texbegin+1,".0",sep=""); news<-"%<!--latex-begin--\n"
  <<schreibe [[news]] hinter [[line]]>>
  ##zeige Bild im Textfenster an##
  no.plots<-get("no.plots",envir=revive.sys) #081125
  if(!no.plots) createandshow.single.plot(tworkwin,insertline,ppmname,type="ppm") #121114
  ## old: show.single.plot(tworkwin,line,jpgname) 
  melde("FormatTeXLines",2)
}

@
<<schreibe [[news]] hinter [[line]]>>=
<<hole ggf. [[tworkwin]]>>
<<lese Arbeitsfenster auf [[worktext]] ein>>
try(tkinsert(tworkwin,line,paste(news,collapse="\n")))
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))


@
\subsubsection{Kopfzeile: [[Edit]] --- [[InsertTeX]]}
\paragraph{[[InsertTeX]] zur Ersetzung von Abschnitten durch TeX-Formatierungsergebnis.
Speicherung des Ergebnisses als PS-Datei
und als [[Jpeg]]-Datei.}
z.Z. unused
<<definiere Funktion für Knopf: [[InsertTeX]]>>=
InsertTeX<-function(){
  melde("InsertTeX",1)
  h<-gsub(" ","",gsub(":","",date()))
  h<-substring(h,4:nchar(h),4:nchar(h))
  bildname<-paste(c("p",h[6:11],h[4:5],h[1:2],h[14:15]),collapse="")
  <<hole ggf. [[tworkwin]]>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  start<-grep("begin-tex-code",worktext)
  start<-rev(start[start<line])[1]
  ende<-grep("end-tex-code",worktext)
  ende<-ende[ende>start][1]
  h<-worktext[start+1:ende-1]
  h<-c("\\documentclass{article}\\begin{document}",h,"\\end{document}")
  cat(h,file="tmptmp.tex",sep="\n")
  if( <<das OS ist Linux>> || <<OS ist Mac-Mini>>) 
     system("echo q|latex tmptmp.tex;dvips tmptmp.dvi")
  ##lege Bild unter [[bildname]] ab##
  ##zeige Bilder im Textfenster an##
  ##show.single.plot(tworkwin,line,jpgname) 
  melde("InsertTeX",2)
}

@
\subsubsection{Kopfzeile: [[Examples]]}
Der Knopf [[Examples]] soll die R-Beispiele aus der Hilfe anzeigen.
<<definiere Funktion für Knopf: [[Examples]]>>=
fExamples<-function(){
  melde("fExamples",1)
  if(paste(R.version$major,R.version$minor,sep="")<211){
    cat("sorry, for this version not implemented, have a look at the help ..."); return()
  }
  frage<-"name of R function?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      topic<-tclvalue("tvinfo")   # topic <- "plot"
      # find package of object
      package <- sub(".*:","",find(topic))
      # don't use relax if object is redefined 
      if(length(package)>1 && ("relax" %in% package)) 
        package <- package[-which("relax" == package)]
      # if no package found write warning message
      if(0<length(package) && !is.na(package)){
        if(is.function(get(topic))) {
          args<-deparse(args(get(topic)))
          args<-paste(args[-length(args)],collapse="\n")
          args[1] <- paste("# header of",topic,":\n#",args[1],"\n")
          args <- paste(args,collapse="\n")
        } else args <- NULL
        path <- path.package(package) # 130325 .path.package defunct
        alias <- file.path(path,"help","aliases.rds")
        ## rds <- base::.readRDS(file.path(path,"help","aliases.rds")) 
        ## 120110 function reconstructed because of change of name, 120822 because of defunc
        ## idea: 
        ## readRDS  <- function(file){ con <- gzfile(file, "rb"); on.exit(close(con)); 
        ##                            .Internal(unserializeFromConn(con, NULL)) } 
        readRDS  <- function(file){ con <- gzfile(file, "rb"); on.exit(close(con)); 
                                    unserialize(con) }
        rds <- readRDS(file.path(path,"help","aliases.rds"))
        help.name <- rds[which(names(rds)==topic)]
        help.text <- utils:::.getHelpFile(
          file.path(path.package(package),"help",help.name) # 130325 .path.package defunct
        )
        help.text <- as.character(help.text)
        idx <- grep("\\\\examples",help.text)
        if( 0 < length(idx)){
          help.text <- help.text[idx:length(help.text)]
          help.text <- sub("^\\\\examples","",help.text)
          help.text <- sub(".dontrun","'dontrun example';",help.text)
          help.text <- sub(".dontshow","'dontshow';",help.text)
          help.text <- sub("^ *%","#%",help.text)
          if(""==help.text[1]) help.text <- help.text[-1]
          if(0<length(grep("\\{",help.text[1])) && 
             0<length(grep("\\}",help.text[length(help.text)]))){
             help.text <- help.text[-c(1,length(help.text))]
          }
          help.text <- paste(help.text,collapse="")
          playground(code=
            paste(paste("# help examples of",topic,"-> last output will be printed:"),
                  paste(help.text,collapse=""),sep="\n"))
        } else help.text <- "\nrelax warning: no examples found"
          news<-args
      } else {
        news <- "\nrelax warning: not help page found!"
      }
      if(0<length(args) && is.character(args) && 0<nchar(args)) { #121217
        <<schreibe [[news]] ans Ende des Outputfeldes>>
      }
  })
  melde("fExamples",2)
}

@
\subsubsection{Kopfzeile: [[Help.R]]}
Als letzte Funktion muß [[Help.R]] für den Hilfeknopf definiert werden.

\paragraph{[[Help.R]] zum Start der Hilfe.}
Die Wirkungen der Knöpfe müssen natürlich auch noch festgelegt werden.
Als Vereinbarung soll gelten, daß die Anweisungen eines Knopfes
durch eine Funktion umgesetzt wird, deren Name sich
durch ein vor den Widget-Namen vorgestelltes [[f]] ergibt.

Der Druck von {\sc Alt-H} soll die gleiche Wirkung wie das Drücken des
Knopfes haben. Deshalb wird für das gesamte Top-Level-Fenster vereinbart,
bei dem Event [[<yen>]] (unter Unix) die Funktion [[fHelp.R]] auszuführen.
Inzwischen wurde das {\em physikalische} Ereignis [[<yen>]] gegen das
virtuelle [[@<<Help.R>>]] ausgetauscht. Dieses wird im Abschnitt über
plattformabhängige Dinge für {\sc unix} mit Hilfe von [[<yen>]] definiert.
Übrigens liefert der {\sc Tcl/Tk}-Interpreter die richtigen Tastatur-Codes
mit [[bind . <KeyPress> {puts  {%%K=%K}}]].
Wird ein Hilfetext gefunden, wird dieser jetzt nicht mehr in einem neuen Top-Level-Fenster
dargestellt, sondern mit Hilfe des Browsers. Die Verzögerung verhindert, dass
[[help.start()]] durch [[help(xyz)]] überholt wird.

Mit R-2.10.0 haben sich die help()-Argumente geändert, so dass dieses auch im Code 
hier berücksichtigt werden muss.
<<definiere Funktion für Knopf: [[Help.R]]>>=
fHelp.R<-function(){
  melde("fHelp.R",1)
  frage<-"name of R function?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      # help.start(browser=browser.sys); Sys.sleep(0.1);
      fns<-tclvalue("tvinfo")
      mess<-paste("documentation of",fns,"appears in the R window;",
			    "click \"ok\" and change to the R window")
      res<-tkmessageBox(message=mess,title="Help",icon="info",type="ok")
      try.res<-try(eval(parse(text=
##        paste("get(\"print\",\"package:base\")(help(\"",fns,"\",htmlhelp=FALSE))",sep="")
## wegen Argument-Änderung
        paste("get(\"print\",\"package:base\")(help(\"",fns,"\",help_type=\"text\"))",sep="")
      )))
      if(length(try.res)==0){
        mess<- paste("Warning: no documentation for",fns,"found!")
	res<-tkmessageBox(message=mess,title="Help",icon="info",type="ok")
      }
      mess<-paste("relax"); set.tclvalue("tvmess",mess)
    } # end of function
  )
  melde("fHelp.R",2)
}

@
<<unused>>=
fHelp.R<-function(){
  melde("fHelp.R",1)
  frage<-"name of R function?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
    #  help.start(browser=browser.sys); Sys.sleep(0.1);
      fns<-tclvalue("tvinfo")
      try.res<-try(helpcall<-eval(parse(text=(help.cmd<-paste("help(\"",fns,"\")",sep="")))))
      if(length(try.res)==0){
        mess<- paste("Warning: no documentation for",fns,"found!")
	set.tclvalue("tvmess",mess)
      }	else {
            #   if(##das OS ist Windows##){
       #    mess<-paste("view documentation of",fns,"appears in R window")
	# }
         #if(##das OS ist Linux##){
  	  mess<-paste("documentation of",fns,"appears in browser if it is running")
	  assign("cmds",paste(">",help.cmd,sep=""),envir=revive.env)
	  out<-tclvalue(tkget(toutwin,"0.0","end"))
          <<lese Arbeitsfenster auf [[worktext]] ein>>
	  report<-worktext
	    <<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>
	  Sys.sleep(0.1)
	  worktext<-report
	  <<schreibe [[worktext]] ins Arbeitsfenster>>
          <<aktualisiere Texthervorhebungen>>
	  worktext<-out
          <<schreibe [[worktext]] ins Outputfenster>>
	# }
      }
      set.tclvalue("tvmess",mess)
    } # end of function
  )
  melde("fHelp.R",2)
}

@
<<alter Code>>=
 such<-paste(R.home(),"library/base/help",tclvalue("tvinfo"),sep="/")
        if(!file.exists(such))return()
        sys.cmd<-if(<<das OS ist Windows>>) "type" else "cat"
        out<-try(system(paste(sys.cmd,such),TRUE))
        out<-out[-grep("^_",out)]
        .newl  <- tktoplevel(); tkwm.geometry(.newl,"+0+15")
        tkwm.title(.newl,paste("help text found: >",such,"< -- ",
                              "quit by Escape or Return!"))
        tkpack(tt<-tktext(.newl))
        try(tkinsert(tt,"0.0",paste(out,collapse="\n")))
        tkbind(.newl,"<Return>",function(){
                                 tkdestroy(.newl);set.tclvalue("tvndone",2)})
        tkbind(.newl,"<Escape>",function(){
                                 tkdestroy(.newl);set.tclvalue("tvndone",2)})
        tkwait.variable("tvndone")


@
Nachdem die Funktion entworfen ist, muß sie noch als [[command]]-Eigenschaft
des Knopfes vereinbart werden. Außerdem wird in einem Rutsch der short cut
mit Hilfe des virtuellen Ereignisses [[@<<Help.R>>]] festgelegt.


@
\subsubsection{An- und Einfügungen an Felder und sonstige Kleinigkeiten}
Da Einfügeoperationen an verschiedenen Stellen notwendig sind,
wollen wir hier für Einfügezwecke einige Chunks anbieten.

Anfügungen mit [[output-start]]- und [[-end]]-Klammer.
<<schreibe [[news]] ans Ende des Arbeitstextes>>=
<<hole ggf. [[tworkwin]]>>
pos.to.insert<-"end"
if(0<length(grep("output-start",news))){
  tail<-rev(strsplit(tclvalue(tkget(tworkwin,"end - 3 lines","end")),"\n")[[1]])
  ltail<-length(tail)
  if( (0==length(grep("@<<[*]>>=",tail[1:ltail]))) &&
     any(h<-("output-end"==substring(tail[1:ltail],1,11)))){
     news<-sub(".*output-start\n","",news)
     news<-sub("output-end","",news)
     h<-seq(along=h)[h][1]
     pos.to.insert<-paste("end -",h,"lines")
  }
}
try(tkinsert(tworkwin,pos.to.insert,paste(news,collapse="\n")))
tksee(tworkwin,"end - 0 lines")
melde("appended characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
Einfache Anfügung an das Outputfeld:
<<schreibe [[news]] ans Ende des Outputfeldes>>=
if(!exists("toutwin"))
  toutwin<-get("toutwin",envir=get("revive.sys",envir=revive.env))
pos.to.insert<-"end"
## news<-paste(gsub("\n+","\n",news),collapse="\n") # 111121
news<-paste(gsub("\n[ \n\t]*\n","\n",news),collapse="\n")
try(tkinsert(toutwin,pos.to.insert,news))
tksee(toutwin,"end - 0 lines")
melde("appended characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
Einfügung von [[news]] hinter den aktuellen Code-Chunk:
<<schreibe [[news]] hinter den aktuellen Code-Chunk>>=
<<hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
<<lese Arbeitsfenster auf [[worktext]] ein>>
if(0==length(insertline<-grep("^@",worktext))||
   0==length(insertline<-insertline[insertline>line])){
    try(tkinsert(tworkwin,"end","\n"))
    insertline<-"end"
  }else{
    insertline<-paste(insertline[1],"0",sep=".")
  }
try(tkinsert(tworkwin,insertline,paste(news,collapse="\n")))
tksee(tworkwin,insertline)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>=
line <-floor(as.numeric(tkindex(tworkwin,"insert")))

@
Für [[PlanRCode]] wurde dieser Chunk entworfen, mit dem [[news]]
hinter den aktuellen Chunk, also Code- oder Text-Chunk geschrieben wird.
<<schreibe [[news]] hinter aktuellen Chunk>>=
##hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
##lese Arbeitsfenster auf [[worktext]] ein>>
textstart<-grep("^@",worktext)-1; textstart<-textstart[textstart>=line][1]
codestart<-grep("^@<<(.*)>>=",worktext)-1; codestart<-codestart[codestart>=line][1]
if(is.na(codestart))codestart<-Inf; if(is.na(textstart))textstart<-Inf
insertline<-if(codestart==textstart) NA else min(codestart,textstart)
anzrows<-length(unlist(strsplit(news,"\n")))
if(is.na(insertline)){
    insertline<-"end"
    try(tkinsert(tworkwin,"end","\n"))
    try(tkinsert(tworkwin,"end",paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert","end - 2 lines")
    tksee(tworkwin,"end")  # paste(insertline+anzrows,"0",sep="."))
    insertline<-length(worktext)
}else{
  # in einem Text-Chunks muss ein Kl-Affe eingebaut werden.
    if(length(grep("@<<\\*>>=",news[1]))>0 && codestart < textstart) news<-c(news,"@\n")
    try(tkinsert(tworkwin,paste(insertline+1,"0",sep="."),paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert", paste(insertline+anzrows,"0",sep="."))
    tksee(tworkwin,paste(insertline+anzrows,"0",sep="."))
}
## melde(insertline)
<<aktualisiere Texthervorhebungen>>
##zeige Bilder im Textfenster an##
tkfocus(tworkwin)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
\paragraph{[[text.tkinsert]] und [[text.tkget]]:}
Zur zuverlässigen Behandlung von geschweiften Klammern und ähnlichen
Zeichen wurde die Funktion [[tkinsert]] in einigen Fällen
durch die Funktion [[text.tkinsert]]
ersetzt. Erste Versionen führten eine Sonderbehandlung der
Zeichen [[\{"}[]$]] \kannweg$ durch.
Wahrscheinlich ist die Funktion [[text.tkinsert]] bei der neuesten
{\sc Tcl/Tk}-Bibliothek überflüssig. Aber man kann ja nie wissen.

@
Der einzufügende Text ist über den formalen Parameter [[inserttext]]
zu übergeben. Die Position ist über [[position]] anzugeben.
Damit kann zum Beispiel [[tkinsert(tworkwin,"0.0",worktext)]]
durch [[text.tkinsert(tworkwin,"0.0",inserttext=worktext)]] ersetzt werden.
Später lassen sich so Anpassungen an Implementierungsänderungen leicht durchführen.
Besonderheiten für Sonderzeichen werden im Moment über entsprechende Events
gesteuert.
<<unused: definiere [[text.tkinsert]] und [[text.tkget]]>>=
text.tkinsert<-function(widget,position,inserttext=""){
  tkinsert(widget,position,paste(inserttext,collapse="\n"))
}
text.tkget<-function(widget,...){
  text<-tkget(widget,...)
  if(is.null(class(text)))  return(text)
  if("tclObj"==class(text)) return(tclvalue(text))
}


@
\paragraph{Arbeitsfenster einlesen:}
Das Auslesen des Reportfensters wird an verschiedenen Stellen benötigt.
Diese Operation wird hier in einem Text-Chunk zusammengefasst.
Hinter [[@<<tmp>>]] versteckt sich der Name für eine temporäre Datei.
Bei riesigen Texten ist die Aufsplittung in Zeilen innerhalb
von R zu zeitaufraubend, so dass dieses Problem mit einer
Schreibe-Lese-Operationen erledigt wird.
Der Text auf [[worktext]] ist der in Zeilen zerlegte Inhalt des
Arbeitsfensters.
<<lese Arbeitsfenster auf [[worktext]] ein>>=
if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
tworkwin<-get("tworkwin",envir=revive.sys)
worktext<-tclvalue(tkget(tworkwin,"0.0","end"))
if(nchar(worktext)<10000){
  worktext<-strsplit(worktext,"\n")[[1]]
}else{
  base::cat(worktext,file=<<tmp>>)
  worktext<-myscan(file=<<tmp>>,"",sep="\n",blank.lines.skip=FALSE)
}

@
Der Name einer temporären Datei soll nur an einer Stelle
ermittelt werden. Dieses geschieht hier.
<<ermittle Namen einer temporären Datei>>=
tmp.file.name <- tempfile("rt-tmp")
assign(tmp.file.name,"tmp.file.name",envir=revive.sys)

@
<<tmp>>=
get("tmp.file.name",envir=revive.sys)

@
Bei einigen alten Versionen gab es Kollisionen im Falle von Fehlbenutzungen
zum Beispiel von [[readline]], wenn vor dem Eingabe-Ende [[AdvanceNo]]
aktiviert wurde.
Falls solche Dinge wieder auftreten, läßt sich mit diesem Code-Chunk
der Name der temporäre Datei für [[sink]]-Operationen verändern.
<<ermittle Namen einer Sink-Datei>>=
tmp.sink.name <- tempfile("rt-sink")
assign(tmp.sink.name,"tmp.sink.name",envir=revive.sys)
@
vorher: "r.tmp"
<<tmp.sink>>=
get("tmp.file.name",envir=revive.sys)

@
\subsubsection{Arbeitsfenstersteuerung: [[TrashROutput]]}
\paragraph{[[TrashROutput]] zur Entfernung des letzten Output-Abdrucks.}
Es hat sich als sehr wichtig erwiesen, unbrauchbare Output bequem
wieder entfernen zu können. Zwar ist noch nicht ganz sicher, ob
die Leichtigkeit der Entfernung weise ist, jedoch
wird sie bereitgestellt. Auch wird noch überlegt einen
Papierkorb zu definieren, aus dem sich die gelöschten
Stücke wieder herausholen lassen.
<<definiere Funktion für Knopf: [[TrashROutput]]>>=
fTrashROutput<-function(){
  melde("fTrashROutput",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  out.end  <-grep("^output-end",worktext)
  out.end  <-out.end[out.end>=(line-1)][1]
  if(is.na(out.end)) return()
  out.start <-grep("^output-start",worktext)
  out.start<-rev(out.start[out.start<out.end])[1]
  if(is.na(out.end)) return()
  code.start   <-grep("^@<<(.*)>>=",worktext)
  code.start <- rev(code.start[code.start<out.end])[1]
  if(is.na(code.start)) return()
  if(code.start>out.start) return()
  if("@"==worktext[out.start-1]) out.start<-out.start-1
  if(""==worktext[out.start-1]) out.start<-out.start-1
  if(""==worktext[out.start-1]) out.start<-out.start-1
  trash<-worktext[out.start:out.end]
  worktext<-worktext[-(out.start:out.end)]
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  tkfocus(tworkwin)
  tkmark.set(tworkwin,"insert",paste(out.start-1,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("fTrashROutput",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[PlanRCode]]}
\paragraph{[[PlanRCode]] zur Vorbereitung eines neuen Schrittes.}
Dieser Knopf schreibt nur ein paar Zeichen ins Reportfenster.
<<definiere Funktion für Knopf: [[PlanRCode]]>>=
fPlanRCode<-function(){
   melde("fPlanRCode",1)
   <<lese Arbeitsfenster auf [[worktext]] ein>>
   news <- "\n@\n\n@<<*>>=\n\n"
   <<schreibe [[news]] hinter aktuellen Chunk>>
   <<lese Arbeitsfenster auf [[worktext]] ein>>
   <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
   ##zeige Bilder im Textfenster an##
   melde("fPlanRCode",2)
}

@
Annahme: worktext hält Arbeitsfenster
<<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>=
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
code.start<-grep("^@<<(.*)>>=",worktext)
try(if(0<length(code.start)){ 
       worktext[code.start]<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext[code.start])
       worktext[code.start]<-paste(worktext[code.start]," (",1:length(code.start),")",sep="")
})
<<schreibe [[worktext]] ins Arbeitsfenster>>
tkmark.set(tworkwin, "insert", paste(line,"0",sep="."))
tksee(tworkwin,paste(line,"0",sep="."))
tkfocus(tworkwin)

@
\subsubsection{Arbeitsfenstersteuerung: [[Up]]}
\paragraph{[[Up]] zum Cursor-Zurücksetzen.}
a<-get("tworkwin",envir=revive.sys)
tkmark.set(a,"insert","10.0")
<<definiere Funktion für Knopf: [[Up]]>>=
fUp<-function(){
  melde("fUp",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-rev(code.start[code.start<line])[1]
  if(!is.na(code.start)) tkmark.set(tworkwin, "insert", paste(code.start,".0",sep=""))
  tksee(tworkwin,"insert - 7 lines")  #;tksee(tworkwin,"insert + 7 lines")
  tksee(tworkwin,"insert + 4 lines")
  #090706 # tksee(tworkwin,"insert")
  melde("fUp",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[Down]]}
\paragraph{[[Down]] zum Cursor-Vorsetzen.}
<<definiere Funktion für Knopf: [[Down]]>>=
fDown<-function(){
  melde("fDown",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-code.start[code.start>line][1]
  if(!is.na(code.start)) tkmark.set(tworkwin, "insert", paste(code.start,".0",sep=""))
  tksee(tworkwin,"insert - 7 lines")  #;tksee(tworkwin,"insert + 7 lines") 
  tksee(tworkwin,"insert + 4 lines") 
  #090706 # tksee(tworkwin,"insert")
  melde("fDown",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[WarnEval]]}
\paragraph{[[WarnEval]] zur Evaluierung des Chunks, auf den der
Cursor zeigt.}
Vor der Aktivierung muß der betreffende Code-Chunk ermittelt werden.
Falls er noch nicht expandierte Module enthält, müssen diese
expandiert werden --- dieser lokale {\sc Tangle}-Prozeß wird weiter unten im
Abschnitt über reportorientiertes Arbeiten beschrieben.
Eventuell ausgegebene Ergebnisse werden in der Datei
[[<<tmp>>]] abgelegt und dann ins Arbeitsfenster geschrieben.
Ein Output, der zu viele Zeichen umfaßt, wird gekürzt, sofern es
länger als die Grenze [[maxol.sys]] ist.

Zur Sicherheit wird bei jeder Evaluation
eine Kopie des Reporttextes in die Datei
[[report-UnDo-bak.rev]] geschrieben! Diese kann mittels [[UnDo]] wieder
ins Arbeitsfenster geschrieben werden.
@
<<definiere Funktion für Knopf: [[WarnEval]]>>=
fWarnEval<-function(){ # vorher EvalCursorChunk
  melde("fWarnEval",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<transformiere in [[worktext]] [[>]] Code-Chunk-Beginn in normale Schreibweise>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  if(0==length(code.start)){cat("Warning: no code found!!!\n");return()}
  code.start<-code.start[code.start<=line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
  }
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
    <<probiere [[code]] in [[revive.env]], Ergebnis: [[try.res]]>>
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
      if(!is.null(try.res)&&0<length(try.res)){
        <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
        sink(<<tmp.sink>>);get("print",pos="package:base")(try.res);sink()
        news<-paste(myscan(<<tmp.sink>>,"",sep="\n"),collapse="\n")
        if(nchar(news)>maxol.sys){
            news<-paste(substring(news,1,maxol.sys),"...",sep="\n")
        }
        news<-paste("", date(), news,"",sep="\n")
        <<schreibe [[news]] ans Ende des Outputfeldes>>
        ##zeige Ergebnisse in neuem Fenster an>>
      }
    } else { cat("sorry, evaluation not successful!!!\n") }
  } else { cat("no code found!!!\n") }
  <<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>
  <<aktualisiere Texthervorhebungen>>
  ##lese Arbeitsfenster auf [[worktext]] ein##
  ##aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]##
  ##generiere ein Ereignis zum Anzeigen von Warnungen##
  ##zeige ggf. Warnungen an#
  melde("fWarnEval",2)
}

@
%% tkevent.generate(TopW,"@<<Acticmds>>")
<<unused: generiere ein Ereignis zum Anzeigen von Warnungen>>=
melde("Warnungs event wird generiert",3)
tkevent.generate(TopW,"@<<Warningevent>>")
@
<<unused: definiere Bindung zur Warnungsabarbeitung>>=
Checkwarnings<-function(){
  melde("Checkwarnings",1)
  Sys.sleep(.11)
  options(warn=1)
  options(warn.expression={cat("WARNING???: Warning-Info see Console window")})
  #try({xxxxxxxxxxxxxxxxxxxxxxxxxxxxx})
  #options(error=NULL)
  OLD.WARNING<-get("LAST.WARNING", envir = revive.sys)
  LAST.WARNING<-"no warnings"
  if(exists("last.warning")) 
    try(LAST.WARNING<-get("last.warning", envir = baseenv()))
  LAST.WARNING<-c(LAST.WARNING,"no warnings")[1]
  if(LAST.WARNING!="no warnings"){
    if(!identical(LAST.WARNING,OLD.WARNING)){
      assign("LAST.WARNING",LAST.WARNING,envir=revive.sys)
      news<-c("last.warning(s):",
                   paste(paste(names(LAST.WARNING),LAST.WARNING,sep=" in: "),collapse="\n"))
      <<schreibe [[news]] ans Ende des Outputfeldes>>
    } # else { print("no new warnings") }
  }
  melde("Checkwarnings",2)
}
tkbind(TopW, "@<<Warningevent>>", Checkwarnings)


@
as.numeric(R.version$major)*100+as.numeric(R.version$minor)
<<unused: zeige ggf. Warnungen an>>=
options(show.error.messages=FALSE)
try({xxxxxxxxxxxxxxxxxxxxxxxxxxxxx})
options(show.error.messages=TRUE)
if(204<=Rversion){
  OLD.WARNING<-get("LAST.WARNING", envir = revive.sys)
  LAST.WARNING<-"no warnings"
  if(exists("last.warning")) 
    try(LAST.WARNING<-get("last.warning", envir = baseenv()))
  LAST.WARNING<-c(LAST.WARNING,"no warnings")[1]
  if(LAST.WARNING!="no warnings"){
    if(!identical(LAST.WARNING,OLD.WARNING)){
      assign("LAST.WARNING",LAST.WARNING,envir=revive.sys)
      news<-c("last.warning(s):",
                   paste(paste(names(LAST.WARNING),LAST.WARNING,sep=" in: "),collapse="\n"))
      <<schreibe [[news]] ans Ende des Outputfeldes>>
    } # else { print("no new warnings") }
  }
}else{
  if(exists("last.warning",envir = .GlobalEnv)){
    lw<-get("last.warning",envir = .GlobalEnv)
    h<-grep("X11",names(lw)); if(length(h)>0) lw<-lw[-grep("X11",names(lw))]
    if(length(lw)>0){
      news<-c("last.warning(s):",
                   paste(paste(names(lw),lw,sep=" in: "),collapse="\n"))
      try(rm(last.warning,envir = .GlobalEnv))
      <<schreibe [[news]] ans Ende des Outputfeldes>>
    }
  }
}
@
<<setze einige Konstanten>>=
LAST.WARNING<-"no warnings"
assign("LAST.WARNING",LAST.WARNING,envir=revive.sys)
Rversion<-as.numeric(R.version$major)*100+as.numeric(R.version$minor)

@
<<OLD: zeige ggf. Warnungen an>>=
options(show.error.messages=FALSE)
try({xxxxxxxxxxxxxxxxxxxxxxxxxxxxx})
options(show.error.messages=TRUE)
if(exists("last.warning",envir = .GlobalEnv)){
  lw<-get("last.warning",envir = .GlobalEnv)
  h<-grep("X11",names(lw)); if(length(h)>0) lw<-lw[-grep("X11",names(lw))]
  if(length(lw)>0){
    news<-c("last.warning(s):",
                   paste(paste(names(lw),lw,sep=" in: "),collapse="\n"))
    try(rm(last.warning,envir = .GlobalEnv))
    <<schreibe [[news]] ans Ende des Outputfeldes>>
  }
}

@
Anhängen oder überschreiben, das ist hier die Frage.
<<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>=
<<hole ggf. [[tworkwin]]>>
worktext<-TcltoWin.write(tclvalue(tkget(tworkwin,"0.0","end")))
get("cat","package:base")(worktext,file="report-UnDo-bak.rev")

@
Die vorsichtige Aktivierung von [[code]] wird auch an anderer Stelle benötigt.
<<probiere [[code]] in [[revive.env]], Ergebnis: [[try.res]]>>=
<<merke [[code]] für Historie>>
try.res <- try(eval(parse(text=code),envir=revive.env))
#options(warn=0)
#options(warn.expression=NULL)

@
<<probiere [[code]] in [[revive.env]] mit warn-break, Ergebnis: [[try.res]]>>=
<<merke [[code]] für Historie>>
code<-c("options(warn=2)",code)
try.res <- try(eval(parse(text=code),envir=revive.env))
options(warn=1)

@
Um den Code von [[fEval...]] nicht zu unübersichtlich werden zu lassen, wurde
ein Block ausgelagert, der zudem auch noch an einer anderen Stelle Verwendung
findet.
Dabei handelt es sich um
die Aufgabe, den Code des letzten Code-Chunk mit Hilfe der Zeilen-Nummern
der Anfänge von Code-Chunks ([[code.start]]) zu ermitteln.
Auf [[code]] steht dann der gesuchte Code.
<<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>=
if((code.start<-max(code.start)+1)>length(worktext)) return()
code.end  <-c(grep("^@",worktext),1+length(worktext))
code.end  <-min(code.end[code.end>code.start])-1
code<-worktext[code.start:code.end]
code<-code[code!=""]
if(length(weg.ab<-grep("^@<<(.*)>>=",code))>0) code<-code[-(weg.ab:length(code))]
if(length(code)==0 || code[1]=="@") code<-" "
melde("code:",3,code,"\n")

@
\subsubsection{Historie einfangen}
<<merke [[code]] für Historie>>=
if(0<length(code)){
  tld <- paste("<","<*>",">=",sep="")
  rh <- c( get("relax.history",envir=revive.sys), list(c("@",tld,code)) )
  assign("relax.history",rh,envir=revive.sys)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[DumpCodeChunk]]}
\paragraph{[[DumpCodeChunk]] zur Speicherung des
aktuellen R-Chunks.}
@
<<definiere Kopf-Zeilen-Funktionen>>=
DumpCodeChunk<-function(){
  melde("DumpCodeChunk",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  if(0==length(code.start)) return()
  code.start<-code.start[code.start<=line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
  }
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
  } else { cat("ERROR: no code found!!!\n"); return() }
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.R}}",
                          title="name of file to save code chunk?", initialdir=getwd(),
                          defaultextension=".R", initialfile="RCode-act.R")
  <<checke [[filename]], quitte ggf.>>
  try.res <- try(cat(code,file=filename,sep="\n"))
}

@
\subsubsection{Arbeitsfenstersteuerung: [[RemoveOut]]}
\paragraph{[[RemoveOut]] zum Löschung unbrauchbarer
Ergebnisse aus dem Outputfenster.}
<<definiere Funktion für Knopf: [[RemoveOut]]>>=
fRemoveOut<-function(){
  melde("fRemoveOut",1)
  worktext<-""
  <<schreibe [[worktext]] ins Outputfenster>>
  melde("fRemoveOut",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[FindText]]}
\paragraph{[[FindTextt]] zur Suche nach Zeichenketten.}
Vgl. [[FindReportText]]! -- Menüeintrag
Die in der Funktion [[fFindText]] verwendete [[Tcl]]-Funktion wird im folgenden
Chunk ebenfalls definiert.
<<definiere Funktion für Knopf: [[FindText]]>>=
fFindText<-function(){
  melde("fFindText",1)
  frage<-"search string?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      such.orig<-such<-string.sys<-tclvalue("tvinfo")
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      <<bearbeite Suchmuster [[such]] für Textsuche>> 
      if(length(found<-grep(such,worktext))>0){
        <<ermittle Cursor-Zeile [[cline]] und Position [[cline.pos]]>>
        <<ermittle Text-Match nach Cursor: [[line]] und [[line.pos]]>>
        tksee(tworkwin,paste(line,".1",sep="")); h<-paste(line,".",line.pos,sep="")
        tkmark.set(tworkwin, "insert", h); tkfocus(tworkwin)

        tktag.configure(tworkwin,"found",background="#000999fff",relief="raised")
        tcl("findmatches",tworkwin,such)
      } else set.tclvalue("tvmess",paste("Warning: search string >",
                                         such.orig,"< not found!!!"))
    } # end of function
  )
  melde("fFindText",2)
}

@
<<ermittle Cursor-Zeile [[cline]] und Position [[cline.pos]]>>=
cline.pos <- as.character(tkindex(tworkwin,"insert"))
cline <- floor(as.numeric(cline.pos))
cline.pos<-as.numeric(sub(".*\\.","",cline.pos))

@
<<old>>=
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      such.orig<-such<-string.sys<-tclvalue("tvinfo")
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      <<bearbeite Suchmuster [[such]] für Textsuche>> 
      if(length(found<-grep(such,worktext))>0){
        line <- floor(as.numeric(tkindex(tworkwin,"insert")))
        line <- if(any(found>line)) found[found>line][1] else found[1]
        tksee(tworkwin,paste(line,".1",sep=""))
        h<-worktext[line]
        ## h<--1+charmatch(such,substring(h,1:nchar(h))); if(is.na(h)) h<-0 # 060605
        h<-which(such.orig==
                 substring(h,1:nchar(h),(1:nchar(h))-1+nchar(such.orig)))-1 # 091023
        if(is.na(h<-h[1])) h<-0
        h<-paste(line,".",h,sep="")
        tkmark.set(tworkwin, "insert", h[1]); tkfocus(tworkwin)

	# tworkwin<-get("tworkwin",envir=revive.sys)
        tktag.configure(tworkwin,"found",background="#000999fff",relief="raised")
        tcl("findmatches",tworkwin,such)
      } else set.tclvalue("tvmess",paste("Warning: search string >",
                                         such.orig,"< not found!!!"))
    } # end of function
  )

@
<<bearbeite Suchmuster [[such]] für Textsuche>>=
repl.pat<-gsub("(.)","\\\\\\1","^!$%&/()=?{}}+*#,.-;:\\_[") ## 070830
repl.pat<-paste("([",repl.pat,"])",collapse="")
such<-gsub(repl.pat,"\\\\\\1",such)
assign("string.sys",string.sys,envir=revive.sys)
if(nchar(such)==0) {
  tcl("findclear",tworkwin); tkfocus(tworkwin); return()
}

@
<<definiere Funktion für Knopf: [[FindText]]>>=
proc<-c(  # 050628
   "proc findmatches {w pattern} {",
   "$w tag remove found    1.0 end",
   "  scan [$w index end] %d numLines",
   "  for {set i 1} {$i < $numLines} {incr i} {",
   "    $w mark set last $i.0",
   "    while {[regexp -indices $pattern \\",
   "       [$w get last \"last lineend\"] indices]} {",
   "     $w mark set first \"last + [lindex $indices 0] chars\"",
   "     $w mark set last \"last  + 1 chars\\",
   "                              + [lindex $indices 1] chars\"",
   "     uplevel [$w tag add found first last]",
   "     }",
   "  }",
   "}",
    "proc findclear w {",
      "$w tag remove found    1.0 end",
    "}"
  )
.Tcl(paste(proc,collapse="\n"))



@
\subsubsection{Arbeitsfenstersteuerung: [[EvalRCode]]}
\paragraph{[[EvalRCode]] zum Evaluieren, jedoch bricht bei 
einer Warnung die Evaluierung ab.}
<<definiere Funktion für Knopf: [[EvalRCode]]>>=
fEvalRCode<-function(){
  melde("fEvalRCode",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<transformiere in [[worktext]] [[>]] Code-Chunk-Beginn in normale Schreibweise>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  if(0==length(code.start)){cat("Warning: no code found!!!\n");return()}
  code.start<-code.start[code.start<=line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
  }
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
    <<probiere [[code]] in [[revive.env]] mit warn-break, Ergebnis: [[try.res]]>>
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
      if(!is.null(try.res)&&0<length(try.res)){
        <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
        sink(<<tmp.sink>>);get("print",pos="package:base")(try.res);sink()
        news<-paste(myscan(<<tmp.sink>>,"",sep="\n"),collapse="\n")
        if(nchar(news)>maxol.sys){
            news<-paste(substring(news,1,maxol.sys),"...",sep="\n")
        }
        news<-paste("", date(), news,"",sep="\n")
        <<schreibe [[news]] ans Ende des Outputfeldes>>
        ##zeige Ergebnisse in neuem Fenster an>>
      }
    } else { cat("sorry, evaluation not successful!!!\n") }
  } else { cat("no code found!!!\n") }
  <<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>
  <<aktualisiere Texthervorhebungen>>
  melde("fEvalRCode",2)
}
@
Für eine vereinfache Schreibweise soll auch ein Code-Chunk-Beginn per [[>]] Zeichen 
zugelassen sein. # 091029
Markierung in rot im tcl-Script eingebaut, 
todo: SaveAsTextFile, SaveAsPlainTeXFile -> SaveAsConsoleStyleFile (ok) 
todo: Formatierung mit weaveR, Index-Listen weaveR sowie Schmalspur-R-Code-Ausgabe -> Console-Stil wird angepasst (ok?)
<<transformiere in [[worktext]] [[>]] Code-Chunk-Beginn in normale Schreibweise>>=
if(any(h<-(substring(worktext,1,1)==">"))){ # 091026
  worktext[h]<-sub("^.","@SpLiTtE?@<<*@>>=SpLiTtE?",worktext[h])
  worktext<-substring(unlist(strsplit(paste("",worktext),"SpLiTtE")),2)
  if(is.vector(line)) line<-line+2*sum(which(h)<=line)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[Insert]]}
\paragraph{[[Insert]] zur Übertragung des Inhalts aus dem
Output- ins Arbeitsfenster.}
Falls der Output mit xtable erstellt wurde, werden
output-start und output-end auskommentiert. 080310
<<definiere Funktion für Knopf: [[Insert]]>>=
fInsert<-function(){
  melde("fInsert",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  news<-tclvalue(tkget(toutwin,"0.0","end"))
  if(1<nchar(news)){
    if(length(grep("egin[{]table[}]",news))>0 &&
       length(grep("generated.*xtable.*package",news))>0){
        news<-sub("(\n%.*begin[{]table[}])","\noutput-end\n\\1",news)       
        news<-sub("(.end[{]table[}])","\\1\noutput-start",news)       
        news<-paste("\n@",paste("output-start",news,sep=""),"output-end\n", sep="\n")
        news<-sub("output-start\n+output-end","",news)
    }else{    
      news<-paste("\n@","output-start",news,"output-end\n",sep="\n")
    }
    news<-gsub("\n+","\n",news)
    <<schreibe [[news]] hinter aktuellen Chunk>>
    worktext<-""
    <<schreibe [[worktext]] ins Outputfenster>>
  }
  melde("fInsert",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[CopyToEnd]]}
\paragraph{[[CopyToEnd]] zur Übertragung des Inhalts aus dem
Output- ans Ende des Arbeitsfensters.}
<<definiere Kopf-Zeilen-Funktionen>>=
CopyToEnd<-function(){
  melde("CopyToEnd",1)
  news<-tclvalue(tkget(toutwin,"0.0","end"))
  if(1<nchar(news)){
    news<-paste("\n@","output-start",news,"output-end\n",sep="\n")
    news<-gsub("\n+","\n",news)
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
    worktext<-""
    <<schreibe [[worktext]] ins Outputfenster>>
  }
  melde("CopyToEnd",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
# tkconfigure(Help.R,command=fHelp.R)
if( ! <<OS ist Mac-Mini>> ) tkbind(TopW, "@<<Help.R>>", fHelp.R) #120111
# tkconfigure(Up,command=fUp)
tkbind(TopW, "@<<Up>>", fUp)
# tkconfigure(Down,command=fDown)
if( ! <<OS ist Mac-Mini>> ) tkbind(TopW, "@<<Down>>", fDown) #120111

# tkconfigure(PlanRCode,command=fPlanRCode)
tkbind(TopW, "@<<PlanRCode>>", fPlanRCode)
# tkconfigure(EvalRCode,command=fEvalRCode) ## 071115
tkbind(TopW, "@<<EvalRCode>>", fEvalRCode)
# tkconfigure(WarnEval,command=fWarnEval)
tkbind(TopW, "@<<WarnEval>>", fWarnEval)
# tkconfigure(TrashROutput,command=fTrashROutput)
tkbind(TopW, "@<<TrashROutput>>", fTrashROutput)

# tkconfigure(Insert,command=fInsert)
tkbind(TopW, "@<<Insert>>", fInsert)
# tkconfigure(SavePlot,command=fSavePlot)
tkbind(TopW, "@<<SavePlot>>", fSavePlot)
# tkconfigure(FindText,command=fFindText)
tkbind(TopW, "@<<FindText>>", fFindText)
# tkconfigure(RemoveOut,command=fRemoveOut) ## 071115
tkbind(TopW, "@<<RemoveOut>>", fRemoveOut)

#tkconfigure(CopyToEnd,command=CopyToEnd)
#tkbind(TopW, "@<<CopyToEnd>>", CopyToEnd)

@
\subsubsection{Arbeitsfenster:  Bereitstellung besonderer Zeichen}
Einige besondere Zeichen müssen in einem Text-Widget erst erzeugt werden.
Genauer handelt es sich um die Zeichen: [[\,[,],{,},~,@]].
Für sie werden geeignete Bindungen definiert.
Da dieses Eingabeverhalten auch an anderer Stelle verlangt ist,
wird ein allgemeiner Chunk die Zeichenerzeugung beschreiben.
Erforderlich ist jedoch,
daß das betreffende Widget über den Namen [[twin]] ansprechbar ist.

Ein in einem Textfenster eingegebener Umlaut führt beim Auslesen
auf eine R-Char-Variable zwei Zeichen zum Vorschein. Damit 
bei der Speicherung ein Windows-Umlaut in der Datei ankommt, muss
eine Ersetzung erfolgen. 
Der Datei-Code für die Umlaute unter Latin1 ist für
[[äöüÄÖÜß]] gegeben durch [["\344\366\374\304\326\334\337"]]. 
Für die Erzeugung eines Rückstriches muss beachtet werden,
dass der Rückstrich auf derselben Taste wie [[ß]] liegt.
<<stelle besondere Zeichen in [[twin]] zur Verfügung>>=
f.sonderzeichen<-function(zeichen){
  function(){
    tkinsert(twin,"insert",zeichen)
    if(<<das OS ist Windows>>)tkdelete(twin,"insert-1chars")
    if(<<OS ist Mac-Mini>>)tkdelete(twin,"insert-1chars")
  }
}
f.umlaut<-function(zeichen){
  function(){
    return()
    #char337<-eval(parse(text='"\\337"'))
    #if(zeichen==char337 & tclvalue(tkget(twin,"insert-1chars","insert"))=="\\") return()
    #tkinsert(twin,"insert",zeichen); tkdelete(twin,"insert-2chars")
  }
}
tkbind(twin,"@<<LKeckig>>", f.sonderzeichen("["))
tkbind(twin,"@<<RKeckig>>", f.sonderzeichen("]"))
tkbind(twin,"@<<Tilde>>",   f.sonderzeichen("~"))
tkbind(twin,"@<<LKgeschw>>",f.sonderzeichen("{"))
tkbind(twin,"@<<RKgeschw>>",f.sonderzeichen("}"))
tkbind(twin,"@<<Klammera>>",f.sonderzeichen("@"))
tkbind(twin,"@<<Pipe>>",    f.sonderzeichen("|"))
tkbind(twin,"@<<Backsl>>",  f.sonderzeichen("\\"))
renewhighlighting<-function(){
  tworkwin<-get("tworkwin",envir=revive.sys)
  <<aktualisiere Texthervorhebungen>>
}
# tkbind(twin,"@<<Klammeraffe>>",renewhighlighting)
tkbind(twin,"<Return>",renewhighlighting)

@
\subsubsection{Arbeitsfenster: [[Strg Pagedown]] zur Kopie alter Code-Chunk}
Zur Wiederholung von Anweisungen ist es sehr unschön, diese immer wieder
eintippen zu müssen. Deshalb soll es möglich sein, solche durch die Tastenkombination
[[Strg Pagedown]] ans Ende des Arbeitsfeldes zu kopieren.
Mehrfachklicks, die zunächst als Lösung dienen sollten, besaßen zu viele
Nachteile.
<<unused: definiere Wirkung von [[Strg Pagedown]] im Reportfenster / ab 1.02 abgeschaltet>>=
tkbind(tworkwin,"@<<ActChunk>>", function() {
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-code.start[code.start<line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
    news<-paste("\n@\n@<<*>>=\n",paste(code,collapse="\n"),"\n",sep="")
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
  }
   tkmark.set(tworkwin, "insert", "end")
   tksee(tworkwin,"end")
})

@
\subsubsection{Hervorhebung zugehöriger Klammern}
4.7.2006 
<<definiere Klammernmatchanzeige im Reportfenster>>=
proc<-c(  # 060704
   "proc showbracket {w orta ortb} {",
   "$w tag remove secondbracket    1.0 end",
   "  scan [$w index end] %d numLines",
   "     $w mark set first \"$orta\"",
   "     $w mark set last \"$orta  + 1 chars\"",
   "     uplevel [$w tag add secondbracket first last]",
   "     $w mark set first \"$ortb\"",
   "     $w mark set last \"$ortb  + 1 chars\"",
   "     uplevel [$w tag add secondbracket first last]",
   "}",
    "proc showbracketsclear w {",
      "$w tag remove secondbracket    1.0 end",
    "}"
  )
.Tcl(paste(proc,collapse="\n"))
tktag.configure(tworkwin,"secondbracket",background="#000dddfff",relief="raised")
MarkSecondBracket<-function(){
  tworkwin<-get("tworkwin",envir=revive.sys)
  left.of.cursor<-tclvalue(tkget(tworkwin,"insert - 1 chars"))
  open<-0
  if(left.of.cursor %in% c("{","[","(")){ ## print("Klammer auf")
    open<-1
    a<-tclvalue(tkget(tworkwin,"insert - 1 chars","end"))
    n<-min(nchar(a),1500); aa<-substring(a,1,n); aaa<-substring(aa,1:n,1:n)
    auf<-aaa %in% c("{","[","("); zu<-aaa %in% c("}","]",")")
    count<-cumsum(auf)-cumsum(zu)
    second<-which(count==0)[1]-2
    first<-paste(tclvalue(tkindex(tworkwin,"insert")),"- 1 chars")
    if(!is.na(second)){
      tcl("showbracket",tworkwin,first,paste("insert +",second,"chars"))
    }
  }
  if(left.of.cursor %in% c("}","]",")")){ ## print("Klammer zu"); 
    open<- -1
    a<-tclvalue(tkget(tworkwin,"0.0","insert"))
    n<-nchar(a); aa<-substring(a,max(1,n-1500),n)
    aaa<-substring(aa,nchar(aa):1,nchar(aa):1) 
    auf<-aaa %in% c("{","[","("); zu<-aaa %in% c("}","]",")")
    count<-cumsum(zu)-cumsum(auf)
    second<-which(count==0)[1]
    first<-paste(tclvalue(tkindex(tworkwin,"insert")),"- 1 chars")
    if(!is.na(second)){
      tcl("showbracket",tworkwin,first,paste("insert -",second,"chars"))
    }
  }
  ## if(exists("second")) print(second)  ##; print(open)
  if(open==0) tcl("showbracketsclear",tworkwin)
  ### Zeilennummeraktualisieren: 
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  tkconfigure(llineno.sys,text=paste(line))

}
tkbind(tworkwin,"<KeyRelease>",MarkSecondBracket)
### Zeilennummeraktualisieren falls Mouse-Op: 
tkbind(tworkwin,"<ButtonRelease>",function(){
    tworkwin<-get("tworkwin",revive.sys)
    <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
    tkconfigure(llineno.sys,text=paste(line))
  }
)

@
Testweiser Versuch Zeilennummer anzuzeigen.
<<xxxdefiniere Logik zum Eintrag der Zeilennummer>>=
tkbind(tworkwin,"<KeyPress><KeyRelease>",function(){
    tworkwin<-get("tworkwin",revive.sys)
    <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
    tkconfigure(llineno.sys,text=paste(line))
  }
)
tkbind(tworkwin,"<ButtonRelease>",function(){
    tworkwin<-get("tworkwin",revive.sys)
    <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
    tkconfigure(llineno.sys,text=paste(line))
  }
)



@
\subsubsection{Automatische Komplettierung von Objektnamen}
% 090629???
091210 ::  Tab ist ok, falls kein Namensteil gefunden wird
<<definiere Wirkung von [[Tab]] im Reportfenster>>=
 tkbind(tworkwin,"<Tab><KeyRelease>", function() {
  #  tworkwin<-get("tworkwin",envir=revive.sys)
 ## check, ob Leerzeichen oder nicht vorm Cursor steht
  if(1==length(grep("[a-zA-Z._\\(]", #)
                    tclvalue(tkget(tworkwin,"insert - 2 char")))))
     try(tkdelete(tworkwin,"insert - 1 char")) else return()
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  line<-line.orig<-(tclvalue(tkindex(tworkwin,"insert")))
  pos<-as.numeric(sub("(.*)\\.","",line)); line<-as.numeric(line) 
  w<-worktext[floor(line)]
  anfang<-paste(rev(substring(w,1:pos,1:pos)),collapse="") # aktuelle Zeile 
  anfang<-sub("(^[\\(]{0,1}[a-zA-Z0-9._]*)(.*)","\\1",anfang) # aktuelles Wort
  h<-nchar(anfang); klammer<-"("==substring(anfang,1,1)
  if(klammer && h<2) return()
  anfang<-if(klammer) paste(rev(substring(anfang,2:h,2:h)),collapse="") else
                      paste(rev(substring(anfang,1:h,1:h)),collapse="")
  suchstring<-paste("^",anfang,sep="")

  objekt<-grep(suchstring,ls(envir=revive.env),ignore.case=FALSE,value=TRUE)
  objekt<-c(objekt,apropos(suchstring,ignore.case=FALSE))
  if(length(objekt)==0) return();  if(length(objekt)>40) return()

  if(1==length(objekt)||klammer) { 
    if(klammer) objekt<-substring(suchstring,2) # ohne ^
    objtail<-sub(suchstring,"",objekt)
    objtail<-substring(objekt,nchar(suchstring)) # because of "^", 1+(nchar(.)-1)
    if(0==length(find(objekt))) h<-get(objekt,envir=revive.env) else h<-get(objekt)
    # cat("h"); print(h); cat("objtail"); print(objtail) # der angefuegt werden muss
    if(is.function(h)){
      h<-paste(deparse(args(h)),collapse=" ")[1]
      h<-sub("^function[^\\(]*\\(","(",h);h<-sub(" *NULL$","",h)
      news<-paste("\n\nsyntax of function ",objekt,":\n",h,sep="")
      <<schreibe [[news]] ans Ende des Outputfeldes>>
    }
    try(tkinsert(tworkwin,line.orig,objtail));    return()
  }
  ooo<-sapply(objekt,function(x) substring(x,1:20,1:20))
  n.equal<-which.min(apply(ooo[,1]==ooo,1,all))-1
  if(n.equal>nchar(anfang)){
    objekt<-paste(ooo[1:n.equal,1],collapse="")
    objtail<-sub(suchstring,"",objekt)
    try(tkinsert(tworkwin,line.orig,objtail));    return()
  } else { print(objekt); return() }
 })
 if( name.complete.sys!=TRUE ) {
   tkbind(tworkwin,"<Tab><KeyRelease>", function() { "relax" } ) 
 }

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reportorientiertes Arbeiten --- Implementation}

@
\subsection{Implementation der Oberflächenelemente}

Für ein reportorientiertes Arbeiten muß das Angebot im Menü [[File]] des
Kopf-Frames erweitert werden.

\subsubsection{[[File]]: Ergänzung neuer Menüeinträge}
Die Stelle der Arbeit kann über [[SetWorkPath]] gesetzt werden.
Durch Laden von Reports [[OpenReport]] oder Speicherung [[SaveReport]]
wird ebenfalls ein Verzeichniswechsel durchgeführt.

<<definiere Kopf-Frame>>=
tkadd(mbFile.menu,"command", command=SetWorkPath,
      label="SetWorkPath:   change working path")
tkadd(mbFile.menu, "separator")
tkadd(mbFile.menu,"command", command=OpenReport,
      label="OpenReport:   >>APPEND<< file to text field")
if(but.Wizardry!="simple") 
  tkadd(mbFile.menu,"command", command=SaveReport,
        label="SaveReport:   save text field to rev file")
if(but.Wizardry!="simple") 
  tkadd(mbFile.menu, "separator")
tkadd(mbFile.menu,"command", command=SaveHtml,
      label="SaveHtml:   save text field to a rev file and a HTML file")

@
\subsubsection{[[View]]: Anzeigen von Reports}
Für die Ansicht ist ein Browser notwendig, z.B.\ [[mozilla]].
Der Browser kann gesetzt werden über:
[[options(browser="/opt/kde3/bin/konqueror")]]
<<definiere Kopf-Frame>>=
tkadd(mbFile.menu,"command", command=ViewReport.html,
      label="ViewReport.html:   view html representation of report")
if(but.Wizardry!="simple") {
  tkadd(mbFile.menu,"separator")
  tkadd(mbFile.menu,"command", command=OpenTextFile,
        label="OpenTextFile:  open not-rev-file, translate console style and >>APPEND<< it to text field")
  tkadd(mbFile.menu,"command", command=SaveAsConsoleStyleFile,
        label="SaveAsConsoleStyleFile:   dump report as txt-, tex-file in console style, and as a rev- , R-file")
#tkadd(mbFile.menu,"command", command=SaveAsPlainTeXFile,
#      label="SaveAsPlainTeXFile:   dump report as TeX-file in console style, as a rev-file and as an 
#      R-file")
}
tkadd(mbFile.menu,"separator")
tkadd(mbFile.menu, "command", command=PLAYGROUND,
      label="playground:   open R-window for testing R-code")
tkadd(mbFile.menu,"command", command=ShowHistory,
      label="ShowHistory:   show history of evaluation in a separate window")
tkadd(mbFile.menu,"command", command=SaveHistory,
      label="SaveHistory:   save history of evaluation")
if(but.Wizardry!="simple") {
  tkadd(mbFile.menu,"command", command=StartCodeChunkPlayer,
      label="StartCodeChunkPlayer:     call code chunk player (without saving report field)")
  tkadd(mbFile.menu,"command", command=ConstructDemoFunction,
      label="ConstructDemoFunction:   save, construct demo showing code chunks")
  tkadd(mbFile.menu, "separator")

  tkadd(mbFile.menu,"command", command=LoadEnvironment,
        label="LoadEnvironment:   load objects from dump file into relax environment")
  tkadd(mbFile.menu,"command", command=DumpEnvironment,
        label="DumpEnvironment:   save objects of relax environment as dump file")
  tkadd(mbFile.menu,"command", command=SaveEnvironment,
        label="SaveEnvironment:   save objects of relax environment in binary file")
  tkadd(mbFile.menu,"command", command=CleanEnvironment,
        label="CleanEnvironment:   delete objects of environment")
}
tkadd(mbFile.menu,"separator")

@
<<definiere Kopf-Frame>>=
if(but.Wizardry=="all"){
  tkadd(mbFile.menu,"command", command=OpenRevbook,
      label="OpenCompbook:   load compbook from library relax/rev")
  tkadd(mbFile.menu, "separator")
}
<<definiere Datei-Menü-Eintrag zur Programmbeendigung>>


@
\subsubsection{[[Edit]]: Ergänzung neuer Menüeinträge}
[[EditReport]] startet einen externen Editor.
[[SaveDiffReport]] speichert Differenz.
[[RunAll]] wiederholt alle bisherigen Start- und Stern-Chunks.
[[DeleteAll]] löscht das Reportfenster.
[[UnDo]] stellt den Zustand im
Reportfenster her, wie er vor der letzten Code-Aktivierung war.
[[EvalCursorChunk]] aktiviert Chunk, auf den der Cursor zeigt.
<<definiere Kopf-Frame>>=
tkadd(mbEdit.menu, "separator")
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "command", command=EditReport,
        label=paste("EditReport:   use editor",editor.sys,"for editing"))
}
tkadd(mbEdit.menu, "command", command=DumpCodeChunk,
      label=paste("DumpCodeChunk:   save code chunk in a file"))
if(but.Wizardry!="simple") {
  tkadd(mbEdit.menu, "command", command=CopyToEnd,
        label=paste("CopyToEnd:   copy output to end of text"))
  tkadd(mbEdit.menu, "separator")
  tkadd(mbEdit.menu, "command", command=RunAll,
        label="RunAll:   run all start- and *-code chunks")
  tkadd(mbEdit.menu, "command", command=RunStart,
        label="RunStart:   run all start-code chunks")
  tkadd(mbEdit.menu, "separator")
  tkadd(mbEdit.menu, "command", command=RemoveSavedPlot,
        label="RemoveSavedPlot:   remove saved plots defined by cursor and plot links from REPORT FIELD")
  tkadd(mbEdit.menu, "command", command=RemoveALLPLOTS,
        label="RemoveALLPLOTS:   remove ALL saved plots of the report from file system and report")
  tkadd(mbEdit.menu, "command", command=DeleteAll,
        label="DeleteAll:   clear text field")
  tkadd(mbEdit.menu, "separator")
}
tkadd(mbEdit.menu, "command", command=UnDo,
      label="UnDo:   load report-UnDo-bak.rev (report before last evaluation)")

@
<<unused>>=
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=SaveDiffReport,
      label="SaveDiffReport:   save difference between actual and old file")

@
\subsubsection{[[WarnEval]]: lokaler {\sc Tangle}-Prozeß}
Für den angesprochenen lokalen {\sc Tangle}-Prozeß bedarf es keiner
Oberflächenelemente, siehe Abschnitt zur Implementation.

@
\subsection{Implementation der Funktionalitäten}

Es werden folgende Funktionen entworfen:\\
{ \small
[[SetWorkPath]],
% [[ListReportFiles]] (im Moment ohne Verwendung),
[[SaveReport]],
[[SaveHtml]],
[[OpenReport]],
% [[SaveAsHtml]],
[[EditReport]],
[[SaveDiffReport]],\\
[[RunAll]],
[[RunStart]],
[[DeleteAll]] und
[[UnDo]]
} % end of small
Außerdem ist der lokale {\sc Tangle}-Prozeß zu beschreiben.

@
\subsubsection{Kopfzeile: [[File]] --- [[SetWorkPath]]}
\paragraph{[[SetWorkPath]] zur Ort für Reports.}
Die Funktion legt den Ort der Arbeit fest.
Der aktuelle Ort läßt sich mit Hilfe
von [[getwd]] ermitteln und mit [[setwd]] setzen.
Der Anwender muß nur nach dem neuen Ort gefragt werden.
Der neue Ort wird nicht als Systemvariable gespeichert.
Falls er nicht existiert, wird eine Fehlermeldung ausgegeben.
<<definiere Kopf-Zeilen-Funktionen>>=
SetWorkPath<-function(){
  melde("SetWorkPath",1)
  path<-tkchooseDirectory(title="Reportverzeichniswahl",initialdir=getwd())
  if(!is.character(path)) path<-tclvalue(path)
  if(path=="") return() else try.res <- try(setwd(path))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    cat("new directory:",getwd(),"\n")
  }else{
    cat("ERROR: change of directory failed!!!\n")
  }
  melde("SetWorkPath",2)
}

@
Unter Windows95 führt der Aufruf von [[tk_chooseDirectory]]
zum Absturz. Der Verzeichniswechsel muß in einem solchen Fall
direkt über [[setwd()]] ausgeführt werden.

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveEnvironment]], [[DumpEnvironment]],
[[LoadEnvironment]]}
\paragraph{[[SaveEnvironment]] zur Abspeicherung der Objekte der Umgebung.}
Die dritte Funktion lädt die Objekte wieder in die Umgebung.
<<definiere Kopf-Zeilen-Funktionen>>=
DumpEnvironment<-function(){
  melde("DumpEnvironment",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.relax-env}}",
                          title="name of ENVIRONMENT DUMP file?", initialdir=getwd(),
                          defaultextension=".relax-env", 
                          initialfile=sub("rev$","relax-env",workname.sys))
  <<checke [[filename]], quitte ggf.>>
  noenv<-TRUE # ignore environments 
  <<ermittle und zeige Objektliste [[objlist]] von revive.env>>
  assign("list.of.env.obj",objlist,envir=revive.env)
  try.res<-try(eval(parse(text=
                  paste(sep="","dump(list.of.env.obj,file=\"",filename,"\")")),envir=revive.env))
  try(eval(parse(text="remove(\"list.of.env.obj\")"),envir=revive.env))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    cat(paste("Objects of environment saved in file:",filename,"!\n"))
  } else {
    cat("ERROR: saving of environment objects failed!!!\n")
  }
  melde("DumpEnvironment",2)
}
SaveEnvironment<-function(){
  melde("SaveEnvironment",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.bin-relax-env}}",
                          title="name of BINARY SAVE file?", initialdir=getwd(),
                          defaultextension=".bin-relax-env", 
                          initialfile=sub("rev$","bin-relax-env",workname.sys))
  <<checke [[filename]], quitte ggf.>>
  noenv<-FALSE # do not ignore environments 
  <<ermittle und zeige Objektliste [[objlist]] von revive.env>>
  assign("list.of.env.obj",objlist,envir=revive.env)
  try.res<-try(eval(parse(text=
                  paste(sep="","save(list=list.of.env.obj,file=\"",filename,"\")")),envir=revive.env))
  try(eval(parse(text="remove(\"list.of.env.obj\")"),envir=revive.env))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    cat(paste("Objects of environment saved in file:",filename,"!\n"))
  } else {
    cat("ERROR: saving of environment objects failed!!!\n")
  }
  melde("SaveEnvironment",2)
}
LoadEnvironment<-function(){
  melde("LoadEnvironment",1)
  initialfile<-sub("rev$","bin-relax-env",workname.sys)
  if(!file.exists(initialfile)) initialfile<-sub("rev$","relax-env",workname.sys)
  filename<-tkgetOpenFile(filetypes="{{Paper Files} {.relax-env .bin-relax-env}}",
                          title="Select *relax-env file to be loaded!",
                          defaultextension=".relax-env",
                          initialfile=initialfile,
                          initialdir=getwd())
  <<checke [[filename]], quitte ggf.>>
  if(0<length(grep("bin-relax-env$",filename))){
    try.res<-try(load(filename,envir=revive.env))
  } else {
    obj<-scan(filename,""); ind<-grep("<-",obj)-1   
    obj[ind]<-paste(";",obj[ind]); obj<-sub("^;","",paste(obj,collapse=""))
    try.res<-try(eval(parse(text=obj),envir=revive.env))
  }
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    cat(paste("Objects of file:",filename,"\nloaded into environment!\n"))
    noenv<-FALSE # do not ignore environments 
    <<ermittle und zeige Objektliste [[objlist]] von revive.env>>
  } else {
    cat("ERROR: saving of environment objects failed!!!\n")
  }
  melde("LoadEnvironment",2)
}
CleanEnvironment<-function(){
  melde("CleanEnvironment",1)
  noenv<-FALSE # do not ignore environments 
  <<ermittle und zeige Objektliste [[objlist]] von revive.env>>
  res<-tkmessageBox(message=
      if(language=="german") 
        "Sollen die Objekte der Umgebung wirklich entfernt werden"
      else 
        "Do you want to delete all the objects of the environment?",
      title="Clean Environment?",icon="warning",type="yesnocancel",default="no")
  res<-tclvalue(res)
  if(res=="yes"){    
    objlist<-c(objlist,"objlist"); assign("objlist",objlist,envir=revive.env)
    try.res<-try(eval(parse(text="remove(list=objlist)"),envir=revive.env))
    cat("Objects of environment have been deleted!\n")
    # print(try.res)
  }
  melde("CleanEnvironment",2)
}

@
<<ermittle und zeige Objektliste [[objlist]] von revive.env>>=
objlist<-ls(envir=revive.env) 
if(noenv) objlist<-objlist[sapply(objlist,function(x)!is.environment(get(x,envir=revive.env)))]
objlist<-objlist[substring(objlist,1,6)!="revive"]
if(length(objlist)==0){
  cat("WARNING: no objects found for saving!!!\n")
  return()
}
cat("list of objects:\n"); print(objlist); Sys.sleep(.5)
  

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveReport]]}
\paragraph{[[SaveReport]] zur Abspeicherung eines Reports.}
Die Speicherung von Reports erfordert Schreib-Operationen,
die eventuell mißlingen. Deshalb werden diese innerhalb von [[try]]
ausgeführt. Ein solches Probieren wird auch an anderen
Stellen vorkommen. Deshalb wird ein Chunk zur Wiederverwendung eingerichtet,
der das Ergebnis auf einen möglichen Fehler hin untersucht.
<<definiere Kopf-Zeilen-Funktionen>>=
SaveReport<-function(){
  melde("SaveReport",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.rev}}",
                          title="name of report file?", initialdir=getwd(),
                          defaultextension=".rev", initialfile=workname.sys)
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  if(ok){
    <<aktualisiere Reportname>>
    <<kopiere ggf.\ Bilder ins neue Verzeichnis>>
    <<wechsele ins neue Verzeichnis>>
    melde(paste("report file",filename,"saved\n"),0)
    melde(paste("w",workname.sys),"cmd.msg")
  } else {
    cat("ERROR: write operation failed!!!\n")
  }
  melde("SaveReport",2)
  return("ok")
}
SaveHtml<-function(){
  melde("SaveHtml",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.rev}}",
                          title="name of report file?", initialdir=getwd(),
                          defaultextension=".rev", initialfile=workname.sys)
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  if(ok){
    <<aktualisiere Reportname>>
    <<kopiere ggf.\ Bilder ins neue Verzeichnis>>
    <<wechsele ins neue Verzeichnis>>
    melde(paste("report file",filename,"saved\n"),0)
    melde(paste("w",workname.sys),"cmd.msg")
  } else {
    cat("ERROR: write operation failed!!!\n")
  }
  <<speichere Report als Html-File>>
  melde("SaveHtml",2)
  return("ok")
}
@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<SaveReport>>", SaveReport)

@
SaveAsConsoleStyleFile: 
<<definiere Kopf-Zeilen-Funktionen>>=
SaveAsConsoleStyleFile<-function(){
  melde("SaveAsConsoleStyleFile",1)
  filename<-tkgetSaveFile(filetypes="{{TEXT-FILE!} {*.*}}",
                          title="name of file?", initialdir=getwd(),
                          defaultextension="", initialfile=sub(".rev$",".rev",workname.sys))
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<transformiere in [[worktext]] [[>]] Code-Chunk-Beginn in normale Schreibweise>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  filename<-sub("\\.rev$",".txt",filename)	
  <<speichere [[worktext]] als Textfile ab, Indikator: [[ok]]>>
  if(ok){
    filename<-sub("\\.tex$","",filename)
    filename<-sub("\\.txt$","",filename)
    filename<-sub("\\.rev$","",filename)
    filename<-sub("\\.R$","",filename)
    filename<-paste(filename,".rev",sep="")
    <<aktualisiere Reportname>>
    <<kopiere ggf.\ Bilder ins neue Verzeichnis>>
    <<wechsele ins neue Verzeichnis>>
  } else {
    cat("ERROR: write operation failed!!!\n")
  }
  melde("SaveAsConsoleStyleFile",2)
  return("ok")
}

@
Erste Zeile wird mit einem [[> ]] versehen, die Folgecodezeilen
erhalten [[+ ]].
output-start, output-end umsetzen: 090717
<<speichere [[worktext]] als Textfile ab, Indikator: [[ok]]>>=
worktext<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext)
#worktext<-sub("^output-start","\\\\begin{verbatim}",worktext)
#worktext<-sub("^output-end","\\\\end{verbatim}",worktext)
worktext<-sub("^output-start","",worktext)
worktext<-sub("^output-end","",worktext)
#if(0==length(grep("\\\\end\\{document\\}",worktext))) #2.1.0
#  worktext<-c(worktext,"@\n\\end{document}")
## remove noweb items
code.ch<-c("@",worktext,"@")
# translation of code chunks in noweb style
code.chunk.start<-paste("^<","<.*>",">=",sep="")
code.a<- grep(code.chunk.start,code.ch)
if(0<length(code.a)){
  code.z<-grep("^@",code.ch)
  code.z<-unlist(sapply(code.a ,function(x,y)min(y[y>x]),code.z))
  code.n<-length(code.ch)
  change<-rep(0,code.n); change[c(code.a ,code.z)]<-1
  ind<-(1==(cumsum(change)%%2))[-length(change)]
  def.lines<-diff(c(FALSE,ind))>0
  code.ch<-code.ch[!def.lines]; ind<-ind[!def.lines]
  code.ch<-sub(paste("^ *<","<",sep=""),"# <<",code.ch) # Auskommentierung von uses
  code.ch[ind]<-paste("+",code.ch[ind])
  code.ch[ind]<-sub("^[+][ \t]*$"," ",code.ch[ind])
  ind<-diff(c(FALSE,ind))>0
  code.ch[ind]<-paste(">",substring(code.ch[ind],3))
#  code.ch[ind]<-paste("+",code.ch[ind])
#  ind<-diff(c(FALSE,ind))>0
#  code.ch[ind]<-sub("^[+] ","> ",code.ch[ind])
} else { "no code" }
worktext<-code.ch
# translation of code chunks in console style
code.a<-grep("^>",code.ch)
if(0<length(code.a)){
  code.z<-grep("^@",code.ch)
  code.z<-unlist(sapply(code.a ,function(x,y)min(y[y>x]),code.z))
  code.n<-length(code.ch)
  change<-rep(0,code.n); change[c(code.a ,code.z)]<-1
  ind<-(1==(cumsum(change)%%2))[-length(change)]
  def.lines<-diff(c(FALSE,ind))>0
  ###  code.ch<-code.ch[!def.lines]; ind<-ind[!def.lines]
  code.ch<-sub(paste("^ *<","<",sep=""),"# <<",code.ch) # Auskommentierung von uses
  code.ch[ind]<-ifelse(!(substring(code.ch[ind],1,1)%in%c(">","+")),paste("+",code.ch[ind]),code.ch[ind])
  code.ch[ind]<-sub("^[+][ \t]*$"," ",code.ch[ind])
  ind<-diff(c(FALSE,ind))>0
  ### code.ch[ind]<-paste(">",substring(code.ch[ind],3))
} else { "no code" }
worktext<-code.ch
worktext<-worktext[-grep("^@",worktext)]
worktext<-TcltoWin.write(worktext)
try.res <- try(cat(worktext,file=filename,sep="\n")) ### .txt written
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
if(ok){ cat(paste("file",filename,"saved\n")) }

# schreibe  script.R-file
a<-worktext; ind<-grep("^[+>]",a)
if(0!=length(ind)){
  a<-a[ind]; ind<-grep("^[>]",a); no<-seq(ind)
  a[ind]<-paste("#",no,": >\n ",substring(a[ind],2),sep="")
  ind<-grep("^[+]",a)
  if(0!=length(ind)) a[ind]<-paste("", substring(a[ind],2))
  filename<-sub(".txt$",".R",filename)
  try.res <- try(cat(a,file=filename,sep="\n")) ### .R
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){ cat(paste("file",filename,"saved\n")) }
}

# schreibe  tex-file
# verbatim-Separationszeichen festlegen: SEP
filename<-sub("\\.R$",".tex",filename); filename<-sub("\\.txt$",".tex",filename) 

<<stelle lokales Coding fest: [[is.UTF]]>>

SEP<- if(!is.UTF){ eval(parse(text='"\\267"')) }else{ trennzeichen<-"\140" }
ind<-grep("^[>+]",worktext)
worktext[ind]<-paste("\\rule{0mm}{0mm}\\\\\\verb",SEP,worktext[ind],SEP,sep="")
worktext[!ind]<-gsub("\\[\\[(.*)\\$(.*)\\]\\]",paste("[[\\1\\\\","$\\2]]",sep=""),worktext[!ind])
try.res <- try(cat(worktext,file=filename,sep="\n")) ### .tex
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
if(ok){ cat(paste("file",filename,"saved\n")) }

@
SaveAsPlainTeXFile: 
<<definiere Kopf-Zeilen-Funktionen--old>>=
SaveAsPlainTeXFile<-function(){
  melde("SaveAsPlainTeXFile",1)
  filename<-tkgetSaveFile(filetypes="{{TEXT-FILE!} {*.*}}",
                          title="name of file?", initialdir=getwd(),
                          defaultextension="", initialfile=sub(".rev$",".rev",workname.sys))
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  filename<-sub("\\.rev$",".tex",filename)	
  <<speichere [[worktext]] Plain-TeX-File ab, Indikator: [[ok]]>>
  if(ok){
    filename<-sub("\\.tex$","",filename)
    filename<-sub("\\.rev$","",filename)	
    filename<-sub("\\.R$","",filename)
    filename<-paste(filename,".rev",sep="")
    <<aktualisiere Reportname>>
    <<kopiere ggf.\ Bilder ins neue Verzeichnis>>
    <<wechsele ins neue Verzeichnis>>
  } else {
    cat("ERROR: write operation failed!!!\n")
  }
  melde("SaveAsPlainTeXFile",2)
  return("ok")
}

@
<<speichere [[worktext]] Plain-TeX-File ab, Indikator: [[ok]]>>=
# verbatim-Separationszeichen festlegen: SEP

<<stelle lokales Coding fest: [[is.UTF]]>>


SEP<- if(!UTF){ eval(parse(text='"\\267"')) }else{ trennzeichen<-"\140" }
worktext<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext)
worktext<-sub("^output-start","\\\\begin{verbatim}",worktext)
worktext<-sub("^output-end",  "\\\\end{verbatim}",worktext)
if(0==length(grep("\\\\end\\{document\\}",worktext))) #2.1.0
  worktext<-c(worktext,"@\n\\end{document}")
## remove noweb items
code.ch<-c("@",worktext,"@")
code.chunk.start<-paste("^<","<.*>",">=",sep="")
code.a<- grep(code.chunk.start,code.ch)
if(0<length(code.a)){
  code.z<-grep("^@",code.ch)
  code.z<-unlist(sapply(code.a ,function(x,y)min(y[y>x]),code.z))
  code.n<-length(code.ch)
  change<-rep(0,code.n); change[c(code.a ,code.z)]<-1
  ind<-(1==(cumsum(change)%%2))[-length(change)]
  def.lines<-diff(c(FALSE,ind))>0
  code.ch<-code.ch[!def.lines]; ind<-ind[!def.lines]
  code.ch<-sub(paste("^ *<","<",sep=""),"# <<",code.ch) # Auskommentierung von uses
  code.ch[ind]<-paste("+",code.ch[ind])
  code.ch[ind]<-sub("^[+][ \t]*$"," ",code.ch[ind]) # leer Codezeilen leeren
  w.tmp<-code.ch; ind.tmp<-ind
  code.ch[ind]<-paste("\\rule{0mm}{0mm}\\\\\\verb",SEP,code.ch[ind],SEP,sep="")
  code.ch[!ind]<-gsub("\\[\\[(.*)\\$(.*)\\]\\]",paste("[[\\1\\\\","$\\2]]",sep=""),code.ch[!ind])
  #code.ch[!ind]<-gsub("\\[\\[(.*)\\$(.*)\\]\\]",paste("\\1\\\\","$\\2",sep=""),code.ch[!ind])
  #code.ch[!ind]<-gsub("\\[\\[(.+)\\]\\]","\\1",code.ch[!ind])
  # code.ch[!ind]<-gsub("(\\[\\[.+\\]\\])",paste("\\\\verb",SEP,"\\1",SEP,sep=""),code.ch[!ind])
  ind<-diff(c(FALSE,ind))>0
  # Codeanfaenge mit ">" versehen:
  code.ch[ind]<-paste("\\rule{0mm}{0mm}\\\\\\verb",SEP,">",substring(code.ch[ind],25),sep="") 
##  code.ch[ind]<-paste(">",substring(code.ch[ind],3)) 

#  code.ch[ind]<-paste("+",code.ch[ind])
#  ind<-diff(c(FALSE,ind))>0
#  code.ch[ind]<-sub("^[+] ","> ",code.ch[ind])
} else { "no code" }
ind<-grep("^@",code.ch)
worktext<-code.ch[-ind]
worktext<-TcltoWin.write(worktext)
try.res <- try(cat(worktext,file=filename,sep="\n"))
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
if(ok){ cat(paste("file",filename,"saved\n")) }
# und ein script.R-file
a<-w.tmp;   ind.a<-diff(c(FALSE,ind.tmp))>0
ind<-grep("^[+]",a)
if(0!=length(ind)){
  a[ind.a]<-paste(">",substring(a[ind.a],3))
  a<-a[ind]; ind<-grep("^[>]",a); no<-seq(ind)
  a[ind]<-paste("#",no,": >\n ",substring(a[ind],2),sep="")
  ind<-grep("^[+]",a)
  if(0!=length(ind)) a[ind]<-paste("", substring(a[ind],2))
  filename<-sub(".tex$",".R",filename)
  try.res <- try(cat(a,file=filename,sep="\n"))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){ cat(paste("file",filename,"saved\n")) }
}

@
Alte Behandlung der TLD-Zeile:
<<old>>=
worktext<-sub("^@<<(.*)>>= \\([0-9]*\\)","@<<\\1>>=",worktext)


@
Was sollte man tun, wenn der File existiert? Aus Gründen der Sicherheit
wird die Datei ggf.\ gesichert und eine entsprechende Meldung
per Message-Box ausgegeben.
<<sichere alten File auf [[old.tmp]], falls [[filename]] existiert>>=
## im Moment nicht aktiv ##
if(file.exists(filename)){
  copy.cmd <- if(<<das OS ist Windows>>) "command.com /c copy" else "cp"
  h<-paste(filename,".bak",sep="")
  system(paste(copy.cmd,filename,h))
  tkmessageBox(title="Warnung", icon="warning",
       message=paste("File existierte!\n ",filename,"\ngesichert unter:\n ",h))
}

@
Vor der Speicherung sollten einige Dinge geschickt übersetzt werden.
2.3.2004: Unter Linux funktionierte auf einmal nicht mehr die korrekte
Speicherung von Umlauten. Die eingelesenen Umlaute waren in R nicht mehr
zu erkennen und zu bearbeiten. Deshalb wurde experimentell die Zeile
mit [[cat..]] unter Linux ersetzt durch Tcl-Zeilen. Die Lösung ist aber unbefriedigend,
da keine weitere Bearbeitung in R erfolgen kann.
Interessanterweise liefert der erste .Tcl-Aufruf die falschen der zweite
die richtigen Zeichen. Der zweite kann jedoch nicht aufgefangen werden.
\begin{verbatim}
> .Tcl("set bbb")
<Tcl> asdfÇÏÇôÇ¬ÇÇÇÇasdf

> .Tcl("puts $bbb")
asdfäöüÄÖÜßasdf
\end{verbatim}
Auch hilft eine Umkodierung mit allen möglichen code Tabellen nicht weiter:
\begin{verbatim}
> .Tcl(paste("set bbb [ encoding convertfrom",readline()," $aaa ] ")); .Tcl("set bbb")

top<-tktoplevel();tt<-tktext(top);tkpack(tt)
.Tcl("set ccc [ .Tk.ID(tt) insert \"0.0 end\" ] )

\end{verbatim}
% 090717
<<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>=
worktext<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext)
worktext<-sub("^output-start","\\\\begin{verbatim}",worktext)
worktext<-sub("^output-end","\\\\end{verbatim}",worktext)
if(0==length(grep("\\\\end\\{document\\}",worktext))) #2.1.0
   worktext<-c(worktext,"@\n\\end{document}")
worktext<-TcltoWin.write(worktext)
try.res <- try(cat(worktext,file=filename,sep="\n"))
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
if(ok){ cat(paste("file",filename,"saved\n")) }

@
Ersetzungsoperation direkt unter Tcl/Tk
<<old>>=
    try(.Tcl(paste("set fileId [open ",filename," w 0600]")))
   #### try.res<-"ok"; try(.Tcl(paste("puts $fileId [ ",.Tk.ID(tworkwin)," get \"0.0\" \"end\" ] ")))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ ",.Tk.ID(tworkwin)," get \"0.0\" \"end\" ] ")))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ regsub -all output-start $xyz ",
                         "\\\\begin{verbatim} ]" )))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ regsub -all output-end $xyz ",
                         "\\\\end{verbatim} ]" )))
    try.res<-"ok"; try(.Tcl(paste("puts $fileId $xyz")))
    try(.Tcl("close $fileId "))
@
\verb+set xyz [ regsub "^output-start"  [ .t  get "0.0" "end" ]  "\\begin\{document\}" ]+

@
Diese Operation wird an verschiedenen Stellen gebraucht, so
daß ein eigener Code-Chunk eingerichtet wird.
[[ok]] zeigt [[TRUE]] im Erfolgs- und [[False]] im Fehlerfall.
Als Verbesserung ist zu bedenken, dass im Fehlerfall das Ergebnis 
die Klasse try-error besitzt.
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>=
if(is.function(try.res)){
  ok <- "OK"
} else {
  if(mode(try.res)=="externalptr"||mode(try.res)=="environment") try.res<-"ok"
  if(mode(try.res)=="S4") try.res <- "ok" else ok<-try.res[1]  ## 130304
  if(is.null(ok) ||is.na(ok)|| is.name(ok) || is.list(ok) || is.numeric(ok)) ok <- "OK"
  if(!is.character(ok)) { ok <- "OK" }
}
if(0!=length(ok)&&("Error"==substring(ok,1,5) | "Fehler"==substring(ok,1,6))){
  ok<-FALSE
  error.msg<-unclass(try.res); error.msg<-sub("options.warn.2.","",error.msg)
  cat(error.msg,"\n")
  if(0<length(grep("Warnung",error.msg))||0<length(grep("warning",error.msg)))
     cat("A warning message stopped the evaluation!",
           "If you want to\nevaluate the code anyway",
           "evaluate code by:\n>WarnEval<")
  # cat("sorry, operation failed in:",as.character(sys.call()),"!!!\n") # due to R-2.15.1
} else { ok<-TRUE }


@
<<aktualisiere Reportname>>=
workname.sys<-sub(paste(".*",.Platform$file.sep,sep=""),"",filename)
lworkname.sys<-get("lworkname.sys",envir=revive.sys)
tkconfigure(lworkname.sys,text=paste(workname.sys,""))
assign("workname.sys",workname.sys,envir=revive.sys)
# tkwm.title(TopW,paste("RELAX:",workname.sys))
tkwm.title(TopW,paste(if(but.Wizardry=="simple") "redit:" else "RELAX:",workname.sys))                      

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveDiffReport]]}
\paragraph{[[SaveDiffReport]] zum Speichern von Unterschieden.}
\begin{enumerate}
\item [[worktext]] speichern
\item [[diff alt neu > diffreport]]
\item [[cat diffreport| grep "^[0-9]" > difflines]]
\item einlesen und [[difflines<-sub("^([0-9]*)[a-z]","",difflines)]]
\end{enumerate}
<<definiere Kopf-Zeilen-Funktionen>>=
# ermittle neue Zeilen:
SaveDiffReport<-function(){
  melde("SaveDiffReport",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.html}}",
                          title="Diff-File-Name?", initialdir=getwd(),
                          defaultextension=".html", initialfile=
              paste("diff",workname.sys,sep="-"))
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  try.res <-try(cat(worktext,file=<<tmp>>,sep="\n"))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok) return()
  # stelle Differenzen fest
  system(paste("diff ",workname.sys," ",<<tmp>>," | grep \"^[0-9]\" > ",<<tmp.sink>>))
  difflines<-scan(<<tmp.sink>>,"",blank.lines.skip=FALSE,sep="\n")
  difflines<-sub("^([0-9]*)[a-z]","",difflines)
  difflines<-sub(",",":",difflines)
  difflines<-paste("c(",paste(difflines,collapse=","),")")
  try(difflines<-eval(parse(text=difflines)))
  if(length(difflines)>0 || "ERROR"!=substring(unlist(difflines)[1],1,5)){
    # suche Chunks:
    worktext<-c("@",worktext,"@")
    difflines<-difflines+1
    chunkbegins<-grep("(^@)|(^@<<(.*)>=)", worktext)
    chunk.log<-rep(FALSE,length(chunkbegins))
    ch.new<- 0<hist(difflines,plot=FALSE,
                    breaks=c(chunkbegins,length(worktext)+1)-0.5)$counts
    ch.new<- ch.new | c(ch.new[-1],FALSE) | c(FALSE,ch.new[-length(ch.new)])
    ch.new<-seq(ch.new)[ch.new]
    # extrahiere Chunks:
    lines<-paste(chunkbegins[ch.new],":",
             c(chunkbegins[-1],chunkbegins[length(chunkbegins)]+1)[ch.new]-1)
    lines<-paste(lines,collapse=",")
    lines<-try(eval(parse(text=paste("c(",lines,")"))))
    if(ch.new[1]) lines<-lines[-1]
    if(ch.new[length(ch.new)]) lines<-lines[-length(lines)]
    difftext<-worktext[unique(lines)]
    # speichere difftext
    ### SaveAsHtml(difftext,filename)
    try.res <-try(cat(difftext,file=filename,sep="\n"))
  }
  melde("SaveDiffReport",2)
}

@
\subsubsection{Kopfzeile: [[File]] --- [[OpenReport]]}
\paragraph{[[OpenReport]] zum Öffnen von Reportdateien.}
Nach der Erkundung des Dateinamens wird der Reportdatei gelesen und
ans Ende des Arbeitsfenster gehängt.
<<definiere Kopf-Zeilen-Funktionen>>=
OpenReport<-function(){
  melde("OpenReport",1)
  filename<-tkgetOpenFile(filetypes="{{Paper Files} {.rev}}",
                          title="Select .rev file to be loaded!",
                          defaultextension=".rev", initialfile=workname.sys,
                          initialdir=getwd())
  <<checke [[filename]], quitte ggf.>>
  try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    <<wechsele ins neue Verzeichnis>>
    <<aktualisiere Reportname>>
    try.res<-WinToTcl.read(try.res)
        ## Eintrag mit Entfernung des bisherigen Inhalts:
        ## worktext<-paste(try.res, collapse="\n")
        ## @<<schreibe [[worktext]] ins Arbeitsfenster>>
    news<-c("",try.res)
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<setze Output-Klammern um>>
    <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
    RunStart()
    <<aktualisiere Texthervorhebungen>>
    <<kreiiere Bilder neu und zeige sie im Textfenster an>>
    melde(paste("r", workname.sys), "cmd.msg")
  } else { cat("ERROR: File",filename,"not found!!!\n") }
  melde("OpenReport",2)
}

@
<<setze Output-Klammern um>>=
worktext<-sub("^\\\\begin\\{verbatim\\}","output-start",worktext)
worktext<-sub("^\\\\end\\{verbatim\\}","output-end",worktext)

@
OpenTextFile
<<definiere Kopf-Zeilen-Funktionen>>=
OpenTextFile<-function(){
  melde("OpenTextFile",1)
  filename<-tkgetOpenFile(filetypes="{{TEXT-FILE!} {*.*}}",
                          title="Select file to be loaded!",
                          initialfile=sub(".rev$",".txt",workname.sys),
                          initialdir=getwd())
  <<checke [[filename]], quitte ggf.>>
  try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    filename<-paste(sub(".txt$","",filename),".rev",sep="")
    <<wechsele ins neue Verzeichnis>>
    <<aktualisiere Reportname>>
    try.res<-WinToTcl.read(try.res)
    <<translation of not rev files>>
    ## Eintrag mit Entfernung des bisherigen Inhalts:
    ## worktext<-paste(try.res, collapse="\n"); @<<schreibe [[worktext]] ins Arbeitsfenster>>
    news<-c("",try.res)
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<setze Output-Klammern um>>
    <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
    <<aktualisiere Texthervorhebungen>>
    <<kreiiere Bilder neu und zeige sie im Textfenster an>>
    melde(paste("r", workname.sys), "cmd.msg")
  } else { cat("ERROR: File",filename,"not found!!!\n") }
  melde("OpenTextFile",2)
}
@
Zeilen, die mit [[> ]] beginnen, werden als Code-Zeilen interpretiert.
Zeilen, die mit [[+ ]] beginnen, werden als Folge-Code-Zeilen angesehen.
<<translation of not rev files>>=
    try.res<-sub("^[ \t]*$","\n@",try.res)
    try.res<-sub("^\\+ ","> ",try.res)
    code.line<-"> "==substring(try.res,1,2)
    try.res[code.line]<-substring(try.res[code.line],3)
    first.code.line<-diff(c(FALSE,code.line))>0
    code.chunk.start<-paste("<","<*>",">=",sep="")
    try.res[first.code.line]<-paste(code.chunk.start,try.res[first.code.line],sep="\n")
    first.text.line<-rev(diff(c(FALSE,rev(code.line)))>0)
    try.res[first.text.line]<-paste(try.res[first.text.line],"@",sep="\n")
    
@
<<checke [[filename]], quitte ggf.>>=
if(!is.character(filename)) filename<-tclvalue(filename)
if(filename=="") return("cancel")

@
An verschiedenen Stellen ist es erforderlich, das Arbeitsfenster zu
aktualisieren. Deshalb wird ein eigener Code-Chunk spendiert.
<<schreibe [[worktext]] ins Arbeitsfenster>>=
if(length(worktext)>1) worktext<-paste(worktext,collapse="\n")
tkdelete(tworkwin,"0.0","end")
try(tkinsert(tworkwin,"0.0",paste(worktext,collapse="\n")))
tksee(tworkwin,"end")
<<aktualisiere Texthervorhebungen>>
<<zeige Bilder im Textfenster an>>

@
Entsprechend für das Outputfenster:
<<schreibe [[worktext]] ins Outputfenster>>=
if(length(worktext)>1) worktext<-paste(worktext,collapse="\n")
tkdelete(toutwin,"0.0","end")
try(tkinsert(toutwin,"0.0",paste(worktext,collapse="\n")))
@
<<kopiere ggf.\ Bilder ins neue Verzeichnis>>=
olddir<-getwd(); newdir<-sub("(.*)/(.*)","\\1",filename)
if(olddir!=newdir){
  rev<-grep("includegraphics",worktext,value=TRUE)
  if(0<length(rev)){
    # pics<-sub("(.*)\\{(p.*\\.ps)\\}(.*)","\\2",rev) #081121
    pics<-sub("(.*)\\{(p.*)\\}(.*)","\\2.ps",rev); pics<-sub("\\.ps\\.ps$",".ps",pics)
    pics<-c(pics,sub("ps$","jpg",pics),sub("ps$","ppm",pics)) # 121114
    mess<-NULL
    for(pic in pics) {
      if(file.exists(pic)){
        a<-file.copy(pic,paste(newdir,pic,sep="/"))
        mess<-c(mess,if(a) paste("picture",pic,"copied to",newdir) else
                           paste("warning: picture", pic,"not copied"))
      }
    }
    cat(mess,sep="\n")
    "process of copying file(s) finished"
  }
}


@
<<wechsele ins neue Verzeichnis>>=
h <- strsplit(filename,.Platform$file.sep)[[1]]
workname.sys<-rev(h)[1]
workpath.sys<-paste(h[-length(h)],collapse=.Platform$file.sep)
setwd(workpath.sys)

@
<<definiere Kopf-Zeilen-Funktionen>>=
OpenRevbook<-function(){
  melde("OpenRevbook",1)
  h<-file.path(relax.path,"rev")
  filename<-tkgetOpenFile(filetypes="{{Paper Files} {.rev}}",
                          title="Choose paper to be loaded",
                          defaultextension=".rev", initialfile=workname.sys,
                          initialdir=h)
  <<checke [[filename]], quitte ggf.>>
  try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    <<aktualisiere Reportname>>
    code.ch<-grep("^@<<(.*)>>=",try.res)
    if(0<length(code.ch))
       try.res[code.ch]<-paste(try.res[code.ch], " (",1:length(code.ch),")",sep="")
       try.res<-WinToTcl.read(try.res)
        worktext<-paste(try.res, collapse="\n") # alter Inhalt wird entfernt
	<<schreibe [[worktext]] ins Arbeitsfenster>>
      RunStart()
    <<aktualisiere Texthervorhebungen>>
    <<kreiiere Bilder neu und zeige sie im Textfenster an>>
    melde(paste("r", workname.sys), "cmd.msg")
  } else { cat("ERROR: File",filename,"not found!!!\n") }
  melde("OpenRevbook",2)
}
@
<<definiere Kopf-Zeilen-Funktionen>>=
LoadRwtools<-function(){
  melde("LoadRwtools",1)
  path<-file.path(relax.path,"rev/robj.R")
  fns<-readLines(path) #2.1.0
  try(eval(parse(text=fns),
               envir=pos.to.env(which(path.package("relax")==searchpaths())))) # 130325 .path.package defunct
  melde("LoadRwtools",2)
}

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveAsHtml]]}
\paragraph{[[SaveAsHtml]] zur Erstellung eines [[Html]]-Dokuments.}
Dieser Abschnitt ist noch im Aufbau. Er dient mehr dazu, eine Idee
zu skizzieren. Zur Zeit wir die Abspeicherung als Html-File immer
dann vorgenommen, wenn der Report gespeichert wird.
<<speichere Report als Html-File>>=
{
  melde("weaveRhtml",1)
  weaveRhtml(workname.sys,
                     replace.umlaute=replace.umlaute.sys)
  melde("weaveRhtml",2)
}
@
<<old: speichere Report als Html-File>>=
{
  melde("SaveReportAsHtml",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  SaveAsHtml(worktext,workname.sys)
  melde("SaveReportAsHtml",2)
}

@
Für die Speicherung als [[Html]]-File soll eine Funktion eingesetzt werden.
<<definiere [[SaveAsHtml]]>>=
SaveAsHtml<-function(savetext,filename="lotto.rev"){
  <<initialisiere [[AsHtml]]; [[AsHtml]]>>
  <<rette Html-Anweisungen; [[AsHtml]]>>
  <<bearbeite Text-Chunks; [[AsHtml]]>>
  <<bearbeite Code-Chunks; [[AsHtml]]>>
  <<rekonstruiere alte Html-Anweisungen; [[AsHtml]]>>
  <<klebe Kopf und Schwanz an; [[AsHtml]]>>
  <<checke Namen und speichere; [[AsHtml]]>>
}

@
nur für Testzwecke
<<initialisiere [[AsHtml]]; [[AsHtml]]>>=

@
<<rette Html-Anweisungen; [[AsHtml]]>>=
# savetext<-gsub("<p>",NL,savetext)

@
<<bearbeite Text-Chunks; [[AsHtml]]>>=
<<behandle Code im Text; [[AsHtml]]>>
<<bearbeite Outputs; [[AsHtml]]>>
<<blende includegraphics-Zeilen aus; [[AsHtml]]>>
<<ersetze Umlaute; [[AsHtml]]>>
## savetext<-gsub("^@","</pre><p>",savetext)
savetext<-gsub("^@","</pre>",savetext)

@
Die Umlautersetzung (der letzte Punkt im letzten Chunk)
wird an zentraler Stelle der Umlautersetzung abgehandelt.

@
Kleinerzeichen ersetzen
<<behandle Code im Text; [[AsHtml]]>>=
savetext<-gsub("@@<<","&lt;&lt;",savetext)

@
<<blende includegraphics-Zeilen aus; [[AsHtml]]>>=
if(length(h<-grep("includegraphics",savetext))>0){
  savetext[h]<-paste("<!--",savetext[h],"-->")
}

@
<<bearbeite Outputs; [[AsHtml]]>>=
#savetext<-gsub("((\\\\begin\\{verbatim\\})|(output-start))","<p><pre>",savetext)
#savetext<-gsub("((\\\\end\\{verbatim\\})|(output-end))",  "</pre><p>",savetext)
savetext<-gsub("((\\\\begin\\{verbatim\\})|(output-start))","<pre>",savetext) #2.1.0
savetext<-gsub("((\\\\end\\{verbatim\\})|(output-end))",  "</pre>",savetext) #2.1.0

@
<<bearbeite Code-Chunks; [[AsHtml]]>>=
<<ersetze TLD-Zeilen; [[AsHtml]]>>
<<ersetze externe Verweise; [[AsHtml]]>>

@
<<ersetze externe Verweise; [[AsHtml]]>>=
savetext<-gsub("#<(.*)>#","</pre>&lt;\\1&gt;<pre>",savetext)

@
<<ersetze TLD-Zeilen; [[AsHtml]]>>=
no <- grep("@<<(.*)>>=",savetext)
if(0<length(no)){
  savetext<-gsub("^@<<(.*)>>=",  "&lt;&lt;\\1 ",savetext)
  savetext[no]<-paste(savetext[no],1:length(no),"&gt;&gt;=<pre>")
  savetext<-gsub("@<<(.*)>>","</pre>&lt;&lt;\\1&gt;&gt; <pre>",savetext)
}
@
<<rekonstruiere alte Html-Anweisungen; [[AsHtml]]>>=
# savetext<-gsub(NL,"<p>",savetext)

@
<<klebe Kopf und Schwanz an; [[AsHtml]]>>=
savetext<-c("<HTML><HEAD><TITLE>$$1</TITLE></HEAD>",
            "<BODY BGCOLOR=\"#FFFFFF\">", savetext, "</BODY></HTML>")

@
<<checke Namen und speichere; [[AsHtml]]>>=
savetext<-sub("$","<br>",savetext)
savetext<-sub("pre><br>$","pre>",savetext)
n<-nchar(filename)
if(is.null(n)||5>n||substring(filename,n-3,n)!=".rev"){
    cat("ERROR: File name not ok!!!\n")
}else{
    filename<-paste(substring(filename,1,n-3),"html",sep="")
    try(get("cat","package:base")(savetext,sep="\n",file=filename))
}

@
Ende der Definition von [[SaveAsHtml]].

@
\subsubsection{Kopfzeile: [[File]] --- [[ViewReport.html]]}
\paragraph{[[ViewReport.html]] zum Anzeigen von formatierten Rohreports.}
Falls der Browser nicht richtig verankert ist, soll [[mozilla]] verwendet werden.
Fehler unter windows: Das browser-Argument
[[fname<-paste("file://",getwd(),.Platform$file.sep,]]
[[sub("rev$","html",filename),sep="")]]
führte zu einem Fehler, Therapie: Pfad wurde weggelassen.
<<definiere Kopf-Zeilen-Funktionen>>=
ViewReport.html<-function(){
  melde("ViewReport.html",1)
  n<-nchar(filename<-workname.sys)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".rev"){
    cat("ERROR: file name not ok!!!\n"); return()
  }
  if( <<das OS ist Windows>> ){
         fname<-paste(sub("rev$","html",filename),sep="")
         browser.exe<- if(browser.sys=="") "start " else browser.sys
	 res<-shell(paste(browser.exe, fname),wait=FALSE)
         if(res!=0){
           cat("ERROR: browser hasn't been started successfully \n")
           cat("please, start and load file on foot\n")
         }
    }else{
        fname<-paste(sub("rev$","html",filename),sep="")
        if(browser.sys!=""){
              try(system(paste(browser.sys,fname),wait=FALSE))
        }else{
	  if(file.exists(options()$browser))
            try(system(paste(options()$browser,fname),wait=FALSE))
          else if(1==length(system("which firefox",TRUE))) 
              try(system(paste("firefox",fname),wait=FALSE))
            else if(1==length(system("which mozilla",TRUE))) 
                 try(system(paste("mozilla",fname),wait=FALSE))
               else if(1==length(system("which epiphany",TRUE))) 
                    try(system(paste("epiphany",fname),wait=FALSE))
        }
  }
  melde("ViewReport.html",2)
}
@
<<old>>=
        fname<-paste(sub("rev$","html",filename),sep="")
        if(browser.sys==""){
	  if(file.exists(options()$browser))
            try(browseURL(fname))
          else
            try(browseURL(fname,browser="mozilla"))
	}else try(browseURL(fname,browser=browser.sys))  #050607

@
\subsubsection{Kopfzeile: [[Edit]] --- [[EditReport]]}
\paragraph{[[EditReport]] zur Bearbeitung des Reports mit einem Editor.}
Als Zwischenablage wird eine Datei mit dem Namen, der sich auf
[[<<tmp>>]] befindet, angelegt.
Achtung Seiteneffekt: Sie wird nicht automatisch wieder entfernt.
<<definiere Kopf-Zeilen-Funktionen>>=
EditReport<-function(){
  melde("EditReport",1)
  if(<<OS ist Mac-Mini>> ){
     cat("Sorry: not implemented yet!\n"); return()
  }    
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  worktext<-TcltoWin.write(worktext)
  try.res <-try(cat(worktext,file=<<tmp>>,sep="\n"))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    ##  try.res <- try(system(paste(editor.sys, ..tmp..)))
    cmd<-paste(editor.sys, <<tmp>>)
    if(<<das OS ist Windows>>){
      try.res<-try(shell(cmd,wait=TRUE))
    }else{
      try.res<-try(system(cmd))
    }
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
    try.res<-worktext<-try(myscan(<<tmp>>,"",sep="\n",blank.lines.skip=FALSE))
      <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
      if(ok){
        if(<<das OS ist Windows>>)worktext<-WinToTcl.read(worktext)
        <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
        worktext <- paste(worktext,collapse="\n")
#       worktext <- sub("\\\\end\{document\}","%end\{document\}",worktext)
      } else {  cat("ERROR: file open operation not successful!!!\n") }
    } else {  cat("ERROR: editor start not successful!!!\n") }
  } else { cat("ERROR: file write operation not successful!!!\n") }
  melde("EditReport",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RunAll]]}
\paragraph{[[RunAll]] zur Zustandswiederherstellung.}
Um nach einer unterbrochenen Sitzung wieder aufsetzen zu können,
muß der alte Zustand wieder hergestellt werden. Mit [[RunAll]]
werden alle Start- und Stern-Chunk aktiviert.
Dazu wird an den bestehenden Report ein neuer Code-Chunk mit dem Namen
[[RunAllStartsAndStars]] angefügt, der nur aus der Verwendung der
Start- und Sternmodule besteht. Dieser neue Chunk wird aktiviert und
zum Schluß wieder entfernt.
<<definiere Kopf-Zeilen-Funktionen>>=
RunAll<-function(){
  melde("RunAll",1)
  news<-paste("RunAll:",date(),"\n")
  <<schreibe [[news]] ans Ende des Outputfeldes>>
  news<-paste("\n@\n@<<RunAllStartsAndStars>>=\n@<<start>>\n@<<*>>\n@")
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  tkmark.set(tworkwin,"insert","end")
  fWarnEval()
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  h<-grep("RunAllStartsAndStars",worktext)
  if(0<length(h)) worktext<-worktext[1:(h[1]-2)]
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("RunAll",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RunAllandIncludeResults]]}
\paragraph{[[RunAllandIncludeResults]].}
[[RunAllandIncludeResults]]
Punkte: Defaultwerte, Dateinamen für Graphiken, spezielle TeX-Formatierungen für Output.

Für die Umsetzung lassen sich verschiedene Optionen wählen. Diese müssen über den 
Code-Chunk-Namen übermittelt werden. Folgende aus der Sweave-Beschreibung übernommene Optionen sind zur Zeit relevant (Friedrich Leisch: Sweave User Manual, R Version 1.6.0):
\begin{itemize}
\item echo: logical (TRUE). Include S code in the output file?
\item eval: logical (TRUE). If FALSE, the code chunk is not evaluated, and hence no text or graphical
output produced.   % -> OK
\item results: character string (verbatim). If verbatim, the output of S commands is included in
the verbatim-like Soutput environment. If tex, the output is taken to be already proper
latex markup and included as is. If hide then all output is completely suppressed (but
the code executed during the weave).
%\item print: logical (FALSE) If TRUE, each expression in the code chunk is wrapped into a print()
%statement before evaluation, such that the values of all expressions become visible.
%\item term: logical (TRUE). If TRUE, visibility of values emulates an interactive R session: values of
%assignments are not printed, values of single objects are printed. If FALSE, output comes
%only from explicit print or cat statements.
%\item split: logical (FALSE). If TRUE, text output is written to separate files for each code chunk.
%strip.white: logical (TRUE). If TRUE, blank lines at the beginning and end of output are
%removed.
%\item prefix: logical (TRUE). If TRUE generated filenames of figures and output have a common
%prefix.
\item prefix.string: a character string, default is the name of the '.Snw' source file.
%\item include: logical (TRUE), indicating whether input statements for text output and include-
%graphics statements for figures should be auto-generated. Use include=FALSE if the
%output should appear in a different place than the code chunk (by placing the input line
%manually).
\item fig: logical (FALSE), indicating whether the code chunk produces graphical output. Note that
only one figure per code chunk can be processed this way.
%\item eps: logical (TRUE), indicating whether EPS figures shall be generated. Ignored if fig=FALSE.
%\item pdf: logical (TRUE), indicating whether PDF figures shall be generated. Ignored if fig=FALSE.
\item width:  numeric (6), width of figures in inch.
\item height: numeric (6), height of figures in inch.
\item[] [echo:] Option echo=FALSE indicates that the S input should not be included in the final document
(no Sinput environment).
\end{itemize}
Link: [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.148.8314&rep=rep1&type=pdf]]

@
In der hier implementierten simplen Sweave-Version funktionieren alle oben genannten Optionen.
Die auskommentierten lassen sich aber nicht wählen.
@
Hinweis: interessanterweise funktioniert Folgendes, so dass damit aus einem Papier heraus
sich selbst verarbeiten kann. Dazu muss natürlich unbedingt die Option [[eval=FALSE]] gesetzt
werden, damit keine unsinnige Rekursion auftritt.
Siehe auch: Beispiel- und Test-File [[mySweavetest.rev]].
<<eval=FALSE>>=
get("RunAllandIncludeResults",revive.sys)()

@
<<definiere Kopf-Zeilen-Funktionen>>=
RunAllandIncludeResults<-function(){
  melde("RunAllandIncludeResults",1)
  # get report
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<aktiviere Sexpr-Ausdrücke und Code Chunks, integriere Ergebnisse und latexe>>
  melde("RunAllandIncludeResults",2)
}

@
Eine Idee induziert die nächste, so soll noch als weitere Variation das
Extrahieren einer Umgebung a la [[ProcessBeginEndEnv]] mit anschließender Auswertung
a la [[RunAllandIncludeResults]] kombiniert werden. Es entsteht:
[[RunBeginEndEnvandIncludeResults]]
<<definiere Kopf-Zeilen-Funktionen>>=
<<testchunk>>
@
<<testchunk>>=
RunBeginEndEnvandIncludeResults<-function(){
  melde("RunBeginEndEnvandIncludeResults",1)
  # from: ProcessBeginEndEnv
  filename <- "local-chunk.rev"
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<extrahiere Begin-End-Umgebung in [[worktext]] mittels Cursor-Zeile [[line]]>>
  # from: RunAllandIncludeResults
  <<aktiviere Sexpr-Ausdrücke und Code Chunks, integriere Ergebnisse und latexe>>
  melde("RunBeginEndEnvandIncludeResults",2)
}

@
<<aktiviere Sexpr-Ausdrücke und Code Chunks, integriere Ergebnisse und latexe>>=
  # set default values
  <<initialisiere Optionsparameter>>  
  # find names of code chunks  
  idx <- grep(paste("^<","<.*>",">=",sep=""),worktext)
  if(0==length(idx)) return("relax warning: no chunk found!")
  chunk.set <- worktext[idx] <- sub(">>=.*",">>=",worktext[idx])
  <<werte Sexpr-Ausdrücke aus>>
  # initialize some variables
  pic.no <- 0; rep.name <- sub(".rev$","",workname.sys)
  for(i.chunk in seq(along=chunk.set)){     
     <<hole nächsten chunk und setze Optionen um>>
     <<aktiviere Chunk [[i.chunk]]>>
     <<integriere neues Bild>>
     <<füge neuen R-Ouput ein>>
     <<entferne oder formatiere Code-Chunk>>
  }
  idx <- grep("\\SweaveOpts",worktext)
  if(0 < length(idx)) {    
    worktext[idx] <- paste("\\newcommand{\\SweaveOpts}[1]{\\relax}",worktext[idx])
    if(1 < length(idx)) worktext[idx[-1]] <- sub("newcommand","renewcommand",worktext[idx[-1]])
  }
  filename <- paste(rep.name,"-out",".rev",sep="")
    #filename <- paste(rep.name,"-out",".tex",sep="")
    #<speichere [[worktext]] als Textfile ab, Indikator: [[ok]]>#
  base::cat(c(worktext,"@","\\end{document}"),file=filename,sep="\n")
  try(weaveR(filename)) # ,eval_Sexpr=FALSE)
  filename <- paste(rep.name,"-out",".tex",sep="")
  cat("-> '",filename,"' generated",sep="")
  Sys.sleep(0.5)
  ## LatexReport()
  LatexReport(filename=filename)


@
Übernommen aus weaveR bis auf eine kleine Vereinfachung sowie Verkürzung am Ende und Anfang.
<<werte Sexpr-Ausdrücke aus>>=
sexpr.lines<-grep("\\Sexpr\\{.*\\}",worktext)
for(l in seq(along=sexpr.lines)){
  # hole Nummer l der Zeilen, die Sexpr-Expressions enthalten 
  cand<-worktext[sexpr.lines[l]]
  # knacke Kandidaten-Zeile an der Stelle auf, an der \Sexpr gefunden wird
  cand<-unlist(strsplit(cand,"\\\\Sexpr"))
  # cand[1] ist der vor der ersten Expression, 
  # cand[i+1] der mit der i-ten Expression beginnt
  # alle Expressions der Zeile werden nacheinander abgearbeitet
  for(j in seq(cand)[-1]){
    # ncandj zeigt die Laenge von Kandidat j an
    ncandj<-nchar(cand[j])
    # sexpr verwaltet den j-ten Kandidaten zeichenweise
    sexpr<-substring(cand[j],1:ncandj,1:ncandj) 
    # es gilt die beendende Klammer von Sexpr zu finden
    brack<-cumsum((sexpr=="{")-(sexpr=="}")) 
    # n.sexpr zeigt die Stelle der schliessenden-Klammer
    n.sexpr<-which(brack==0)[1]; if(is.na(n.sexpr)) next
    # mit n.sexpr greifen wir den vorderen Teil von sexpr und evaluieren
    code <- paste(collapse="",sexpr[1:n.sexpr])
    melde("werte Sexpr aus",2,code)
    # if(identical(revive.env,"")) ... else -> gegenüber weaveR vereinfacht
    result <- try(eval(parse(text=code),envir=revive.env))
    # wenn nichts rauskommt, ist nichts zu modifizieren
    if(0!=length(result)&&!identical(result,"")) { 
      # 101217 auch leere Ergebnisse ersetzen Sexpr!
      # print("---");print(result);print("---")
      # im Fehlerfall muss es eine Meldung geben
      if(class(result)=="try-error"){ 
        result<-paste("[[\\Sexpr-error:",
                      paste(sexpr[1:n.sexpr],collapse=""),"]]",collaspe="")
      }else{
        # bei nummerischen Ergebnissen werden ungewollte Nachkommastellen entfernt
        if(is.numeric(result)) result<-signif(result,digits=options()$digits)
        # Das Ergebnis wird verpackt
        result<-paste("[[",paste(unlist(result),collapse=" "),"]]",sep="")
      }
    }
    # das Ergebnis des j-ten Ausdrucks wird vorn,
    # also wo das Kommando stand eingetragen
    cand[j]<-paste(result, substring(cand[j],n.sexpr+1),sep="")
  }
  worktext[sexpr.lines[l]]<-paste(cand,collapse="")  
}

@
Die Namen der Parameter entsprechen denen, die bei Sweave verwendet werden, jedoch mit
dem Unterschied, dass sie mit großen Buchstaben geschrieben werden.
<<initialisiere Optionsparameter>>=
defaults <- list()
set.defaults <- function(echo=NULL,eval=NULL,results=NULL,fig=NULL,height=NULL,width=NULL,prefix.string,...){
     defaults <- defaults 
     if(!is.null(echo))     defaults$ECHO     <- echo
     if(!is.null(eval))     defaults$EVAL     <- eval
     if(!is.null(results))  defaults$RESULTS  <- results
     if(!is.null(fig))      defaults$FIG      <- fig
     if(!is.null(height))   defaults$HEIGHT   <- height
     if(!is.null(width))    defaults$WIDTH    <- width
     if(!missing(prefix.string)) {
       prefix.string<-as.character(substitute(prefix.string)) 
       #  prefix.string <- gsub("\\\\","/",prefix.string)
       defaults$PREFIX.STRING    <- prefix.string
     }
     defaults
}
ECHO <- TRUE; EVAL <- TRUE; RESULTS <- "verbatim"; FIG=FALSE; HEIGHT="10cm"; WIDTH=NA; PREFIX.STRING <- ""
defaults <- set.defaults(echo=ECHO,eval=EVAL,results=RESULTS,fig=FIG,height=HEIGHT,width=WIDTH,
                         prefix.string="")

@
<<hole nächsten chunk und setze Optionen um>>=
# get chunk header
chunk.header <- chunk.set[i.chunk]; LINE <- match(chunk.set[i.chunk],worktext)
# get code of chunk -- copied from EvalRCode
code.start<-LINE
if(LINE < length(worktext) && "@"!=substring(worktext[LINE+1],1,1)){
  <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
} else { code <- NULL; code.end <- LINE }
CODE.END <- code.end
melde(paste(220,"code.start",code.start),2,code) 
# set defaults new
idx <- grep("\\\\SweaveOpts[{].*[}]",worktext[1:LINE])
if(0<length(idx)){
  txt <- worktext[rev(idx)[1]]
  txt <- sub("^.*\\\\SweaveOpts[{](.*)[}].*$","set.defaults(\\1)",txt)
  defaults <- eval(parse(text=txt))
  for(i in seq(along=defaults)){
    if(is.character(defaults[[i]])) h<-"'" else h <- NULL
    eval(parse(text=paste(toupper(names(defaults))[i],"<-",h,defaults[[i]],h,sep="")))
  }
  if(!is.na(PREFIX.STRING)) rep.name <- paste(sep="",PREFIX.STRING,sub(".rev$","",workname.sys))
}
# set local options to default values
  for(i in seq(along=defaults)){
    if(is.character(defaults[[i]])) h<-"'" else h <- NULL
    eval(parse(text=paste(toupper(names(defaults))[i],"<-",h,defaults[[i]],h,sep="")))
  }
# set local options 
c.h <- gsub(" ","",chunk.header)
if(0<length(grep("echo=TRUE", c.h))) ECHO <- TRUE
if(0<length(grep("echo=FALSE",c.h))) ECHO <- FALSE
if(0<length(grep("eval=TRUE", c.h))) EVAL <- TRUE
if(0<length(grep("eval=FALSE",c.h))) EVAL <- FALSE
if(0<length(grep("results=",c.h))){
  RESULTS <- sub("^.*results=([a-z]*).*$","\\1",c.h)
  if( !(RESULTS %in% c("verbatim","tex","hide"))) RESULTS <- "verbatim"
}
if(0<length(grep("fig=TRUE", c.h))) FIG <- TRUE
if(0<length(grep("fig=FALSE",c.h))) FIG <- FALSE
if(0<length(grep("height=",c.h))){
  HEIGHT <- sub("^.*height=([0-9.]+[a-z]*).*$","\\1",c.h)
}
if(0<length(grep("width=",c.h))){
  WIDTH  <- sub("^.*width=([0-9.]+[a-z]*).*$", "\\1",c.h)
}
if(0<length(grep("prefix.string=",c.h))){
  PREFIX.STRING  <- sub("^.*prefix.string=([a-z0-9.\\-]+).*$", "\\1",c.h)
}
# remove local option settings
c.h <- chunk.header
repeat{
  h<-sub("[,; ]*[a-z]+ *= *[a-z0-9A-Z]+","",c.h)
  if(h==c.h) break else c.h <- h
}
worktext[LINE] <- c.h
@
<<aktiviere Chunk [[i.chunk]]>>=
# eval option "TRUE" found
if(EVAL){
  EVAL.RESULT <- try.res <- NULL
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
    code <- sub("^ *print","base::print",code)
    code <- sub("^ *cat","base::cat",code)
    <<probiere [[code]] in [[revive.env]] mit warn-break, Ergebnis: [[try.res]]>>
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
      EVAL.RESULT <- try.res
    } else { EVAL.RESULT <- "Error"; cat("sorry, evaluation not successful!!!\n") }
  } ## else { cat("no code found!!!\n") }
} 

@
<<integriere neues Bild>>=
if(FIG && EVAL){
melde("225 ...Include picture",2) #<unused: Trash picture of report># 
  pic.no <- pic.no + 1
  bildname<-paste(rep.name,"-out-pic-",pic.no,".ps",sep="")
  <<lege Bild unter [[bildname]] ab>>
  # include links
  n <- length(worktext)
  textstart <- c(grep("^@",worktext),n+1)
  textstart <- c(textstart[LINE <= textstart],n)[1]
  news <- unlist(strsplit(news,"\n")) 
  news <- news[grep("includegraphics",news)]
  if(!is.na(WIDTH)) news <- sub("cm",paste("cm,width=",WIDTH,sep=""),news)
  news <- sub("[0-9.]+cm",HEIGHT,news)
  worktext <-  c(worktext[  1:(textstart-1) ],"@",news, 
                 worktext[-(1:(textstart-1))])
melde("226 ...Include picture",2,LINE,news,textstart)
}

@
<<füge neuen R-Ouput ein>>=
melde("R-Output",2,RESULTS,EVAL,ECHO)
if(EVAL && RESULTS != "hide"){ #<unused: Trash R Output>#
  if(0 < length(try.res <- EVAL.RESULT)){        
    if(!is.null(try.res)&&0<length(try.res)){
      sink(<<tmp.sink>>);get("print",pos="package:base")(try.res);sink()
      news<-paste(myscan(<<tmp.sink>>,"",sep="\n"),collapse="\n")
    } else news <- NULL
    melde("231...write result",2,news)
    if(1<=nchar(news)){
      if(length(grep("egin[{]table[}]",news))>0 &&
         length(grep("generated.*xtable.*package",news))>0){
        news<-sub("(\n%.*begin[{]table[}])","\noutput-end\n\\1",news)       
        news<-sub("(.end[{]table[}])","\\1\noutput-start",news)       
        news<-paste("\n@",paste("output-start",news,sep=""),"output-end\n", sep="\n")
        news<-sub("output-start\n+output-end","",news)
      } else {    
        if( RESULTS == "verbatim" ) 
        # news<-paste("@","\\begin{quote}\\begin{verbatim}",news,"\\end{verbatim}\\end{quote}",sep="\n")
          news<-paste("@","\\begin{verbatim}",news,"\\end{verbatim}",sep="\n")
        if( RESULTS == "tex" ) news<-paste("@",news,sep="\n")
      }
      news <- gsub("\n+","\n",news)
      n <- length(worktext)
      textstart <- c(grep("^@",worktext),n+1)
      textstart <- c(textstart[LINE <= textstart],n)[1]
      worktext <- c(worktext[1:(textstart-1)],news, worktext[-(1:(textstart))])
    }
  }
}

@
Wenn der Schalter [[code.style]] auf "normal" gesetzt ist, wird jeder Chunk per [[weaveR]] formatiert.
Für die Stellung "simple" werden alle Code Chunk Namen entfernt, sofern die Namen leer sind und im Code
keine Modulverwendung gefunden wird. Als dritte Stellung führt "console" zu einer Darstellung, bei der
der Code Name entfernt wird, die erste Code-Zeile wird mit einem [[">"]] und die übrigen mit einem 
[["+"]]-Zeichen versehen. 
<<entferne oder formatiere Code-Chunk>>=
# worktext[LINE] <- paste("<","<*>",">=",sep="")
code.style <- "simple" # or "console" or "normal"
if( LINE <= CODE.END ){
  if(!ECHO){
    worktext <- worktext[-(LINE:CODE.END)]
  } else {
    if(code.style == "console"){
      # remove code chunk name line and ">" followed by "+" in front of the code lines
      worktext[LINE] <- "\\begin{verbatim}"
      if(LINE   < CODE.END) worktext[LINE+1] <- paste(">",worktext[LINE+1],sep=" ")
      if(LINE+1 < CODE.END) {
        idx <- (LINE+2):CODE.END
        h <- paste("+",worktext[idx],sep=" "); h <- sub("^[+] *$"," ",h)
        worktext[idx] <- h
      }
      worktext[CODE.END] <- paste(worktext[CODE.END],"\\end{verbatim}",sep="\n")
    }
    # no code chunk name and empty code chunk
    if( code.style == "simple" && 
        0 < (h <- length(grep(paste("<","<[ \t]*>",">",sep=""),worktext[LINE]))) && LINE == CODE.END )
      code.style <- "simple console"
    # no code chunk name and no used code chunks within code
    if( code.style == "simple" && 0 < h && LINE < CODE.END &&
        0 == length(grep(paste("<","<.*>",">",sep=""),worktext[(LINE+1):CODE.END])) ) 
      code.style <- "simple console"
    if(code.style == "simple console"){ 
      # remove code chunk name line and only one ">"
      worktext[LINE] <- "\\begin{verbatim}"
      if(LINE   < CODE.END) worktext[LINE+1] <- paste(">",worktext[LINE+1],sep=" ")
      if(LINE+1 < CODE.END) {
        idx <- (LINE+2):CODE.END; worktext[idx] <- paste(" ",worktext[idx],sep=" ")
      }
      worktext[CODE.END] <- paste(worktext[CODE.END],"\\end{verbatim}",sep="\n")
    }
  }
}
# worktext <- worktext[-LINE]

@
Falls einmal der letzte R-Output aus Mutterfile entfernt werden soll, hilft folgender Chunk:
<<unused: Trash R Output>>=
  melde("231 ...TrashROutput",2)
  line.next <- if(i.chunk<length(chunk.set)) match(chunk.set[i.chunk+1],worktext) else length(worktext)+1
  out.end  <- sort(c(grep("^output-end",worktext),grep("^\\\\end[{]verbatim[}]",worktext)))
  out.end  <- out.end[line < out.end & out.end < line.next][1]
  if(!is.na(out.end)){ 
    out.start <- sort(c(grep("^output-start",worktext),grep("^\\\\begin[{]verbatim[}]",worktext)))
    out.start <- out.start[line < out.start & out.start < line.next & out.start < out.end][1]
    if(!is.na(out.start)){
      if("@"==worktext[out.start-1]) out.start<-out.start-1
      if(""==worktext[out.start-1]) out.start<-out.start-1
      if(""==worktext[out.start-1]) out.start<-out.start-1
      trash<-worktext[out.start:out.end]
      worktext<-worktext[-(out.start:out.end)]
    }
  }

@
Falls einmal das letzte R-Bild aus Mutterfile entfernt werden soll, hilft folgender Chunk:
<<unused: Trash picture of report>>=
  melde("221 ...Trash picture",1)
  # look for picture to be removed
  line.next <- if(i.chunk < length(chunk.set)) 
                 match(chunk.set[i.chunk+1],worktext) else length(worktext)+1
  out.start <- grep("\\\\includegraphics.*[{].*[0-9][}]",worktext)
  out.start <- out.start[line < out.start & out.start < line.next][1]
  #  out.start <- grep("^ *\\\\begin[{]center[}]\\\\includegraphics.*[{]p20.*\\\\end[{]center[}]",
  #              worktext) #}
  #  out.start <- grep("\\\\includegraphics.*[{].*weave-pic-",worktext) #}
print(222); cat("out.start,line,line.next",out.start,line,line.next); cat("Zeile",worktext[out.start])
  if(!is.na(out.start)){ 
    # extract name of plot
    picname <- sub("^.*includegraphics.*[{]","",worktext[out.start])  
    picname <- sub("\\}.*$","",picname) 
    # delete files 
    f.vec <- list.files(pattern=picname)
    if(0<length(f.vec)) {
      for(pic in f.vec) { cat("file",pic,"deleted"); file.remove(pic) }
    }
    # remove link lines from text
         out.end <- out.start 
         if(1==length(grep("p..img src..p2", worktext[out.start+1]))) out.end <- out.start+1
         if(1==length(grep("p..img src..p2", worktext[out.start+2]))) out.end <- out.start+2  
         if("@"==worktext[out.start-1] & "@"==worktext[out.start-2])  out.start<-out.start-1
print(2254); print(worktext[(out.start:out.end)]); cat("picname",picname)
         worktext<-worktext[-(out.start:out.end)]
       }
melde("...Trash picture",2)

@
<<unused: lösche alle Bilder, sofern mindestens ein neues erstellt werden soll>>=
if(0 < length(grep("^<<.*fig *[0] *TRUE",chunk.set))){  # remove all pictures if any new will be generated
    pic.lines.set <- grep("^ *\\\\begin[{]center[}]\\\\includegraphics.*[{]p20.*\\\\end[{]center[}]",
                          worktext) #} 
    if(0 < length(pic.lines.set)) {
      for(LINE in rev(pic.lines.set)){
        out.start <- LINE
        # extract name of plot
        picname <- sub("^.*includegraphics.*[{]p[2]","p2",worktext[out.start])  
        picname <- sub("\\}.*$","",picname) 
        if(0==length(grep("^p[2].*[0-9][0-9]",picname))){ next }
        # delete files 
        f.vec <- list.files(pattern=picname); if(0==length(f.vec)) { next }
        for(pic in f.vec) { cat("file",pic,"deleted"); file.remove(pic) }
        # remove link lines from text
        out.end <- out.start 
        if(1==length(grep("p..img src..p2", worktext[out.start+1]))) out.end <- out.start+1
        if(1==length(grep("p..img src..p2", worktext[out.start+2]))) out.end <- out.start+2  
        worktext<-worktext[-(out.start:out.end)]
      }
    }
}

@
<<unused>>=
# get code of chunk -- copied from EvalRCode
code.start<-grep(paste("^<","<.*>",">=",sep=""),worktext)
code.start<-code.start[code.start<=line]
melde(paste(220,"code.start",code.start),2)
if(0<length(code.start)){
  <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
} 

@
------------------------------------------------------------------------------------------
<<definiere Kopf-Zeilen-Funktionen>>=
RunStart<-function(){
  melde("RunStart",1)
  news<-paste("RunStart:",date(),"\n")
  <<schreibe [[news]] ans Ende des Outputfeldes>>
  news<-paste("\n@\n@<<RunStarts>>=\n@<<start>>\n@")
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  tkmark.set(tworkwin,"insert","end")
  fWarnEval()
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  h<-grep("RunStart",worktext)
  if(0<length(h)) worktext<-worktext[1:(rev(h)[1]-2)] ## 060310
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("RunStart",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[playground]]}
\paragraph{[[playground]] opens a Textwidget for testing R code.}
Die Funktion [[PLAYGROUND]] setzt im [[Edit]]-Menü den Punkt Playground um.
Sie ruft nur die Funktion [[playground]] des Paketes mit der Umgebung 
[[revive.env]] auf.
<<definiere Kopf-Zeilen-Funktionen>>=
PLAYGROUND<-function() playground(revive.env)

@
Jan 2012: ALT-E für evaluiere R-Code sollte für Freunde der Tastatur gehen. Aus Parallelität wurde "ACTIVIERE" in 
"EVALUATE" umbenannt. ALT-Q für Quit ist jedoch ungeeignet, da damit der Klammeraffe erzeugt wird.
Die Logik für das CLIPBOARD ist angepasst entnommen von: [[<definiere Report-Text-Frame>]].
<<*>>=
playground<-function(playground.envir=NULL,code=NULL){
  require(tcltk)
  pg<-tktoplevel(); tkwm.geometry(pg,"+100+100")
  tkwm.title(pg, "playground for testing R code (error messages appear in the R Console)")
  pgtext<-tktext(pg,height=19,background="#f7fffF",
                 font="-Adobe-courier-Medium-R-Normal--18-180-*")
  ## ok: tkbind(pgtext,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")
if(<<OS ist Mac-Mini>> ){
  mac.paste<-function(...){  ## Ctrl-V  # mac-PASTE
     try({.Tcl("clipboard append hello"); .Tcl("clipboard clear")
          news<-base::scan(file=pipe("pbpaste","r"),what="",sep="\n",blank.lines.skip=FALSE)
          tkinsert(pgtext,"insert",paste(news,collapse="\n"))})
          tksee(pgtext,"insert - 7 lines");  tksee(pgtext,"insert + 7 lines") #090706 
  } 
  tkbind(pgtext,"<Control_L><v>",mac.paste)
  mac.copy<-function(...){  ## Ctrl-C  # mac-COPY
     news<-""
     try(news<-tclvalue(.Tcl("if {[catch {clipboard get}]} {set aa empty} {set aa full}")))
     if(news=="empty") return()
     try({news<-tclvalue(.Tcl("set aaa [selection get -selection CLIPBOARD]"))
          tmp.file.name <- tempfile("rt-tmp")
          base::cat(news,file=tmp.file.name); system(paste("pbcopy < ",tmp.file.name))
          .Tcl("clipboard append hello"); .Tcl("clipboard clear")})
  }
  tkbind(pgtext,"<Control_L><c>",mac.copy)
  tkevent.add("@<<extract>>",  "<Control_L><c><KeyRelease>")   # mac-extract
  tkbind(pgtext,"@<<extract>>",mac.copy)
}else{
  tkevent.add("@<<Paste>>",   "<Control_L><v>")
  tkbind(pgtext,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")
}

  pgbutfr<-tkframe(pg)
  tkpack(pgtext, side="top",fill="both",expand="y")
  tkpack(pgbutfr,side="top",fill="both")
  
  bexit<-tkbutton(pgbutfr,text="QUIT",width=9)
  beval<-tkbutton(pgbutfr,text="EVALUATE",width=9)
  tkpack(beval,side="left")
  tkpack(bexit,side="right")

  if(!is.null(code)) try(tkinsert(pgtext,"0.0",paste(code,collapse="\n")))

  eval.code<-function(){
    code<-tclvalue(tkget(pgtext,"0.0","end"))
    code.orig<-code<-unlist(strsplit(code,"\n"))
    if(length(code)==0){ cat("warning: no code found!\n"); return() }    
    if(!is.null(playground.envir)){  ## exists("revive.env") ##
      if(0 < grep("revive.sys", ls(envir=playground.envir))){
        revive.sys <- get("revive.sys",playground.envir)
        <<merke [[code]] für Historie>>   ## stores code in revive.sys
      }
      result<-try(eval(parse(text=code),envir=playground.envir)) 
    }else{ 
      result<-try(eval(parse(text=code),envir=pos.to.env(1)))
    }
    if(class(result)=="try-error"){
      class(result)<-"character"; cat(result,"\n"); return()
    } else { 
      #idx <- which("relax.fns"==search()) # 121214
      #if( 0 < length(idx) ) print <- get("print",pos=idx)
      print(result) 
    }  
    NULL
  }
  tkbind(pg, "@<<EvalRCode>>", eval.code)
  exit.function<-function(){
     tkdestroy(pg)
     return()
  }
  tkconfigure(bexit,command=exit.function)
  tkconfigure(beval,command=eval.code)
  invisible(NULL)
}

@
<<alte Ausgabeverarbeitungen>>=
    ##if(is.null(result)){ cat("warning: output of length 0!\n"); return() }
    ##if(any(is.na(result))){ cat("warning: there are NAs in the output!\n"); return() }
    ##if(is.list(result)&& length(names(result))> 0 && 
    ##                     names(result)[1]=="ID") return()
    ## if(is.list(result)&& TRUE) return()


@
Doppel, vgl. Chunk mit
[[cat("# sorry, chunk number '",no,"' wrong!\n"); return()]]
<<hole chunk Nummer-Doppel>>=
no.start<-grep(paste("^#",no,":$",sep=""),chunks)
no.end<-grep(paste("^#:",no,"$",sep=""),chunks)
if(length(no.end)==0||is.na(no.end) ||is.na(no.start)||
     is.nan(no.end)||is.nan(no.start)){
     cat("# versuchte Chunk-Nummer falsch\n"); return()
}
### cat("# aktueller chunk:",no,"\n")
code<-paste(chunks[no.start:no.end],collapse="\n")
@
\subsubsection{Kopfzeile: [[Edit]] --- [[DeleteAll]]}
\paragraph{[[DeleteAll]] zur Entfernung aller Inhalte aus dem Reportfenster.}
<<definiere Kopf-Zeilen-Funktionen>>=
DeleteAll<-function(){
  melde("DeleteAll",1)
  <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
  worktext<-paste("% New Report:",date(),"\n")
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("DeleteAll",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[UnDo]]}
\paragraph{[[UnDo]] zur Restauration des Reportfensterzustands vor der
letzten Code-Aktivierung.}
<<definiere Kopf-Zeilen-Funktionen>>=
UnDo<-function(){
  melde("UnDo",1)
  if(file.exists("report-UnDo-bak.rev")){
    worktext<-myscan(file="report-UnDo-bak.rev",
                     what="",sep="\n",blank.lines.skip=FALSE)
    <<schreibe [[worktext]] ins Arbeitsfenster>>
  }else{
    cat("ERROR: file report-UnDo-bak.rev not found!!!\n")
  }
  melde("UnDo",2)
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



@
\subsubsection{Reportoperationen --- der lokale {\sc Tangle}-Prozeß}

An dieser Stelle wird der schon in der Definition von [[fWarnEval]]
verwendete {\sc Tangle}-Prozeß definiert.
Besonders in Reports schafft eine Wiederverwertung gegenüber einfachem
Kopieren Übersicht.
Der Quelltext befindet sich auf [[worktext]], expandiert werden muß der
aktuelle Code-Chunk. Das Ergebnis muß auf [[code]] abgelegt werden.
Vorher steht dort gerade der aktuelle Code-Chunk.
<<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>=
melde("vor tangle - Code:\n",3,code)
if(length(grep("@<<(.*)>>",code))>0 || length(grep(">#",code))>0){
  <<bereite Inhalt des Inputs auf>>
  <<initialisiere Variable für Output>>
  <<ermittle Namen und Bereiche der Code-Chunks>>
  melde("vor expand - Code:\n",3,code)
  <<expandiere aktuellen Code-Chunk>>
  <<korrigiere ursprünglich mit @ versehene Zeichengruppen>>
  <<liefere [[code]] ab>>
  melde("nach expand\n",3,code)
}

@
\paragraph{Aufbereitung des Inputs.}
Aus dem Input werden Text-Chunks entfernt und
Definitions- und Verwendungszeilen gekennzeichnet.
<<bereite Inhalt des Inputs auf>>=
<<entferne Text-Chunks>>
<<substituiere mit @ versehene Zeichengruppen>>
<<stelle Typ der Zeilen fest>>

@
[[code.ch]] enthält die isolierten Code-Chunks.
[[code.n]] zeigt die aktuelle Zeilenzahl von [[code.ch]] an.
Text-Chunks beginnen mit einem [[@]], Code-Chunks enden mit der
Zeichenfolge [[>]][[>=]]. Es werden
die Nummern der ersten Zeilen der Code-Chunks auf [[code.a]] abgelegt.
[[code.z]] zeigt den Beginn von Text-Chunks an, weiter unten wird diese
Variable die letzten Zeilen eines Code-Chunk anzeigen.
Aus der Kumulation des logischen Vektor [[change]],
der die Übergänge hält, lassen sich schnell die Bereiche der
Text-Chunks ermitteln.
Klammeraffen werden für alle Fälle vor TLDs eingebaut. 080310
<<entferne Text-Chunks>>=
code.a    <- grep("^@<<(.*)>>=",worktext)
code.z    <- grep("^@",worktext)
code.z    <- unlist(sapply(code.a ,function(x,y) y[y>x][1], code.z))
if(any(h<-is.na(code.z))) code.z<-code.z[!h]
################
# code.n    <- length(worktext)
# change    <- rep(0,code.n); change[c(code.a ,code.z)]<-1
# code.ch   <- worktext[1==(cumsum(change)%%2)]
## 080311
ind<-rep(0,length(worktext)); copy<-0
for(i in seq(ind)){
  if(i %in% code.z) copy<-0
  if(i %in% code.a) copy<-1
  ind[i]<-copy
}
code.ch   <- worktext[ind==1]
## cat("input-text, Anfaenge, Code.chunks"); print(worktext); print(code.a); print(code.ch)

code.n    <- length(code.ch)

@
<<substituiere mit @ versehene Zeichengruppen>>=
code.ch<-gsub("@@>>","DoSpCloseKl-esc",gsub("@@<<","DoSpOpenKl-esc",code.ch))

@
In dieser Implementation dürfen
vor der Verwendung von Verfeinerungen Anweisungsteile stehen,
ebenso dahinter. Deshalb werden die Zeilen, die [[<<]] enthalten,
aufgebrochen.
Sodann werden die Orte der Definitionen von Code-Chunks
und der Verwendungen festgestellt.
Auf der Variable [[line.typ]] wird
die Qualität der Zeilen von [[code.ch]] anzeigt: [[D]] steht für
Definition, [[U]] für Verwendungen, [[C]] für normalen Code-Zeilen
und [[E]] für externe Verweise.
[[code.ext]] zeigt externe Code-Chunks an.
<<stelle Typ der Zeilen fest>>=
<<knacke ggf.\ Zeilen mit mehrfachen Chunk-Uses>>
line.typ  <-rep("C",code.n)
code.a    <-grep("cOdEdEf",code.ch)
code.ch[code.a]<-substring(code.ch[code.a],8)
line.typ[code.a]<-"D"
code.use    <-grep("uSeChUnK",code.ch)
code.ch[code.use]<-substring(code.ch[code.use],9)
line.typ[code.use]<-"U"
code.ext  <-grep("#<file",code.ch)
line.typ[code.ext]<-"E"
melde("code.ch:",3,code.ch,"\n")
@
<<knacke ggf.\ Zeilen mit mehrfachen Chunk-Uses>>=
code.ch<-gsub("(.*)@<<(.*)>>=(.*)","cOdEdEf\\2",code.ch)
repeat{
  if(0==length(cand<-grep("@<<(.*)>>",code.ch))) break
  code.ch<-unlist(strsplit(gsub("(.*)@<<(.*)>>(.*)",
             "\\1bReAkuSeChUnK\\2bReAk\\3",code.ch),"bReAk"))
}
code.ch<-code.ch[code.ch!=""]
code.n<-length(code.ch)
melde("code.ch:",3,code.ch,"\n")

@
<<old: stelle Typ der Zeilen fest>>=
code.use  <-grep("@<<.*>>[^=]",code.ch)
if(0<length(code.use<-grep("@<<.*>>[^=]",code.ch))){
   code.ch[code.use]<- sub(">>",">>>>\n",code.ch[code.use])
   code.ch<-unlist(strsplit(code.ch,">>\n"))
}
code.ch <- gsub("<<-","BiG<-GiB",code.ch)
code.ch <- unlist(strsplit(code.ch,"<<"))
code.ch <- gsub("BiG<-GiB","<<-",code.ch)
code.n    <-length(code.ch)
code.a    <-grep(">>=",code.ch); code.use <-grep(">>",code.ch)

code.use  <-code.use[is.na(match(code.use,code.a))]
code.ext  <-grep("#<file",code.ch)
line.typ  <-rep("C",code.n)
line.typ[code.a]<-"D"; line.typ[code.use]<-"U"; line.typ[code.ext]<-"E"

@
\paragraph{Ermittlung der Code-Chunks.}
Zur Erleichterung für spätere Manipulationen werden in den Bezeichnern die
Zeichenketten [[<<]], [[>>]] und [[>>=]] entfernt.
Die Zeilennummern der Anfänge von Code-Chunks bezüglich [[code.ch]]
stehen auf [[code.a]], die Enden auf [[code.z]].
<<ermittle Namen und Bereiche der Code-Chunks>>=
def.names<-code.ch[code.a]
use.names<- if(length(code.use)>0) code.ch[code.use] else NULL
code.z<-c(if(length(code.a)>1) code.a[-1]-1, code.n)
code.ch<-paste(line.typ,code.ch,sep="")
melde("code.ch:",3,code.ch,"\n")

@
<<old: ermittle Namen und Bereiche der Code-Chunks>>=
code.ch[code.a]  <- unlist(lapply(strsplit(code.ch[code.a],">>="),"[",1))
def.names        <- substring(code.ch[code.a],2)
if(length(code.use)>0){
  code.ch[code.use]<- unlist(lapply(strsplit(code.ch[code.use],">>"),"[",1))
  use.names        <-substring(code.ch[code.use],2)
} else { use.names <- NULL }
code.z             <-c(if(length(code.a)>1) code.a[-1]-1, code.n)

@
\paragraph{Initialisierung des Outputs.}
Auf [[code.out]] werden die fertiggestellten Code-Zeilen abgelegt.
Diese Variable muß initialisiert werden.
<<initialisiere Variable für Output>>=
code.out<-"##act:##"

@
\paragraph{Expansion des aktuellen Code-Chunk.}
Es gilt, den letzten Code-Chunk zu expandieren.
Dazu wird der aktuelle Chunk gesucht und auf dem
Zwischenspeicher [[code.stack]] abgelegt.
Dann werden normale Code-Zeilen
auf die Output-Variablen übertragen, und Verfeinerungsverwendungen werden
auf [[code.stack]] durch ihre Definitionen ersetzt.
Anfänger zeigen manchmal elementare Probleme auf.
So ist das Problem ungewollter Rekursionen erstmals
in einem Kurs aufgefallen. Zu seiner Verhinderung kann
prakmatisch die Verschachtelungstiefe begrenzt werden.
Die Variable [[line]] muss bereits bekannt sein!
Eine erneute Bestimmung der Cursormarke ist falsch, da 
[[worktext]] bereits überarbeitet ist!
<<expandiere aktuellen Code-Chunk>>=
melde("bearbeite aktuellen Chunk\n",3)
###<bestimme Cursorzeile [[line]] von [[tworkwin]]> not a good idea###
ch.no<-length(grep("^@<<(.*)>>=",worktext[1:line]))

rows      <-c((code.a[ch.no]+1),code.z[ch.no])
if(all(!is.na(rows))&&rows[1]<=rows[2]){
  rows<-rows[1]:rows[2]
  code.stack<-code.ch[rows]
  max.depth.refinements<-500; i<-1
  repeat{
     if((i<-i+1)>max.depth.refinements){ 
         cat("ERROR: maximal number of expandations (",max.depth.refinements,
             ") exceeded\n --- perhaps a unintended recursion ???")
         return()
     }
     <<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>
  }
}
if(length(code.ext)>0){
  <<expandiere externe Verfeinerungen>>
}
code.out<-c(code.out,"##:act##")

@
Falls [[code.stack]] leer ist, ist nichts mehr zu tun. Andernfalls
wird die Anzahl der aufeinanderfolgenden Codezeilen festgestellt
und auf die Output-Variable übertragen. Falls die nächste keine
Codezeile ist, muß es sich um die Verwendung einer Verfeinerung handeln.
In einem solchen Fall wird die nächste Verfeinerung
identifiziert und der Bezeichner der Verfeinerung wird durch seine Definition
ersetzt.
<<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>=
if(0==length(code.stack))break
typ<-substring(code.stack[1],1,1)
if("C"==typ||"E"==typ){
  n.lines<-sum(cumprod("C"==substring(code.stack,1,1)))
  code.out<-c(code.out, substring(code.stack[1:n.lines],2))
  code.stack<-code.stack[-(1:n.lines)]
}
if(length(code.stack)>0 && "U"==substring(code.stack[1],1,1)){
  if(any(found<-def.names==substring(code.stack[1],2))){
    found<-seq(along=def.names)[found]; rows<-NULL
    for(no in found){
      if((code.a[no]+1)<=code.z[no]) rows<-c(rows,(code.a[no]+1):code.z[no])
    }
    code.stack<-c(code.ch[rows],code.stack[-1])
    melde("found",0,found)
  }else{code.stack<-code.stack[-1]}
}

@
<<expandiere externe Verfeinerungen>>=
code.out<-code.out[code.out!=""]
code.ext<-rev(grep(">#",code.out))
found<-TRUE
repeat{
  <<beende Schleife, falls keine externen Verfeinerungen zu finden>>
  <<gehe im Fehlerfall zur nächsten externen Verfeinerung>>
  found<-TRUE
  <<ermittle Dateinamen und Chunkbeschreibung>>
  <<falls Chunkbeschreibung ein Name, suche Chunknummer>>
  <<lese Datei mit Code-Chunks>>
  <<extrahiere externen Code>>
  <<lege Code auf Ergebnisvariablen ab>>
  <<gehe zur nächsten externen Verfeinerung>>
}

@
<<beende Schleife, falls keine externen Verfeinerungen zu finden>>=
if(length(code.ext)==0) break

@
Falls die Suche ergebnislos verläuft --- dieses führt (s.u.) in einem
Schleifendurchgang zur Anweisung [[next]] und damit zum folgenden
Code-Chunk ---, wird eine Fehlermeldung ausgegeben. Trotzdem wird
die Weiterverarbeitung fortgesetzt, auch wenn dies oft nicht mehr
sinnvoll sein dürfte.
<<gehe im Fehlerfall zur nächsten externen Verfeinerung>>=
if(!found){
  code.out[code.ext[1]]<-paste("# ??",code.out[code.ext[1]])
  cat("ERROR: External Chunk",code.out[code.ext[1]],"not found!!!\n")
  code.ext<-code.ext[-1]
}

@
Für den Zugriff auf den externen Code wird der Dateiname [[ext.name]]
ohne Endung und die Bezeichnung des Chunk [[ext.chunk]] festgestellt.
<<ermittle Dateinamen und Chunkbeschreibung>>=
ext.name <- rev(unlist(strsplit(code.out[code.ext[1]],"#<file:")))[1]
ext.name <- unlist(strsplit(unlist(strsplit(ext.name,">#"))[1],":"))
ext.chunk<-ext.name[2]; ext.name <-ext.name[1]
ext.name.n<-nchar(ext.name)
if(ext.name.n >4 && ".rev"==substring(ext.name,ext.name.n-3,ext.name.n)){
  ext.name<-substring(ext.name,1,ext.name.n-4)
}

@
Ein externer Code-Chunk kann
durch einen Namen oder eine Chunknummer beschrieben
sein. Im Falle eines Namens wird der [[*.rev]]-File gelesen und aus diesem
die Nummer ermittelt.
<<falls Chunkbeschreibung ein Name, suche Chunknummer>>=
if(is.na(as.numeric(ext.chunk))){
  # tld untersuchen
  filename<-paste(ext.name[1],".rev",sep="")
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"for expansion of code chunk not found!!!\n")
    ext.file<-"Error"
  }else{
    ext.file<-try(myscan(file=filename,what="",sep="\n"))
  }
  if("Error"==substring(unlist(ext.file)[1],1,5)){
    found <-FALSE; next
  }
  ext.file <-ext.file[grep("^@<<(.*)>>=",ext.file)]
  if(!is.null(ext.file)){ found<-FALSE; next }
  ext.chunk<-grep(ext.chunk,ext.file)
}

@
Die [[*.R]]-Datei wird gelesen ...
<<lese Datei mit Code-Chunks>>=
filename<-paste(ext.name[1],".R",sep="")
if(!file.exists(filename)){
  cat("Warning: file",filename,"not found!!!\n")
  cat("         file",filename,"is now generated!!!\n")
  try(tangleR(ext.name[1]))
}
if(!file.exists(filename)){
  ext.file<-"Error"
}else{
  ext.file<-try(myscan(file=filename,what="",sep="\n"))
}
if("Error"==substring(unlist(ext.file)[1],1,5)){
  found <-FALSE; next
}

@
%%%%%%%%%%%%%%%%  aus rw.rev uebernommen -- notwendig ANFANG
<<unused: generiere zur Datei [[filename]] zugehörige [[R]]-Datei>>=
melde(paste(filename,"nicht gefunden!"),3)
worktext<-REVFILE
if(length(grep("^@<<(.*)>>=",worktext))>0){
  <<entferne Text-Chunks>>
  <<trage Sektionsnummernverweise ein>>
  <<stelle Typ der Zeilen fest>>
  code.out<-NULL
  <<ermittle Namen und Bereiche der Code-Chunks>>
}
melde("bearbeite aktuellen Chunk\n",3)
code.stack<-c("Ustart","U*")
repeat{
  <<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>
}
<<schreibe [[code.out]] nach Endbehandlung als [[filename]] weg>>

@
Die gefundenen Definitionszeilen werden um die Kommentare, abgegrenzt durch
Newline-Zeichen, verlängert. Eine Datei-Schreibe-Lese-Operation wertet
die Trennzeichen aus.
<<unused: trage Sektionsnummernverweise ein>>=
sec.z<- grep(">>=",code.ch); sec.z.start<-grep("@<<start>>=",code.ch)
sec.no<-seq(along=sec.z);    sec.no[!is.na(match(sec.z,sec.z.start))]<-0
if(0<length(sec.z)){
  h<-c(sec.z[-1]-1,length(code.ch))
  code.ch[sec.z]<-paste(code.ch[sec.z],"\n#", sec.no,":\n",sep="")
  code.ch[h    ]<-paste(code.ch[h    ],"\n#:",sec.no,"\n", sep="")
}
cat(code.ch,sep="\n",file=<<tmp>>)
code.ch<-myscan(file=<<tmp>>,what="",sep="\n")

@
Ist das Startmodul auf mehrere Code-Chunks verteilt, müssen
überflüssige ([[#0:]], [[#:=]])-Paare entfernt werden. Gleiches gilt für
Zeilen der Form (Leerzeichen, Zahl, [[:]], Leerzeichen), die bei dem
lokalen Tangle-Prozeß entstehen.
<<unused: schreibe [[code.out]] nach Endbehandlung als [[filename]] weg>>=
no<-grep("#0:",code.out)
if(1<length(no)){
  no<-no[-1]
  code.out<-code.out[-c(no,rev(grep("#:0$",code.out))[-1])]
}
no<-grep(": $",code.out)
if(0<length(no)){
  code.out<-code.out[-no]
}
try(cat(code.out,sep="\n",file=filename))

@
%%%%%%%%%%%%%%%%  aus rw.rev uebernommen -- notwendig ENDE

@
... und der gesuchte Code extrahiert.
<<extrahiere externen Code>>=
ext.chunk<-as.numeric(ext.chunk)
a        <-grep(paste("#", ext.chunk,":",sep=""),ext.file)[1]
z        <-grep(paste("#:",ext.chunk,    sep=""),ext.file)[1]
if(is.na(a)){
  found <- FALSE; next
}
if(a<=z) ext.file <-ext.file[a:z]

@
Der gefundene Code wird auf der Ergebnisvariablen [[code.out]] abgelegt.
<<lege Code auf Ergebnisvariablen ab>>=
code.out <-c(code.out[1:(code.ext[1]-1)], ext.file,
             if(length(code.out)>(code.ext[1]+1))
               code.out[(code.ext[1]+1):length(code.out)]
           )

@
Nachdem der externe Link abgearbeitet ist, kann der Stapel der externen
Verweise [[code.ext]] verkürzt werden.
<<gehe zur nächsten externen Verfeinerung>>=
code.ext<-code.ext[-1]

@
<<korrigiere ursprünglich mit @ versehene Zeichengruppen>>=
code.out<-gsub("DoSpCloseKl-esc",">>",gsub("DoSpOpenKl-esc","<<",code.out))

@
Gemäß den Vorgaben wird der Code zum Schluß auf [[code]] abgelegt.
<<liefere [[code]] ab>>=
melde("Ende Rtangle-last\n",3)
code<-code.out[code.out!=""]
@
%%%%% end of tangling ch.no %%%+++%%%%%

%%%%%%%% hier war vorher der Paperteil !!!!!!!!!!!!!!!!!


@
\section{Dialogorientiertes Arbeiten}
Für Tutorials und andere speziell ausgerichtete wiederbelebbare Papiere
müssen noch einige Spezialitäten implementiert werden: Zum Beispiel gibt es
Papiere mit Dialogelementen. Hierzu werden in der Regel die Funktionen
[[readline]], [[scan]], [[cat]], [[print]] und [[menu]] verwendet.
Damit der hier präsentierte Vorschlag Dialoge innerhalb der eigenen Fensterwelt
abhandeln kann, müssen die genannten Funktionen durch neue
überlagert werden. Zum zweiten unterstellen einige Papiere, daß
Verarbeitungsanweisungen auch über die Variable [[cmds]]
abgesetzt werden können.
Als drittes ist ein Mechanismus nett, mit dem ein Anwender bzw.\ ein
Papier im Kopf\-frame ein eigenes Menü unterbringen kann. Als Beispiel
und als Defaultsetzung wird hier ein völlig rudimentärer Vorschlag
einer Daten- und Funktionsverwaltung für den Anfänger definiert.
Für Unterbrechungen wird die Funktion [[.Return]] geschaffen, mit der
die Abarbeitung erst nach Druck der Taste {\sc Return} vorangeht.
Zum Abschluß wird noch eine Funktion zur Umsetzung von Umlauten
definiert.

@
\subsection{Die Umsetzung von Anweisungen über [[cmds]]}
Die Funktion [[Execute.cmds]] führt die Kommandos: [[s]], [[q]], [[>]],
[[i]] und [[r]] sowie einige andere Dinge aus.
Diese müssen sich in der Umgebung des Anwenders auf [[cmds]] befinden.
Der Mechanismus läuft so: Nach bestimmten Aktionen, nämlich am Ende von
[[fWarnEval]] und am Ende der Initialisierung
von [[relax]], wird das virtuelles Ereignis [[@<<Acticmds>>]] ausgelöst.
Mit diesem Ereignis ist die Funktion [[Execute.cmds]] verbunden,
die dann [[cmds]] analysiert und die dort abgespeicherten Befehle
abarbeitet.
@
<<definiere Bindung zur Abarbeitung von [[cmds]]>>=
Execute.cmds<-function(){
  melde("Execute.cmds",1)
  res<-ls(pattern="^cmds$",envir=revive.env)
  if(length(res)>0){
    cmds<-try(eval(parse(text="cmds"),envir=revive.env))
    if(length(cmds)>0){
      eval(parse(text="cmds<-NULL"),envir=revive.env)
      #repeat{
        <<aktiviere die auf [[cmds]] abgelegten Kommandos>>
      #}
    } else remove(list="cmds",envir=revive.env)
  }
  melde("Execute.cmds",2)
}
tkbind(TopW, "@<<Acticmds>>", Execute.cmds)

@
<<aktiviere die auf [[cmds]] abgelegten Kommandos>>=
melde("beginn repeat",1)
if(length(cmds) == 0) break
cmd <- substring(cmds[1],1,1); choice<-substring(cmds[1],2)
cmds<-cmds[-1]; assign("cmds",cmds,envir=revive.env)
switch(cmd
  ,"s" = {
           <<lese Arbeitsfenster auf [[worktext]] ein>>
           line<-grep("^@<<(.*)>>=",worktext)
           if(class(try(no<-line[as.numeric(choice)]))!="try-error" && !is.na(no)){
	     line<-paste(no[1],"0",sep=".")
	     tkmark.set(tworkwin,"insert",line);fWarnEval()
	     tksee(tworkwin,"end")
	   }
          }
  ,"q" = { Exit() }
  ,">" = {
          news<-paste("\n@\n@<<*>>=\n",choice,"",sep="")
          <<schreibe [[news]] ans Ende des Arbeitstextes>>
           tkmark.set(tworkwin,"insert","end");fWarnEval()
	   tksee(tworkwin,"end")
	 }
  ,"p" = {
          bildname <- choice
          f<-function() { 
            <<lege Bild unter [[bildname]] ab>> 
            # include links
            if(!is.null(bildname)&&nchar(bildname)>0){
              <<lese Arbeitsfenster auf [[worktext]] ein>>
              <<schreibe [[news]] hinter aktuellen Chunk>>
              melde(paste("p", psname), "cmd.msg")
            }
          }; f()
         }
  ,"r" = {
          choice<-gsub(" ","",choice)
          if(!file.exists(choice)){
            cat("ERROR:",choice,"not found!!!\n")
            ok<-FALSE
          }else{
            filename<-choice
            try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
            <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
          }
          if(ok){
              <<aktualisiere Reportname>>
              try.res<-WinToTcl.read(try.res)
                ## Eintrag mit Entfernung des bisherigen Inhalts:
                ## worktext<-paste(try.res, collapse="\n")
                ## @<<schreibe [[worktext]] ins Arbeitsfenster>>
              news<-c("",try.res)
              <<schreibe [[news]] ans Ende des Arbeitstextes>>
              <<lese Arbeitsfenster auf [[worktext]] ein>>
              <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
              RunStart()
              <<aktualisiere Texthervorhebungen>>
              <<kreiiere Bilder neu und zeige sie im Textfenster an>>
	      melde(paste("r", filename), "cmd.msg")
              Execute.cmds()
	  } else { cat("ERROR: file not found!!!\n") }
         }
)

@
<<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>=
melde("event wird generiert",3)
tkevent.generate(TopW,"@<<Acticmds>>")

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Die Überlagerung von Input- und Outputfunktionen}
Wird während der Arbeit mit dem Manager eine Eingabe verlangt, ist der
sicherste Weg, dem Anwender ein kleines Fenster zur Eingabe anzuzeigen.
Eine Eingabeauf\-forderung in dem normalen R-Fenster dürfte verwirren,
da das R-Fenster irgendwo im Hintergrund verborgen sein kann.
Entsprechendes gilt für die Ausgabefunktionen.
Deshalb werden in diesem Abschnitt Funktionen bereitgestellt, die
denselben Namen besitzen wie ihre R-Gegenstücke.
Damit diese Ersatzfunktionen auch wirksam werden, werden sie in
die Umgebung kopiert, in der sich auch die Evaluation der Anwenderanweisungen
zuträgt.

@
Im Laufe der Zeit wurde verschiedene Wege gesucht, um modifizierte 
Output-Funktionen so bereitzustellen, dass sie während einer Evaluierung 
gefunden werden konnten. Elegant schien bspw.\ die Einrichtung einer eigenen
Umgebung mit deren Platzierung auf dem Suchpfad zu sein. Dieses Vorgehen 
wurde jedoch ab R-2.16 als unakzeptabel betrachtet, so dass nun eine
Definition der betreffenden Funktionen mit einem Export innerhalb des 
Paketes erfolgt und keine dynamische Bereitstellung stattfindet.
Hierzu ist es erforderlich:
  * die Funktionen neu zu definieren: einige Initialisierungen umzusetzen.
  * Auskommentierung der assign-Statements
  * die Funktionen zu exportieren
   * jeweils eine Hilfeseite bereitzustellen
  * die Hilfeseite in dorx zu generieren
  * dorx neu generieren

@  
Der folgende Chunk fasst die Definition der Überlagerungsfunktionen zusammen:
  * str, cat, print, menu, readline, scan, step, ? myhead.menu, set.tclvalue, melde
<<*>>=
<<definiere exportierte Überlagerungsfunktionen>>

@  
Zur Initialisierung der Überlagerungsfunktionen findet folgender Chunk 
Verwendung:
<<initialisiere Variablen für spezielle Output-Funktionen>>=
# for str, cat, ... it is necessary that revive.sys and revive.env exists
revive.sys <- "noenv"
if (!exists("revive.env")) revive.env <- "noenv"
if (is.environment(revive.env))
    revive.sys <- get("revive.sys", envir=revive.env)
# dummy function used in chunk to append info to output widget
melde <- function(...) {"relax"} 
# cat("revive.env"); print(revive.env); cat("revive.sys"); print(revive.sys)


@
\subsubsection{Die Überlagerung von [[readline]]}
Die neue [[readline]]-Funktion soll ein neues kleines Fenster öffnen
und in diesem eine Eingabe verlangen. Über das formale Argument
läßt sich ein kleiner Text als Titel verwenden.
Das Eingabe-Widget wird in ein neues Top-Level-Fenster gepackt.
Als Wirkung für einen {\sc Return}-Druck wird der Fokus neu gesetzt
das Fenster gelöscht, woraufhin [[tkwait.window]]
die weitere Auswertung der Funktion freigibt. Im Rahmen dieser
Beendigungsarbeiten wird ein Vermerk über die Eingabe ins Arbeitsfenster
geschrieben und der Index des gewählten Item ausgegeben.
<<definiere Input/Output-Funktionen old (bis 2011/05)>>=
readlineold  <-  function(prompt=""){
  if(! (<<teste, ob [[relax]] aktiv ist>>) ){
    readline<-get("readline", pos="package:base")
    return(readline(prompt=prompt))
  }
  .newl<-tktoplevel()
  tkwm.title(.newl, "text input"); tkwm.geometry(.newl,"500x200+0+15")
  <<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>
  eline<-tkentry(.newl,textvariable="tvreadline")
  set.tclvalue("tvreadline","")
  lline<-tklabel(.newl,text=prompt)
  tkpack(eline, lline, side="right");         tkfocus(eline)
  twin<-eline; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
  <<hole ggf. [[tworkwin]]>>
  tkbind(.newl,"<Return>",function(){tkfocus(tworkwin);tkdestroy(.newl)})
  tkwait.window(.newl)
  news<-paste("\nreadline Input:\n", (out<-tclvalue("tvreadline")))
  <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  return(out)
}
assign("readline",readline,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("readline saved",3)

@
Es gab unter Linux Konflikte zwischen dem X11-System, wenn sowohl ein 
Plot-Device bearbeitet wurde als auch über readline() eine Info eingefordert wurde.
Deshalb wird ab 05/2011 readline()-Aufrufe über das Informationsaustauschfenster abgewickelt.
<<definiere exportierte Überlagerungsfunktionen>>=
readline<-function(prompt=""){
  <<initialisiere Variablen für spezielle Output-Funktionen>>
  if( !(<<teste, ob [[relax]] aktiv ist>>) ){  ### 111103 # 130408
    readline<-base::readline
    return(readline(prompt=prompt))
  }
  set.tclvalue <- get("set.tclvalue",envir=revive.sys) # 121214
  linfo <- get("linfo",revive.sys)
  linfo.tmp <- get("linfo.tmp",revive.sys)
  einfo.tmp <- get("einfo.tmp",revive.sys)
  TopW <- get("TopW",revive.sys)
  <<hole ggf. [[tworkwin]]>>
  frage <- if(prompt=="") "Input?" else prompt
  set.tclvalue("tvinfo","")
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      input<-tclvalue("tvinfo")
      set.tclvalue("tvreadlinedone",1)
      mess<-paste("relax"); set.tclvalue("tvmess",mess)
    } # end of function
  )
  tkbind(TopW,"<Escape>",function(){ # Esc should not have an effect
      "relax" 
    }
  )
  set.tclvalue("tvreadlinedone",0); tkwait.variable("tvreadlinedone")
  out<-tclvalue("tvinfo")
  if(0<nchar(out)){
    news<-if(prompt!="") prompt else "readline Input:"
    news<-paste("\n",news,"\n", out,sep="")
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  } 
  <<setze Manager nach {\sc Return} in Normalzustand>>
  return(out)
}
## assign("readline",readline,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
## assign("readline",readline, pos=pos.of.relax.fns)
## melde("readline saved",3)

@
Zur Erledigung einer Eingabe mittels readline() oder scan() kann es hilfreich sein, die 
letzten Ausgaben einzublenden. Deshalb wird -- falls relax aktiv ist, in dem Fenster zur
Eingabe der letzte Ausschnitt von Ergebnissen eingeblendet. Ist relax nicht aktiv, 
<<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>=
if(TRUE){ ## exists("running.function") && running.function==#<relax>#){ ### 111103
  <<schreibe Inhalt von [[toutwin]] als Info in ein Message-Widget unter [[.newl]]>>
}else{
  <<schreibe letzte Ausgabe als Info in ein Message-Widget unter [[.newl]]>>
}

@
Zur Information ist es hilfreich, wenn die letzten Dialogfragmente in
dem Widget zur Eingabe eingeblendet werden.
<<schreibe letzte Ausgabe als Info in ein Message-Widget unter [[.newl]]>>=
tkpack(minfo<-tkmessage(.newl,width="1000",justify="left",relief="raised"),
       fill="both",expand="true")
<<lese Arbeitsfenster auf [[worktext]] ein>>
worktext<-worktext[worktext!=""]
line<-rev(grep("^@<<(.*)>>=",worktext))[1]
if(!is.na(line)&length(line)>0) worktext<-worktext[-(1:line)]
line<-grep("^@",worktext)[1]
if(!is.na(line)&length(line)>0) worktext<-worktext[-(1:line)]
if(length(h<-grep("^output", worktext))>0) worktext<-worktext[-h]
if(length(h<-grep("^@", worktext))>0)      worktext<-worktext[-h]
if(length(h<-grep("verbatim",worktext))>0) worktext<-worktext[-h]
if(length(worktext)>0){
  worktext<-rev(rev(worktext)[1:min(20,length(worktext))])
  worktext<-paste(worktext,collapse="\n")
  tkconfigure(minfo,text=worktext)
}

@
<<hole ggf. [[toutwin]]>>=
if(!exists("toutwin"))
  toutwin<-get("toutwin",envir=get("revive.sys",envir=revive.env))
@
<<hole ggf. [[tworkwin]]>>=
if(!exists("tworkwin"))
  tworkwin<-get("tworkwin",envir=get("revive.sys",envir=revive.env))

@
Info über letzte Ausgaben für readline und scan, wenn relax läuft.
<<schreibe Inhalt von [[toutwin]] als Info in ein Message-Widget unter [[.newl]]>>=
tkpack(minfo<-tkmessage(.newl,width="1000",justify="left",relief="raised"))
<<hole ggf. [[toutwin]]>>
news<-strsplit(tclvalue(tkget(toutwin,"0.0","end")),"\n")[[1]]
if(length(news)>10) news<-rev(rev(news)[1:10])
# kaum relevant
if(length(h<-grep("^output", news))>0) news<-news[-h]
if(length(h<-grep("^@", news))>0)      news<-news[-h]
if(length(h<-grep("verbatim",news))>0) news<-news[-h]
if(length(news)>0){
  news<-rev(rev(news)[1:min(20,length(news))])
  news<-paste(news,collapse="\n")
  tkconfigure(minfo,text=news)
}

@
\subsubsection{Die Überlagerung von [[menu]]}
Für eine Auswahl mit der Funktion [[menu]] werden in einem neuen
Top-Level-Fenster mit mitgegebenem Titel die Auswahlpunkte als Elemente
eines [[listbox]]-Widgets zur Auswahl angeboten. Der Menüpunkt [[Exit]]
wird der Liste der Alternativen hinzugefügt. Ein {\sc Return}-Druck schreibt
das Menü und die Auswahlentscheidung ins Arbeitsfenster.
Die Nummer des gewählten Menüpunktes wird wie bei [[menu]] ausgegeben.

@
Aus Sicherheitsgründen: [[revive.sys]] erst holen, dann benutzen.

@
Neueste Erkenntnis: auch unter Windows muss [[tkwait.variable]]
verwendet werden!

<<definiere Input/Output-Funktionen alt>>=
menualt <-function(choices, graphics=FALSE, title=""){
  if(! (<<teste, ob [[relax]] aktiv ist>>) ){
    menu<-get("menu", pos="package:utils")
    return(menu(choices=choices,graphics=graphics,title=title))
  }else{
    TopN<-tktoplevel()
    tkwm.geometry(TopN,"+0+15"); if(title!="")tkwm.title(TopN, title)
    nc<-length(choices<- c(choices, "EXIT"))
    mch<-max(chars<-nchar(choices)); leer<-paste(rep(" ",mch),collapse="")
    choices<-paste(choices, substring(leer,1,mch-chars) )
    escape.brace<-function(text){text<-gsub("\\\\","\\\\\\\\}",text)
      text<-gsub("\\{","\\\\{",text);text<-gsub("\\}","\\\\}",text);text
    }
    choices<-as.character(escape.brace(choices))
    bw<-as.character(max(mch,10+nchar(title)))
    for(item in choices) {
      tkpack(tkradiobutton(TopN,width=bw,anchor="sw",
                           text=item,variable="tvchoice",value=item))
    }
    tkwait.variable("tvchoice")
    ind <- match(tclvalue("tvchoice"), choices)
    choice <- if(ind==nc) "0" else ind
    news<-paste("",
                   paste(paste(c(1:(nc-1),"0"),choices,sep=":"),collapse="\n"),
                   "\nSelection: ",choice, "",sep="")
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
    tkfocus(get("tworkwin",envir=get("revive.sys",envir=revive.env))) # wichtig!!
    tkdestroy(TopN)
    return(as.numeric(choice))
  }
}
assign("menu",menu,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("menu saved",3)

@
050518: Menu.Funktion um Schieber erweitert. 
<<definiere exportierte Überlagerungsfunktionen>>=
menu<-function(choices, graphics=FALSE, title=""){
  <<initialisiere Variablen für spezielle Output-Funktionen>>
  if( !(<<teste, ob [[relax]] aktiv ist>>) ){ # 130408
    menu<-utils::menu
    return(menu(choices=choices,graphics=graphics,title=title))
  }else{
  set.tclvalue <- get("set.tclvalue",envir=revive.sys) # 121214
  TopN<-tktoplevel()
  if(title=="") title<-"select item, press Return (or exit by Esc)"
  tkwm.geometry(TopN,"+0+15"); tkwm.title(TopN, title)
  if(missing(choices)||length(choices)==0) choices<-"relax"
  choices<-paste(seq(choices),": ",choices, sep="")
  nc<-length(choices<- c(choices, "EXIT"))
  scr <- tkscrollbar(TopN, command=function(...)tkyview(tl,...))
  tl<-tklistbox(TopN,height=min(30,length(choices)),width=60,
                selectmode="single",yscrollcommand=
                  function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkpack(tl,side="left",expand="yes",fill="y")
  tkpack(scr,side="left",expand="yes",fill="y")
  set.tclvalue("choice","0"); tkbind(TopN,"<Escape>",function(){tkdestroy(TopN)})
  tkbind(TopN,"<Return>",function(){
     choice<-as.numeric(tkcurselection(tl))+1
     set.tclvalue("choice",choice); tkdestroy(TopN)
  })
  tkwait.window(TopN)
  choice<-tclvalue("choice")
  choice<- if(choice==length(choices)) 0 else as.numeric(choice)
  news<-paste("",paste(choices,collapse="\n"),"\nSelection: ",choice, "",sep="")
  <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  tkfocus(get("tworkwin",envir=get("revive.sys",envir=revive.env))) # wichtig!!
  return(choice)
 }
}
## assign("menu",menu,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
## assign("menu",menu, pos=pos.of.relax.fns)
## melde("menu saved",3)

@
\subsubsection{Die Überlagerung von [[scan]]}
Die Funktion [[scan]] zu überlagern, scheint ein wenig schwieriger zu sein.
Deshalb soll zunächst einmal für den Manager ein ganz einfacher Vorschlag
gemacht werden, der nur die Eingabe von Zahlen oder Zeichenketten über
Tastatur unterstützt, nicht jedoch kompliziertere Strukturen.
<<definiere exportierte Überlagerungsfunktionen>>=
scan<-function(file = "", what = double(), nmax = -1L, n = -1L, sep = "",
             quote = if (identical(sep, "\n")) "" else "'\"",
             dec = ".", skip = 0L, nlines = 0L, na.strings = "NA",
             flush = FALSE, fill = FALSE, strip.white = FALSE,
             quiet = FALSE, blank.lines.skip = TRUE,
             multi.line = TRUE, comment.char = "", allowEscapes = FALSE, 
             fileEncoding = "", encoding = "unknown", text = NA){
    <<initialisiere Variablen für spezielle Output-Funktionen>>
    <<definiere lokale [[scan]]-Funktion>>
    if(file!="" || !is.na(text) || !(<<teste, ob [[relax]] aktiv ist>>) ){ # 130408
      <<realisiere [[scan]] ohne [[tcl]]-Eingabe-Fenster>>
    } else {
      <<realisiere [[scan]] für [[relax]]>>
    }
    worktext
}
## assign("scan",scan,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
## assign("scan",scan, pos=pos.of.relax.fns)
## melde("scan saved",3)

@
Beachte: [[scan]] ist versionsabhängig! Ebenso: [[local.scan]]
<<definiere lokale [[scan]]-Funktion>>=
scan<-get("scan",pos="package:base")

@
Zur Unterscheidung der Aufrufe muss die Situation ausgewertet werden. 
Mit der passenden Argumentenliste ist dann die Funktion [[base::scan]] 
aufzurufen.
% file.encoding ab R-2.12.0, und text ab R-2.14.0 
<<realisiere [[scan]] ohne [[tcl]]-Eingabe-Fenster>>=
scan.args <- list(file=file,what=what)
if(!missing(nmax)) scan.args <- c(scan.args, list(nmax=nmax))
if(!missing(n))    scan.args <- c(scan.args, list(n=n))
scan.args <- c(scan.args, 
               list(sep=sep,quote=quote,dec=dec,skip=skip,                  
                  nlines=nlines,na.strings=na.strings,
                  flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                  blank.lines.skip=blank.lines.skip,
                  multi.line = multi.line, comment.char = comment.char,
                  allowEscapes = allowEscapes))
if(paste(version$major,version$minor) > "212"){
  scan.args <- c(scan.args, list(fileEncoding = fileEncoding))
}
scan.args <- c(scan.args, list(encoding = encoding))
if(paste(version$major,version$minor) > "214"){
  scan.args <- c(scan.args, list(text=text))
}
worktext <- do.call(scan, scan.args)

@
<<old realisiere [[scan]] ohne [[tcl]]-Eingabe-Fenster>>=
if(paste(version$major,version$minor) > "214"){
  if(!is.na(text)){
    if(!missing(n))
      worktext<-scan(file=file,what=what,n=n,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes,  fileEncoding = fileEncoding,
                 encoding = encoding, text = text
                 )
    else
      worktext<-scan(file=file,what=what,nmax=nmax,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes,  fileEncoding = fileEncoding,
                 encoding = encoding, text = text
                 )
  }
  if(!missing(n))
    worktext<-scan(file=file,what=what,n=n,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes,  fileEncoding = fileEncoding,
                 encoding = encoding
                 )
  else
    worktext<-scan(file=file,what=what,nmax=nmax,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes,  fileEncoding = fileEncoding,
                 encoding = encoding
                 )
} else {
  if(!missing(n))
    worktext<-scan(file=file,what=what,n=n,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes, 
                 encoding = encoding
                 )
  else
    worktext<-scan(file=file,what=what,nmax=nmax,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip,
                 multi.line = multi.line, comment.char = comment.char,
                 allowEscapes = allowEscapes, 
                 encoding = encoding
                 )
}

@
Für relax werden nicht alle Argumente umgesetzt.
<<realisiere [[scan]] für [[relax]]>>=
set.tclvalue <- get("set.tclvalue",envir=revive.sys) # 121214
outfont.sys <- get("outfont.sys",envir=revive.sys) # 121214
typ<-if(is.numeric(what)) "Zahlen-Eingabe" else "Text-Eingabe"
.newl<-tktoplevel(); tkwm.title(.newl, typ); tkwm.geometry(.newl,"+0+15")
revive.sys<-get("revive.sys",envir=revive.env)
assign(".newl",.newl,envir=revive.sys)
<<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>
if(!missing(n)&&n==1){
  sp<-"10"; zei<-"1"
  tkbind(.newl,"<Return>",function() set.tclvalue("tvscandone",2))
}else{sp<-"50"; zei<-"3"}
tkbind(.newl,"<Return><Return>",function()set.tclvalue("tvscandone",2))
tscan<-tktext(.newl,width=sp,height=zei)
twin<-tscan; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
bexit<-tkbutton(.newl, text="Exit: end of input")
tkpack(tscan, bexit); tkfocus(tscan)
tkconfigure(bexit,command=function()set.tclvalue("tvscandone",2))
set.tclvalue("tvscandone",0); tkwait.variable("tvscandone")
worktext<-tclvalue(tkget(tscan,"0.0","end"))
<<hole ggf. [[tworkwin]]>>
tkfocus(tworkwin); tkdestroy(.newl)
<<verarbeite die [[scan]]-Eingabe>>

@
<<verarbeite die [[scan]]-Eingabe>>=
news<-paste("\nscan-Eingabe:\n",worktext,sep="")
<<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
     worktext<-strsplit(worktext,"\n")[[1]]
worktext<-strsplit(paste(worktext,collapse=" ")," ")[[1]]
worktext<-worktext[worktext!=""]
if(typ=="Zahlen-Eingabe"){
  try.res<-try(as.numeric(worktext))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok) worktext<-try.res else NULL
}

@
\subsubsection{Die Bereitstellung von [[scan]] für eigene Zwecke}
Leider unterscheiden sich die [[scan]]-Funktionen der unterschiedlichen
R-Versionen.
Deshalb für interne Zwecke eine eigene verwendet.
<<definiere Input/Output-Funktionen neu>>=
# myscan<-get("scan",pos="package:base"); formals(myscan)$comment.char<-""
myscan<-function(file,what,sep="\n", blank.lines.skip=FALSE){ readLines(file) } #2.1.0

@
\subsubsection{Die Überlagerung von [[print]]}
Die neue [[print]]-Funktion enthält die Definition einer lokalen
[[print]]-Funktion, deren Body mit dem der [[print]]-Funktion von R
identisch ist. Diese lokale Funktion kommt mit den übergebenen
Parametern zur Anwendung, so daß im R-Fenster die normale Ausgabe erscheint.
Zusätzlich wird sie aufgerufen, um das Ausgegebene auch in der Datei
[[<<tmp>>]] abzulegen. Der Inhalt von [[<<tmp>>]] wird dann ins Arbeitsfenster übertragen.
Frage: base::print gibt x invisible aus, relax-print gibt invisible(NULL) aus. Ist das OK?
Problem: help(mean) erzeugt eine Ausgabe, die mit "print" umgesetzt wird. Wenn wir eine doppelte
Ausgabe machen, wir quasi auch die Hilfe doppelt aktiviert.
<<definiere exportierte Überlagerungsfunktionen>>=
print<-function(x, ...){ # 050614
  <<initialisiere Variablen für spezielle Output-Funktionen>>
  if( <<teste, ob [[relax]] aktiv ist>> && !is.null(x) ){ # 130408
    sink(<<tmp.sink>>); base::print(x, ...); sink()
    news<-paste(# "", # 111123
                paste(scan(file=<<tmp.sink>>,what="",sep="\n"),collapse="\n"),
                "",sep="\n" )
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
    if(all(class(x) != "help_files_with_topic")) base::print(x, ...)
  }  else base::print(x, ...)
  invisible(NULL)
}
## assign("print",print,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
## assign("print",print, pos=pos.of.relax.fns)
## melde("print saved",3)

@
<<testbeispiele für print>>=
print(1:3)
print("asdf")
print(co2[1:5])
print(matrix(4,4,4))
print(list(1,1:2,"asdf"))
print(print)
print(NA)
print(summary(co2))
print(str(1:10))
print(str(co2))
print(str(mean))
print(str(as.data.frame(cbind(1:10,letters[1:10]))))
print(str(list(1:3,letters,list(1,2,3))))

@
\subsubsection{Die Überlagerung von [[cat]]}
Die Struktur von [[cat]] entspricht fast der von
[[print]]. [[cat]] löste jedoch beim internen Tanglen Probleme aus,
so daß es angepaßt werden mußte.
<<definiere exportierte Überlagerungsfunktionen>>=
cat<-function(...,file="",sep=" ",fill=FALSE,labels=NULL,append=FALSE){
  <<initialisiere Variablen für spezielle Output-Funktionen>>
  if(file=="" &&  <<teste, ob [[relax]] aktiv ist>> ){ # 130408
     base::cat(...,file=<<tmp>>,sep=sep,fill=fill,labels=labels,append=append)
     news<-paste( # "\n", # 111123
                 paste(scan(file=<<tmp>>,what="",sep="\n"),collapse="\n"), "", # 111123
                 sep="\n")
     <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
     invisible(NULL)
  }
  base::cat(...,file=file,sep=sep,fill=fill,labels=labels,append=append)
}
# assign("cat",cat,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
# assign("cat",cat, pos=pos.of.relax.fns)
# melde("cat saved",3)

@
Auch [[str]] schreibt direkt auf das Konsolenfenster und muss eingerahmt werden.
Als Alternative könnte für das relax-str eine eigene print-Methode entworfen werden,
so dass die Ausgabe auf diese Print-Methode verlagert wird.
%% definiere Input/Output-Funktionen neu>>=
<<definiere exportierte Überlagerungsfunktionen>>=
str<-function(object,...){
  <<initialisiere Variablen für spezielle Output-Funktionen>>
  if( <<teste, ob [[relax]] aktiv ist>> ){ # 130408
     fname <- <<tmp>>; fname <- gsub("\\\\","/",fname)
     base::cat(file=fname,"")
     if(is.data.frame(object)) 
        base::cat(file=fname,
                  paste("'data.frame':  ", 
                        paste(dim(object)[1],"obs. of",
                              dim(object)[2],"variables:\n")))
     a <- deparse(getS3method("str", "default"))
     a <- gsub("cat[(]", paste("base::cat(file=\"", fname, 
               "\",append=TRUE,", sep = ""), a) # ))
     a <- sub(" str[(]", " mystr(", a) # ))
     mystr <- eval(parse(text = a))
     mystr(object,...)  # 111123
     news <- scan(file = fname,
                  what = "", sep = "\n")
     news <- sub("chr .data.frame.", "", news)
     if(0<length(ind<-grep("^ -",news))) news<-news[-ind]
     ## in data frames additional "List of ?" appear and should be removed
     if(is.data.frame(object) && 0<length(ind<-grep("^List of",news))) news<-news[-ind]
     news<-paste("\n", # date(),
                 paste(news,collapse="\n"),"",sep="\n")
     <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  } else { utils::str(object,...) }
  invisible(NULL)
}
# assign("str",str,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
# assign("str",str, pos=pos.of.relax.fns)
# melde("str saved",3)

@
\subsubsection{Help Pages der Output Funktionen}
<<define-str-help>>=
\name{str}
\alias{str}
\title{ modified version of str for relax }
\description{  compactly display the structure of an arbitrary R object, see help of \code{utils::str}}
\usage{ str(object, ...) }
\arguments{ 
  \item{object}{ R object }
  \item{\dots}{ further arguments }
}
\details{ see help of str (package utils) }
\seealso{ \code{\link{str}} }
\examples{
##
}
\keyword{ IO }
@
<<define-cat-help>>=
\name{cat}
\alias{cat}
\title{ modified version of cat for relax }
\description{Output of objects, see help of \code{base::cat} }
\usage{
cat(..., file = "", sep = " ", fill = FALSE, labels = NULL, append = FALSE)
}
\arguments{
  \item{\dots}{ further arguments }
  \item{file}{ file name }
  \item{sep}{ separator }
  \item{fill}{ for controlling line breaks }
  \item{labels}{ to label lines printed }
  \item{append}{ to append infos to a file}
}
\details{ see help of cat (package base) }
\value{ invisible NULL }
\seealso{ \code{\link{cat}} }
\examples{
##
}
\keyword{ IO }

@
<<define-print-help>>=
\name{print}
\alias{print}
\title{ modified version of print for relax }
\description{ \code{print} prints its argument }
\usage{ print(x, ...) }
\arguments{
  \item{x}{ object to be printed }
  \item{\dots}{ further arguments }
}
\details{ see help of print (package base) }
\seealso{ \code{\link{print}} }
\examples{ ## }
\keyword{ IO }

@
<<define-readline-help>>=
\name{readline}
\alias{readline}
\title{modified version of readline for relax }
\description{ reads a line from the terminal }
\usage{ readline(prompt = "") }
\arguments{
  \item{prompt}{ string printed }
}
\details{ see help of readline (package base) }
\seealso{ \code{\link{readline}} }
\examples{ ## }
\keyword{ IO }

@
<<define-menu-help>>=
\name{menu}
\alias{menu}
\title{modified version of menu for relax }
\description{ \code{menu} presents user some choices for choosing }
\usage{ menu(choices, graphics = FALSE, title = "") }
\arguments{
  \item{choices}{ vector of choices }
  \item{graphics}{ whether a graphics menu should be used }
  \item{title}{ used as title }
}
\details{ see help of menu (package utils) }
\value{ number of selected item }
\seealso{ \code{\link{menu}} }
\examples{ ## }
\keyword{ IO }

@
<<define-step-help>>=
\name{step}
\alias{step}
\title{ modified version of step for relax }
\description{Select a formula-based model by AIC.}
\usage{
step(object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, ...)
}
\arguments{
  \item{object}{ model }
  \item{scope}{ range of model }
  \item{scale}{ used in the definiton of AIC statistic }
  \item{direction}{ mode of search }
  \item{trace}{ printing during running }
  \item{keep}{ filter function }
  \item{steps}{ max number of steps }
  \item{k}{ multiple of number of d.f. for penalty }
  \item{\dots}{ further arguments }
}
\details{ see help of step (package stats) }
\value{ stepwise-selected model is returned ... }
\seealso{ \code{\link{step}} }
\examples{ ## }
\keyword{ IO }

@
<<define-scan-help>>=
\name{scan}
\alias{scan}
\title{ modified version of scan for relax }
\description{ reads data into a vector or a list from console or file }
\usage{
scan(file = "", what = double(), nmax = -1L, n = -1L, sep = "", 
quote = if (identical(sep, "\n")) "" else "'\"", dec = ".", skip = 0L,
nlines = 0L, na.strings = "NA", flush = FALSE, fill = FALSE, 
strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, 
multi.line = TRUE, comment.char = "", allowEscapes = FALSE, fileEncoding = "", 
encoding = "unknown", text = NA)
}
\arguments{
  \item{file}{ file name }
  \item{what}{ type of data }
  \item{nmax}{ max number of data }
  \item{n}{ max number of data }
  \item{sep}{ separator }
  \item{quote}{ set of quoting strings }
  \item{dec}{ decimal point character }
  \item{skip}{ lines of input file to be skipped }
  \item{nlines}{ max number of lines }
  \item{na.strings}{ coding of NA entries }
  \item{flush}{ for ignoring comments }
  \item{fill}{ for adding empty fields }
  \item{strip.white}{ for ignoring leading or trailing blanks }
  \item{quiet}{ if FALSE number of items will be printed }
  \item{blank.lines.skip}{ ignore empty lines }
  \item{multi.line}{ if FALSE: record must be in lines } 
  \item{comment.char}{ character used as comment char }
  \item{allowEscapes}{ how to handle escape sequences }
  \item{fileEncoding}{ file encoding }
  \item{encoding}{ encoding assumed for the input }
  \item{text}{ concerning text connections }
}
\details{ see help of scan (package base) }
\value{ scanned object is returned ... }
\seealso{ \code{\link{scan}} }
\examples{ ## }
\keyword{ IO }
@
R.2.14
function (file = "", what = double(), nmax = -1L, n = -1L, sep = "", 
    quote = if (identical(sep, "\n")) "" else "'\"", dec = ".", 
    skip = 0L, nlines = 0L, na.strings = "NA", flush = FALSE, 
    fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, 
    multi.line = TRUE, comment.char = "", allowEscapes = FALSE, 
    fileEncoding = "", encoding = "unknown", text) 
scan relax
function (file = "", what = double(0), nmax = -1, n = -1, sep = "", 
    quote = "", dec = ".", skip = 0, nlines = 0, na.strings = "NA", 
    flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE, 
    blank.lines.skip = TRUE) 
R.2.15    
function (file = "", what = double(), nmax = -1L, n = -1L, sep = "", 
    quote = if (identical(sep, "\n")) "" else "'\"", dec = ".", 
    skip = 0L, nlines = 0L, na.strings = "NA", flush = FALSE, 
    fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, 
    multi.line = TRUE, comment.char = "", allowEscapes = FALSE, 
    fileEncoding = "", encoding = "unknown", text) 


@
[[step]] schreibt ebenfalls direkt auf das Konsolenfenster und muss eingerahmt werden.
<<definiere exportierte Überlagerungsfunktionen>>=
step.dep<-deparse(stats::step)
# 120828
step.dep<-gsub("cat[(]",   "relax::cat(",   step.dep) # ))  
step.dep<-gsub("print[(]", "relax::print(", step.dep) # ))  
## step.dep<-gsub("cat[(]", 'get("cat",  pos=which(search()=="relax.fns"))(',step.dep) # ))  
## step.dep<-gsub("print[(]", 'get("print",pos=which(search()=="relax.fns"))(',step.dep) # ))  

###step.dep<-gsub("cat[(]", "relax::cat(",step.dep) # ))  
###step.dep<-gsub("print[(]", "relax::print(",step.dep) # ))  
mystep <- eval(parse(text = step.dep))
step<- mystep
## assign("step",mystep,pos=#<stelle Nummer von [[relax]] im Suchpfad fest>#)
## assign("step",step, pos=pos.of.relax.fns)
## melde("step saved",3)

@
<<test>>=
dm<-read.csv2("http://www.wiwi.uni-bielefeld.de/fileadmin/stat/wolf/data/frabo08.csv")
names(dm); df<-dm[1:5]; str(df)
revive.sys<-new.env(); assign("tmp.file.name","hallo",revive.sys)

mstr<-function(object){
        if (is.data.frame(object))
        base::cat(file=get("tmp.file.name", envir = revive.sys),
           paste("'data.frame':  ", 
           paste(dim(object)[1],"obs. of",dim(object)[2],"variables:\n")))
        a <- deparse(getS3method("str", "default"))
        a <- gsub("cat[(]", paste("base::cat(file=\"", get("tmp.file.name",
            envir = revive.sys), "\",append=TRUE,", sep = ""), a) # ))
        a <- sub(" str[(]", " mystr(", a) # ))
        mystr <- eval(parse(text = a))
        mystr(object)
        news <- scan(file = get("tmp.file.name", envir = revive.sys),
            what = "", sep = "\n")
        news <- sub("chr .data.frame.", "", news)
        if(0<length(ind<-grep("^ -",news))) news<-news[-ind]
        if(0<length(ind<-grep("^List of",news))) news<-news[-ind]
        news <- paste("\n", paste(news, collapse = "\n"), "",
            sep = "\n")
   base::cat(news)
}; mstr(df)

@
<<stelle Nummer von [[relax]] im Suchpfad fest>>=
which(paste("package",<<relax>>,sep=":")==search())

@
<<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>=
<<schreibe [[news]] ans Ende des Outputfeldes>>
tcl("update","idletasks") # 090710
NULL
@
<<OLD: schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>=
if(TRUE){ ## exists("running.function") && running.function==#<relax>#){ ####111103
       <<schreibe [[news]] ans Ende des Outputfeldes>>
}else{
       <<schreibe [[news]] ans Ende des Arbeitstextes>>
}
tcl("update","idletasks") # 090710
NULL

@
Dieser Chunk checked, ob relax aktiv ist. Wenn das der Fall ist, soll eine Ausgabe,
z.B. von cat, print, etc., im relax-Ausgabefenster eingetragen werden. Zunächst sollte
unterschieden werden, ob eine Ausgabe aus dem Arbeitsfenster veranlasst worden ist oder aber
von außerhalb kommt. Schwierigkeiten ergeben sich dadurch, dass ja an verschiedenen Stellen
Fehler-Ausgaben anzuzeigen sind. Aus Gründen der Vereinfachung wird jetzt nur noch 
untersucht, ob toutwin existiert. Wenn das der Fall ist, wird versucht eine Ausgabe ins
Ausgabefenster einzutragen.
% # "1"==tclvalue(tkwinfo("exists",get("toutwin",get("revive.sys",revive.env)))) # 130408
<<teste, ob [[relax]] aktiv ist>>=
(is.environment(revive.env) && 
 "toutwin" %in% ls( pattern="toutwin", envir=r.sys<-get("revive.sys",revive.env)) && "1"==tclvalue(tkwinfo("exists",get("toutwin",r.sys)))) 
@
<<OLD: teste, ob [[relax]] aktiv ist>>=
&& 5 < length(sys.frames())
any(sapply(sys.frames(),function(x) identical(x,revive.env))) 
### ||  any(sapply(sys.frames(),function(x) identical(x,revive.sys))))
any((h<-'tkwait.variable("tvexit")')==substring(sys.calls(),1,nchar(h))) ||
0 < length(grep("revive.env",as.character(sys.calls()) ) )

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@
\subsection{[[myhead.menu]] --- zur Erstellung eines Anwendermenüs im
Kopf\-frame}

In diesem Abschnitt soll eine Funktion beschrieben werden, die einem
Autor eines wiederbelebbaren Papiers die Möglichkeit eröffnet, über
die Kopfzeile eigene Menüs zu erstellen.
Diese Funktion muß bei ihrem ersten Aufruf prüfen, ob bereits das verlangte
Menü vorhanden ist. Falls nicht sind einige Initialisierungsarbeiten zu
absolvieren. Andernfalls ist dem schon existierenden Menü ein
Menüeintrag hinzuzufügen. Durch Setzung der Option [[rm.menu]] auf [[T]]
wird das Menü wieder gelöscht. Die Nummer des Menüs wird über
[[menu.no]] transportiert. Nummer [[0]] ist für die vom System
bereitgestellten Funktionen vorgesehen.
<<definiere [[myhead.menu]]>>=
myhead.menu<-function(item="Test",code=function()cat("Menu-Test"),
                      title="Menue",rm.menu=FALSE,menu.no=1){
  set.tclvalue<-function(name,value)tclvalue(name)<-as.character(value) # 121217
  out.msg<-NULL
  menu.widget.name<-paste("mrtrevive",   menu.no,sep="")
  menu.item.name  <-paste("mmyhead.menu",menu.no,sep="")
  if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
  if( !( <<teste, ob ein [[myhead.menu]] Nummer [[menu.no]] installiert>> )){
    if( rm.menu==TRUE && menu.no!=0){
      tkmessageBox(title="Warnung", icon="warning",
                   message="Achtung:  kein Kopfmenue vorhanden")
      return("Error")
    }
    <<richte [[myhead.menu]] Nummer [[menu.no]] ein>>
  }
  if( rm.menu==TRUE ){
    <<entferne [[myhead.menu]] Nummer [[menu.no]]>>
  }else{
    <<erweitere [[myhead.menu]] Nummer [[menu.no]] um einen Eintrag>>
  }
  return(out.msg)
}
# assign("myhead.menu",myhead.menu, pos=relax.pos) ### 111103
# assign("myhead.menu",myhead.menu, pos=pos.of.relax.fns)

@
<<entferne [[myhead.menu]] Nummer [[menu.no]]>>=
mrtrevive<-get(menu.widget.name,envir=revive.sys)
tkpack("forget",mrtrevive)
tkdestroy(mrtrevive)
remove(list=menu.widget.name,envir=revive.sys)
out.msg<-c(out.msg, paste("Menue im Kopf entfernt!"))

@
<<teste, ob ein [[myhead.menu]] Nummer [[menu.no]] installiert>>=
exists(menu.widget.name,envir=revive.sys)

@
<<richte [[myhead.menu]] Nummer [[menu.no]] ein>>=
fhead<-get("fhead",envir=revive.sys)
mrtrevive<-tkmenubutton(fhead,text=title,
                        font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
assign(menu.widget.name,mrtrevive,envir=revive.sys)
tkbind(mrtrevive,"<Enter>",function() set.tclvalue("tvmess","R cmd menue"))
tkbind(mrtrevive,"<Leave>",<<relax-zeige-Funktion>>)
tkpack(mrtrevive,side="left")
mmyhead.menu<-tkmenu(mrtrevive)
assign(menu.item.name,mmyhead.menu,envir=revive.sys)
tkconfigure(mrtrevive, menu=get(menu.item.name,envir=revive.sys))
out.msg<-c(out.msg, paste("Menue im Kopf eingerichtet!"))

@
<<erweitere [[myhead.menu]] Nummer [[menu.no]] um einen Eintrag>>=
item<-as.character(item[[1]])
mmyhead.menu<-get(menu.item.name,envir=revive.sys)
revive.env <- get("revive.env",envir=revive.sys)
if(is.function(code))  code<-deparse(body(code))
item.code<-function()eval(parse(text=code),envir=revive.env)
tkadd(mmyhead.menu, "command", label=item, command=item.code,
        font=<<Font für Knöpfe>>
)
out.msg<-c(out.msg, paste("Item",item,"im Kopfmenue eingerichtet!"))

@
\subsubsection{Ein Anwendungsbeispiel: Daten- und Funktionswahlunterstützung}

Gerade für den Anfänger ist es schwierig sich an Namen und Syntax von
R-Funktionen zu erinnern. Ähnliches gilt auch für den Fortgeschrittenen
in Bezug auf Datensätze. Ein kleines Werkzeug zur Unterstützung kann
für diese Probleme sehr nützlich sein.
In diesem Abschnitt soll die Entwicklung eines solchen unter
Einsatz der Funktion [[myhead.menu]] vorgeführt werden.
Dieses Menü erhält die Menü-Nummer [[0]].

Zunächst überlegen wir geeignete Funktionalitäten:
\begin{itemize}
\item
Das Instrument soll ein- und zwei-dimensionale Datensätze auf\-listen
\item
und jeweils für diese beiden Objekttypen Methoden anbieten.
\item
Entsprechend den Wünschen sollen dann im Arbeitfeld Eintragungen
angebracht werden, die der Anwender dann starten kann.
\end{itemize}
Damit können wir schon das Menü definieren:
<<definiere Data-Fns-Menü>>=
<<definiere Menüfunktionen>>
data.fns.menu<-function(){
  myhead.menu(rm.menu=TRUE, menu.no=0)
  # myhead.menu(item="load data via internet",code=loadwwwdata, menu.no=0)   # ok
  myhead.menu(item="1-dim data sets",code=get.dim.1.data,title="Data",menu.no=0)    # ok
  myhead.menu(item="1-dim random numbers",code=generate.1.data,menu.no=0) # ok
  myhead.menu(item="2-dim data sets",code=get.dim.2.data,menu.no=0)    # ok
  myhead.menu(item="delete NAs from vector x",code=removenafromvecx,menu.no=0)
  myhead.menu(item="delete NAs from matrix xy",code=removenafrommatxy,menu.no=0)
  myhead.menu(item="save col of matrix xy as x",code=choosecol,menu.no=0)
  myhead.menu(item="1-dim statistics",code=get.dim.1.stats,title="Methods",menu.no=1)   # ok
  myhead.menu(item="1-dim plots",code=get.dim.1.plots,title="Methods",menu.no=1)   # ok
  myhead.menu(item="2-dim methods",code=get.dim.2.methods,menu.no=1)   # ok
}

@
Das größere Problem ist offensichtlich, die Funktionen zu definieren.

@
\paragraph{[[loadwwwdata]].} Für diesen Job gibt es bereits eine
Funktion. [[GetWWWData]].
Für die Datenbeschaffung vom Server wird die Funktion
\begin{quote}
[[GetWWWData()]]
\end{quote}
bereitgestellt. Diese Funktion greift auch
auf dem WWW-Server unter [[~wolf]] auf das Verzeichnis

[[software/revweb/rtrevive/data]] zu.

In diesem Verzeichnis liegen die Objekte in der R-üblichen Form herum.
Datensätze haben einen Namen mit der Endung [[.R]] außerdem gibt
die Datei [[00Contents]] Auskunft über die Datensätze,
indem für jeden Datensatz ein Eintrag {\em (Name Kurzbeschreibung)}
zu finden ist. Für die Auswahl wird hier die Funktion
[[listboxmenu]] beigesteuert.
<<definiere Menüfunktionen>>=
loadwwwdata<-function(){
  GetWWWData<-function(){
    melde("GetWWWData",1)
    URL<-paste("http://www.wiwi.uni-bielefeld.de/fileadmin/stat/wolf/data")
    download.file(paste(URL,"00Contents",sep="/"),"r.tmp")
    choices<-scan(file="r.tmp","",sep="\n")
    <<definiere Funktion [[listboxmenu()]]>>
    choice<-listboxmenu(choices,"gefundene Datensaetze")
    if(0==choice) return() else choice<-sub(" .*$",".R",choices[choice])
    download.file(paste(URL,choice,sep="/"),"www.data.R")
    cmds<-scan(file="www.data.R","",sep="\n")
    ok<-try(eval(parse(text=cmds),envir=revive.env))
    cat("\"",sub(".R$","",choice),"\" geladen\n",sep="")
    melde("GetWWWData",2)
  }
  GetWWWData()
}

@
\paragraph{[[generate.1.dat]].}
<<definiere Menüfunktionen>>=
generate.1.data<-function(){
 (function(){
  DS<-c("sample(99)","sample(99,replace=TRUE)","rnorm(99,mean=0,sd=1)","rexp(99)")
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("x <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
<<definiere ggf.\ myscan>>=
if(!exists("myscan")) myscan<-get("myscan",envir=revive.sys)


@
Hierfür haben wir zwei Code-Chunks zu definieren:
060517
<<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>=
set.tclvalue<-function(name,value)tclvalue(name)<-as.character(value) # 121217
<<definiere Funktion [[listboxmenu()]]>>
choice<-listboxmenu(DS,"Items:")
if(0==length(choice)||is.na(choice)||0==choice) return()
choice<-DS[choice]
<<definiere ggf.\ myscan>>

@
060517
<<schreibe [[cmd]] ins Arbeitsfenster>>=
<<lese Arbeitsfenster auf [[worktext]] ein>>
melde <- get("melde", envir=revive.sys) # 121217
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
last.text<-c(0,grep("^@",worktext)); last.text<-rev(last.text[last.text<=line])[1]
last.code<-grep("^@<<(.*)>>=",worktext)
if(0<length(last.code)){
  last.code<-rev(last.code[last.code<=line])[1]
  if(is.na(last.code)||last.code<last.text)
            {delta<-4; news<-paste("\n@\n@<<*>>=\n",cmd,"\n@\n",sep="") }
  else
                  {delta<-1; news<-paste(cmd,"\n",sep="")}
}else{
            {delta<-4; news<-paste("\n@\n@<<*>>=\n",cmd,"\n@\n",sep="")}
}
<<schreibe [[news]] hinter Cursorzeile>>
tkmark.set(tworkwin, "insert", paste(line+delta,"0",sep="."))

@
\paragraph{[[get.dim.1.data]].} Es sind drei Dinge zu tun:
Beginnen wir mit [[get.dim.1.data]].
\begin{enumerate}
\item
Datensätze ermitteln
\item
die gefundenen Datensätze in einem Menü auf\-listen
\item
entsprechend der getroffenen Wahl im Arbeitsfenster eine
Eintragung vornehmen.
\end{enumerate}
<<definiere Menüfunktionen>>=
get.dim.1.data<-function(){
 (function(){
  <<ermittle eindimensionale Datensätze>>
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("x <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
Mit der Datensatzermittlungsfunktion [[ds]] ist nicht viel zu tun.
<<ermittle eindimensionale Datensätze>>=
<<definiere eine Datensatzsuchfunktion>>
DS<-c( ds.of.R("vector"),ds(-1), ds(1),
           ds(<<stelle Nummer von [[relax]] im Suchpfad fest>>),
           "-5:5 # integers from -5 to 5", "rep(7,5) # vector: (7,7,7,7,7)")

@
Zur Ermittlung von Datensätzen mit die Funktion [[ds]] aber
erst noch definiert werden:
<<definiere eine Datensatzsuchfunktion>>=
ds<-function(pos=1,type,mode="numeric",struc=is.vector){
  if(pos>0){
   obj<-ls(pos=pos)
   obj<-obj[unlist(lapply(obj ,function(o,pos)
     exists(o,where=pos,mode="numeric") &&
     eval(parse(text=paste("struc(get(\"",o,"\",pos=",pos,"))",sep=""))),pos))]
  }else{
   obj<-ls(envir=revive.env)
   obj<-obj[unlist(lapply(obj ,function(o)
     exists(o,where=revive.env,mode="numeric") &&
     eval(parse(text=paste("struc(get(\"",o,"\",envir=revive.env))",sep=""))) ))]
  }
  if(0==length(obj)) return(NULL) else return(obj)
}
ds.of.R<-function(type="vector"){
  dat<-ls(pos=grep("datasets",search()))
  dat.type<-unlist(lapply(dat,function(x) {       
         num<-mode(x<-eval(parse(text=x)))
         num<-ifelse(is.array(x),"array",num)
         num<-ifelse(is.list(x),"list",num)
         num<-ifelse(is.matrix(x),"matrix",num)
         num<-ifelse(is.data.frame(x),"matrix",num)
         num<-ifelse(num=="numeric","vector",num)
         num }))
  return(dat[dat.type==type])
}



@
Die Definition von [[get.dim.2.data]] fällt nun leicht.
<<definiere Menüfunktionen>>=
get.dim.2.data<-function(){
 (function(){
  <<ermittle zweidimensionale Datensätze>>
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("xy <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
<<ermittle zweidimensionale Datensätze>>=
<<definiere eine Datensatzsuchfunktion>>
DS<-c(ds.of.R("matrix"),ds(struc=is.matrix))
DS<-c(DS,"matrix(sample(100),50,2)","cbind(1:100,rnorm(100,mean=0,sd=1))")
DS<-c(DS, ds(-1,struc=is.matrix), ds(1,struc=is.matrix) ,
           ds(<<stelle Nummer von [[relax]] im Suchpfad fest>> ,struc=is.matrix) )

@
Es ist besser, wenn der Anwender eine Reihe spezieller
Hilfsfunktionen für die statistische Arbeit bereitgestellt
bekommt. Solange darüber aber keine Klarheit herrscht,
soll zunächst einmal für die kleinen Jobs nur aus der
Hüfte -- sozusagen als Erinnerungsposten -- die Funktionen
[[remove.na.from.x]] und [[save.matcol.as.x]] bereitgestellt werden.

@
<<definiere Menüfunktionen>>=
removenafromvecx<-function(){
  (function(){
    cmd<-"x<-x[!is.na(x)]"
    <<definiere ggf.\ myscan>>
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}
removenafrommatxy<-function(){
  (function(){
    cmd<-"xy<-xy[!apply(is.na(xy),1,any),,drop=FALSE]"
    <<definiere ggf.\ myscan>>
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere Menüfunktionen>>=
choosecol<-function(){
  (function(){
    <<ermittle zweidimensionale Datensätze>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    <<definiere [[choose.col()]]>>
 cat("choice:",choice)
    if(0==(col.no<-choose.col(choice))) return()
    cmd<-paste("x<-",choice,"[,",col.no,"]",sep="")
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere [[choose.col()]]>>=
choose.col<-function(obj,title="Which variable?"){
  if(is.character(obj)) try(obj<-eval(parse(text=obj)))
  obj <- as.matrix(obj)
  if(!is.matrix(obj)) return(0)
  if(is.null(choices<-dimnames(obj)[[2]])) choices<-1:ncol(obj)
  <<definiere Funktion [[listboxmenu()]]>>
  choice<-listboxmenu(choices,title)
  choice
}

@
<<definiere Funktion [[listboxmenu()]]>>=
listboxmenu<-function(choices,title="items",addexit=TRUE){
    if(addexit) choices<-c(choices,"EXIT")
    lbmTop<-tktoplevel();tkwm.geometry(lbmTop,"+0+15")
    tkwm.title(lbmTop,"Selection by Click and Return, Quit by Esc")
    ltit<-tklabel(lbmTop,text=title); lbframe<-tkframe(lbmTop)
    lb<-tklistbox(lbframe,height=8,width=60); sb<-tkscrollbar(lbframe)
    tkconfigure(lb,yscrollcommand=function(...) tkset(sb,...))
    tkconfigure(sb ,command=function(...) tkyview(lb,...))
    tkpack(ltit,lbframe)
    tkpack(sb,side="right",fill="y"); tkpack(lb)
    for(i in seq(choices)) tkinsert(lb,"end",choices[i])
    lbmdone      <- tclVar()
    tkbind(lbmTop,"<Return>",function()set.tclvalue(lbmdone,"1"))
    tkbind(lbmTop,"<Escape>",function()set.tclvalue(lbmdone,"0"))
    tkfocus(lb); tkwait.variable(lbmdone)
    choice<-tclvalue(tkget(lb,"active")); tkdestroy(lbmTop)
    if(tclvalue(lbmdone)=="0") return(0)
    ind <- match(choice, choices)
    choice <- if(addexit && ind==length(choices)) 0 else ind
    return(choice)
}

@
\paragraph{Zur Methodenauswahl.}
<<definiere Menüfunktionen>>=
get.dim.1.stats<-function(){
  (function(){
    <<definiere eindimensionale Statistiken>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}
get.dim.1.plots<-function(){
  (function(){
    <<definiere eindimensionale Plots>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere eindimensionale Statistiken>>=
methoden  <-c("median of x"       		="median(x,na.rm=TRUE)"
              ,"mean of x"           			="mean(x,na.rm=TRUE)"
              ,"standard deviation of x"         ="sd(x,rm.na=TRUE)"
              ,"variance of x"              		="var(x,na.rm=TRUE)"
              ,"maximum of x"  			="max(x,rm.na=TRUE)"
	      ,"minimum of x"      			="min(x,na.rm=TRUE)"
	      ,"quantiles of x, prob: p"	="quantile(x,p)"
	      ,"range of x"      			="range(x,na.rm=TRUE)"
	      ,"inter quartile range of x"      	="IQR(x,na.rm=TRUE)"
	      ,"5 number summary of x"      	="fivenum(x,na.rm=TRUE)"
	      ,"summary statistics of x"      	="summary(x,na.rm=TRUE)"
	      ,"sorted data of x"      		="sort(x)"
	      ,"ranks of x"      				="rank(x)"
	      ,"sum of x"      		="sum(x)"
	      ,"cumulative sum of x"      		="cumsum(x)"
	      ,"length of x"      		="length(x)"
	      ,"frequency table of x"      		="table(x)"
	      ,"relative frequencies of x"      		="table(x)/length(x)"
	      )
DS<-names(methoden)

<<definiere eindimensionale Plots>>=
methoden  <-c("1 dim plot of x"="plot(x)"
 ,"boxplot of x"              ="boxplot(x)"
 ,"jitterplot of x"              ="plot(jitter(x))"
 ,"histogram of x"              ="hist(x,prob=TRUE)"
 ,"histogram of x, breaks at br"           ="hist(x,breaks=br,prob=TRUE)"
 ,"plot of density trace of x, width w"="plot(density(x,width=w),type=\"l\")"
 ,"barplot of x"              ="barplot(x)"
 ,"barplot of relative frequencies of x"              ="plot(table(x)/length(x))"
 ,"barplot of frequencies h.i at x.i"      ="plot(x.i, h.i, type=\"h\")"
 ,"empirical distribution function  of x"              ="plot(ecdf(x))"
 ,"stem and leaf display of x"="if(exists(\"stem.leaf\")) stem.leaf(x) else stem(x)"
)
DS<-names(methoden)

@
<<definiere Menüfunktionen>>=
get.dim.2.methods<-function(){
  (function(){
    <<definiere zweidimensionale Methoden>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
  })()
}

@
<<definiere zweidimensionale Methoden>>=
methoden  <-c("scatter plot of xy[,1:2]"="plot(xy[,1:2])",
              "correlation of xy" ="cor(xy)",
              "regression line of xy"  ="plot(xy[,1:2])\nabline(lsfit(xy[,1],xy[,2]))",
              "mean values of cols of xy" ="apply(xy,2,mean)"
            )
DS<-names(methoden)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@
\subsection{[[.Return]] --- zur Unterbrechung der weiteren Abarbeitung}
Soll zum Beispiel vor dem Einblenden des nächsten Menüs dem Anwender
die Möglichkeit gegeben werden, einen Plot zu betrachten, so wird
ein Mechanismus zur Unterbrechung benötigt. Hierbei hilft die
(versteckte) Funktionn [[.Return]], die ein kleines Label-Widget öffnet und
auf einen {\sc Return}-Druck wartet.
<<auskommentiert: definiere [[.Return]]>>=
.Return<-function(title="Return!"){
      .newl  <- tktoplevel(); tkwm.geometry(.newl,"+0+15")
      tkpack(tklabel(.newl,text=title))
      tkbind(.newl,"<Return>",function(){
                               tkdestroy(.newl);
			       set.tclvalue("tvscandone",2)
			       })
      tkfocus(.newl); tkwait.variable("tvndone")
}

@
\subsection{Die Transformation von Umlauten}
Leider waren die Vorstellungen unter {\sc dos} und in einem {\sc Tcl}-Fenster
über Umlaute unterschiedlich. Deshalb musste für diese Probleme eine Lösung her.
Mit Windows und Linux hat sich das Umlaut-Problem nicht erledigt, sondern eher 
verschärft. Ursächlich ist die Tatsache, das gespeicherte Zeichen nur dann verstanden
werden, wenn das Encoding, mit dem eine Datei gespeichert wurde, bei der Interpretation
der Zeichen ebenfalls eingesetzt wird. Die beste Lösung besteht sicher darin,
immer das Encoding explizit anzugeben. Dieses Vorgehen versagt jedoch, wenn
mehrere Dateien mit verschiedenen Encodings zusammengefügt worden sind. Dann 
können wir höchstens versuchen (zeilenweise) das Encoding abzuschätzen.
@
Für den Eindruck mag eine Liste von Encodings helfen, wie sie von der Funktion
[[iconvlist()]] ausgegeben wird.
* UCS-4
* UCS-4BE
* UCS-4LE
* UCS-2
* UCS-2BE
* UCS-2LE
* UTF-32
* UTF-32BE
* UTF-32LE
* UTF-16
* UTF-16BE
* UTF-16LE
* UTF-7
* UTF7-IMAP
* UTF-8
* ASCII
* EUC-JP
* SJIS
* eucJP-win
* SJIS-win
* ISO-2022-JP
* JIS
* ISO-8859-1
* ISO-8859-2
* ISO-8859-3
* ISO-8859-4
* ISO-8859-5
* ISO-8859-6
* ISO-8859-7
* ISO-8859-8
* ISO-8859-9
* ISO-8859-10
* ISO-8859-13
* ISO-8859-14
* ISO-8859-15
* byte2be
* byte2le
* byte4be
* byte4le
* BASE64
* HTML-ENTITIES
* 7bit
* 8bit
* EUC-CN
* CP936
* HZ
* EUC-TW
* CP850
* CP950
* BIG-5
* EUC-KR
* UHC (CP949)
* ISO-2022-KR
* Windows-1251 (CP1251)
* Windows-1252 (CP1252)
* CP866 (IBM866)
* KOI8-R
Unter MAC-OS wird "Western (Mac OS Roman)" verwendet, das mit
[[$line = iconv('macintosh', 'UTF-8', $line);]] bzw.
[[iconv(x,"macintosh","LATIN1")]] konvertierbar ist.
[[http://en.wikipedia.org/wiki/Mac_OS_Roman]] teilt mit:
The Internet Assigned Numbers Authority identifies this encoding using the string "macintosh". 
The MIME Content-Type for this encoding is therefore "text/plain; charset=macintosh". 
Mac OS Roman is also referred to as MacRoman or the Apple Standard Roman character set. 

Beim Laden einer Datei sollte man über das Encoding nachdenken. Dieser Fall wird
in der Funktion [[WinToTcl.read()]] abgehandelt. 
Beim Speichern gehen wir davon aus, dass das locale Encoding passt.

Weiterhin könnte es ein Angebot geben, ein falsches Encoding zu reparieren.
Es sei noch einmal betont, dass die Encoding-Problematik nur wegen der deutschen 
Umlaute abgehandelt werden soll.


Es ist vorstellbar,
dass relax läuft und das locale Encoding utf8, Latin1 oder Macintosh ist. 
In seltenen Fällen dürfte auch noch die Dos-Welt das Encoding bestimmen (cp850).
Zur Zeit wird utf8 anhand des Flags [[is.UTF8]] erkannt und gesondert behandelt.
Damit wird gleichzeitig eine multibyte Character-Codierung unterstellt
([[ l10n_info()["MBCS"] ]] zeigt dann [[TRUE]]). Weitergehende Encodings werden 
bislang nicht überprüft oder bearbeitet.
<<definiere Input/Output-Funktionen neu>>=
WinToTcl.read<-function(x){
  try(if(is.UTF && replace.umlaute.sys){  
      utf8.umlaute <- "[\xa4\xb6\xbc\x84\x96\x9c\x9f]" # utf-Umlaute ohne xc3
      uml.from.other <- c(
         length(grep(utf8.umlaute,useBytes=TRUE,x)),
         length(grep(utf8.umlaute,useBytes=TRUE,iconv(x,"latin1",""))),
         length(grep(utf8.umlaute,useBytes=TRUE,iconv(x,"macintosh",""))),
         length(grep(utf8.umlaute,useBytes=TRUE,iconv(x,"cp850",""))) 
      )
      melde(paste(utf8.umlaute,"uml.from.other:",uml.from.other),3)
      idx.max <- which.max(uml.from.other)
      from <- c("","LATIN1", "macintosh", "cp850")[idx.max]
      <<ask for changing and managing the encoding of the file>>
  })
  try(if(!is.UTF&&replace.umlaute.sys){ 
      umlaute <- "[\xe4\xf6\xfc\xc4\xd6\xdc\xdf]" # latin1-Umlaute
      umlaute <- iconv(umlaute,"latin1","")       # locale-Umlaute
      uml.from.other <- c(
         length(grep(umlaute,useBytes=TRUE,x)),
         length(grep(umlaute,useBytes=TRUE,iconv(x,"utf8",""))),
         length(grep(umlaute,useBytes=TRUE,iconv(x,"macintosh",""))), 
         length(grep(umlaute,useBytes=TRUE,iconv(x,"cp850","")))
      )
      melde(paste(umlaute,"uml.from.other:",uml.from.other),3)
      idx.max <- which.max(uml.from.other)
      from <- c("","utf8", "macintosh", "cp850")[idx.max]
      <<ask for changing and managing the encoding of the file>>
  })
  return(x)
}

@
<<ask for changing and managing the encoding of the file>>=
if( 1 < idx.max){
    melde(paste("source encoding maybe:",from),3)
    res<-tkmessageBox(
      message=if(language=="german") 
                paste("Dokument-Encoding wahrscheinlich:", from, 
                      "Soll es zum lokalen umgewandelt werden?")
              else 
                paste("Encoding of document maybe:", from, 
                      "Do you want to change it to the locale one?"),
      title="Encoding -- German Umlaute", icon="warning", 
      type="yesnocancel", default="yes"
    )
    if("externalptr"==mode(res))  res<-tclvalue(res)
    if(res=="yes"){
      xx <- sapply(x, function(x) iconv(x,from,""))
      idx<-is.na(xx); xx[idx]<-x[idx]; x<-xx
      cat("========================================================================\n")
      cat("WARNING:",from,"encoding of document has been changed to locale encoding\n")
      cat("========================================================================\n")
      Sys.sleep(1)
    }
}

@
Beim Dokument-Transport vom MAC zu anderen Geräte wurden Umlaute nicht umgesetzt. 
Hier ein Versuch per Hand. (120821)
Vorgehen: [[x<-iconv(x,"utf-8",""); x<-iconv(x,"macintosh","")]]

% tx <- "äöüÄÖÜß"
% a<- iconv(tx,"utf8","latin1"); Encoding(a)<-"unknown"; iconv(a,"latin1","utf8")
% [1] "äöüÄÖÜß"
% Probleme durch: a <- "utf8-Umlaute"; Encoding(a) <- "latin1" => zwei Zeichen, a kaputt

<<definiere Kopf-Zeilen-Funktionen>>=
ConvertEncodingToLocal<-function(){# Error: statt Umlaut ue U-tilde-Viertel
  melde("ConvertEncodingToLocal",1)
  frage<-"Input the old Encoding to be converted to locale encoding (e.g. macintosh):"; 
  set.tclvalue("tvinfo","macintosh")
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      from <- tclvalue("tvinfo")
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      <<definiere [[ICONV]]>>
      worktext<-ICONV(worktext,from,"") # LATIN1
      <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>        
  })
  melde("ConvertEncodingToLocal",2)
}
ConvertEncodingFromLocal<-function(){
  melde("ConvertEncodingFromLocal",1)
  frage<-"Input the new encoding (e.g. macintosh) to be applied:" 
  set.tclvalue("tvinfo","macintosh")
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      newencoding <- tclvalue("tvinfo")
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      <<definiere [[ICONV]]>>
      try(worktext <- ICONV(worktext,"",newencoding))
      <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>        
  })
  melde("ConvertEncodingFromLocal",2)
}
@
Unter utf8 erhalten wir nach dem Einlesen ohne Umwandlung von relax angezeigt: 
\begin{verbatim}
dos cp850:       <84><94><81><8e><99><9a><e1> 
mac / macintosh: <8a><9a><9f><80><85><86><a7> 
ubuntu / utf8: äöüÄÖÜß
windows / latin1 <e4><f6><fc><c4><d6><dc><df>
\end{verbatim}
Damit können wir die meisten Situationen problemlos auflösen.
<<definiere Kopf-Zeilen-Funktionen>>=
ConvertGermanUmlauteToLocalEncoding<-function(){
  melde("ConvertGermanUmlauteToLocalEncoding",1)
  ascii <- function(x) { strtoi(charToRaw(x), 16L) }
  ##lese Arbeitsfenster auf [[worktext]] ein## ohne splitting
  if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
  tworkwin<-get("tworkwin",envir=revive.sys); worktext<-tclvalue(tkget(tworkwin,"0.0","end"))
  <<stelle lokales Coding fest: [[is.UTF]]>>
  changes <- FALSE
  if(is.UTF){ melde("locale encoding is utf8:",3)
    idx <- grep("<[0-9a-f][0-9a-f]>",worktext)
    if( 0 < length(idx) ){ 
      melde("not-utf8-Umlaute found ",3)    
      x <- unlist(strsplit(worktext,"\n"))
      idx <- c(grep("<[0-9a-f][0-9a-f]>",x),grep("\\\\x[8-9ae]",x)) 
      xx <- x[idx] #; print(idx)
      uml <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","")
      ae<-uml[1];oe<-uml[2];ue<-uml[3];Ae<-uml[4];Oe<-uml[5];Ue<-uml[6];sz<-uml[7]
      # Konflikt: <9a>: dos-Ue==mac-oe => mac-oe wird zuerst ersetzt
      #              DOS:   MAC:   WIN:  ( cp850, macintosh, latin1 )
      ae.codes <- c("<84>","<8a>","<e4>"); for(code in ae.codes)xx <- gsub(code,ae,xx)
      oe.codes <- c("<94>","<9a>","<f6>"); for(code in oe.codes)xx <- gsub(code,oe,xx)
      ue.codes <- c("<81>","<9f>","<fc>"); for(code in ue.codes)xx <- gsub(code,ue,xx)
      Ae.codes <- c("<8e>","<80>","<c4>"); for(code in Ae.codes)xx <- gsub(code,Ae,xx)
      Oe.codes <- c("<99>","<85>","<d6>"); for(code in Oe.codes)xx <- gsub(code,Oe,xx)
      # DOS Ue(x9a) will not be found because of MAC oe (x9a)
      Ue.codes <- c("<9a>","<86>","<dc>"); for(code in Ue.codes)xx <- gsub(code,Ue,xx)
      sz.codes <- c("<e1>","<a7>","<df>"); for(code in sz.codes)xx <- gsub(code,sz,xx)
      x[idx] <- xx; changes <- TRUE
      worktext <- paste(x,collapse="\n") #; print(worktext)      
    } else { # 121114
      if(<<OS ist Mac-Mini>> && paste(R.version$major,R.version$minor,sep="")<211){
        # find Mac-Umlaute:
        umlloc <- iconv("[\xe4\xf6\xfc\xc4\xd6\xdc\xdf]","latin1","")
        # are there mac-Umlaute
        idx <- grep(umlloc,iconv(worktext,"macintosh",""))
        if(0 < length(idx)){
             x <- unlist(strsplit(worktext,""))
             # where are mac-Umlaute inclusive first charater of multichar representation
             # idx <- grep(umlloc,iconv(x,"macintosh","")); # alt
             idx <- grep(paste("\xc2\xac",umlloc,sep=""),iconv(x,"macintosh",""));
             # extract mac-Umlaute
             xx <- x[idx]
             # convert and repair mac-Umlaute
             xx <- iconv(xx,"macintosh",""); xx <- gsub("\xc2\xac","",xx)
             # repair errors
             if(any(is.na(xx))) xx[is.na(xx)] <- x[idx][is.na(xx)] 
             # save changes
             x[idx] <- xx; worktext <- x; worktext <- paste(worktext,collapse="") 
             changes <- TRUE
        } # end of replacements
      } # end of Mac-Mini
    } # end of not <..> case
  } # end of is.UTF
  is.LATIN1 <-l10n_info()[["Latin-1"]] 
  if(!is.UTF && is.LATIN1){ # 
    melde("locale encoding is Latin-1:",3)
    umlutf8 <- iconv("[\xe4\xf6\xfc\xc4\xd6\xdc\xdf]","latin1","utf8")
    idx <- grep(umlutf8,worktext)
    if( 0 < length(idx) ){ 
      melde("utf8-Umlaute found",3)    
      x <- unlist(strsplit(worktext,"\n")) 
      idx <- grep(umlutf8,x); xx <- x[idx] #; print(idx)      
      uml <-     iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","")
      umlutf8 <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","utf8")
      for(i in 1:7) xx <- gsub(umlutf8[i],uml[i],xx) #; cat("xx-utf-ok"); print(xx)      
      x[idx] <- xx; changes <- TRUE
      worktext <- paste(x,collapse="\n") #; print(worktext)      
    }
    # transform NOT-utf8 Umlaute: --------------------------------------------------
    umldosmac <- paste("[",iconv("\xe4\xf6\xfc\xc4\xd6\xdc\xdf","latin1","cp850"),
                           iconv("\xe4\xf6\xfc\xc4\xd6\xdc\xdf","latin1","macintosh"),"]",sep="")
    idx <- grep(umldosmac,worktext)
    if( 0 < length(idx) ){ 
      melde("dos- or mac-Umlaute found",3)    
      x <- unlist(strsplit(worktext,"\n"))
      idx <- grep(umldosmac,x); xx <- x[idx] #; print(idx)
      uml    <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","")
      umlmac <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","macintosh")
      umldos <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","cp850")
      # Konflikt: <9a>: dos-Ue==mac-oe => mac-umlaute werden zuerst ersetzt
      for(i in 1:7) xx <- gsub(umlmac[i],uml[i],xx) #; cat("xx-mac-ok"); print(xx)      
      for(i in 1:7) xx <- gsub(umldos[i],uml[i],xx) #; cat("xx-dos-ok"); print(xx)      
      x[idx] <- xx; changes <- TRUE
      worktext <- paste(x,collapse="\n") #; print(worktext)      
    }
  }
  if(changes){
      <<schreibe [[worktext]] ins Arbeitsfenster>>    
  }
  melde("ConvertGermanUmlauteToLocalEncoding",2)
} 

@
<<old-is.utf8 repair>>=
    <<definiere [[ICONV]]>>
    try({
      x <- unlist(strsplit(worktext,""))
      idx <- sapply(sapply(x, function(x) 128<=ascii(x)),any)

      xx.old <- xx <- x[idx] 
      
      ax <- sapply(xx, function(x) ascii(x)[1]) # ax <- ascii(paste(xx,collapse="")) 
      if(any(ax==195)) { 
         print("UTF8  Umlaute found: substitution not possible")
      } 
      if( FALSE ){
        worktext<-gsub("\303\244","\344",worktext)
        worktext<-gsub("\303\266","\366",worktext)
        worktext<-gsub("\303\274","\374",worktext)
        worktext<-gsub("\303\204","\304",worktext)
        worktext<-gsub("\303\226","\326",worktext)
        worktext<-gsub("\303\234","\334",worktext)
        worktext<-gsub("\303\237","\337",worktext)         
        x <- unlist(strsplit(worktext,""))
        idx <- sapply(sapply(x, function(x) 128<=ascii(x)),any)

        xx.old <- xx <- x[idx] 
        ax <- sapply(xx, function(x) ascii(x)[1]) # ax <- ascii(paste(xx,collapse=""))           
      }
      # DOS
      #xx.idx <- ax==132|ax==148|ax==129|ax==142|ax==153|ax==154|ax==225 
      #if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "CP850", "")
      #Encoding(xx) <- "unknown"
      # HP-UX 
      xx.idx <- ax==204|ax==206|ax==207|ax==216|ax==218|ax==219|ax==222 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "hp-roman8", "")
      Encoding(xx) <- "unknown"
      # MAC
      xx.idx <- ax==138|ax==154|ax==159|ax==128|ax==133|ax==134|ax==167 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "macintosh", "")
      Encoding(xx) <- "unknown"
      # Latin-1, Windows / ANSI / Suse-Linux alt 
      xx.idx <- ax==228|ax==246|ax==252|ax==196|ax==214|ax==220|ax==223 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "iso-8859-1", "")
      Encoding(xx) <- "unknown"
      if( any(h<-is.na(xx)) ) xx[h] <- xx.old[h]
      x[idx] <- xx
      worktext <- paste(x,collapse="")
    })
    <<schreibe [[worktext]] ins Arbeitsfenster>>        
  }
 # locale encoding is UTF-8:
    repair.Umlaute <- function(txt,EncodingSrc="latin1",
                               WrongIconvFrom="macintosh", WrongIconvTo="utf8"){
      # Umlaute erzeugen, z.B. macintosh-encoding:
      UmlauteMac <- c("\x8a","\x9a","\x9f","\x80","\x85","\x86","\xa7")#mac
      # Umlaute in latin1 umwandeln
      UmlauteLatinl <-iconv(UmlauteMac,"macintosh","latin1")
      Encoding(UmlauteLatinl) <- "unknown"
      # korrekte lokale Umlaute generieren
      UmlauteLocal <- iconv(UmlauteLatinl,"latin1","")
      Encoding(UmlauteLocal) <- "unknown"
      # korrektes Encoding der Quelle abbilden
      UmlauteEncodingSrc <- iconv(UmlauteLatinl,"latin1",EncodingSrc)
      Encoding(UmlauteEncodingSrc) <- "unknown"
      # Fehlerhafte Konvertierung abbilden: Latin1 als Macintosh angesehen nach Utf-8
      UmlauteWrong <- UmlauteEncodingSrc; Encoding(UmlauteWrong) <- "unknown"
      for(step in seq(along=WrongIconvFrom)){
        UmlauteWrong <- iconv(UmlauteWrong,WrongIconvFrom[step],WrongIconvTo[step])
        Encoding(UmlauteWrong) <- "unknown"
      }
      org <- txt
      for(i in 1:7){ txt <- gsub(UmlauteWrong[i],UmlauteLocal[i],txt) }
      Encoding(txt) <- "unknown"
      if( any(h<-is.na(txt)) ) txt[h] <- org[h]
      txt
    }
    try({
      txt <- worktext <- unlist(strsplit(worktext,"\n"))      
      txt <- repair.Umlaute(txt,EncodingSrc="latin1",
                            WrongIconvFrom="macintosh", WrongIconvTo="utf8")
      txt <- repair.Umlaute(txt,EncodingSrc="macintosh",
                            WrongIconvFrom=NULL, WrongIconvTo=NULL)
      txt <- repair.Umlaute(txt,EncodingSrc="latin1",
                            WrongIconvFrom=NULL, WrongIconvTo=NULL)
      if( any(h<-is.na(txt)) ) txt[h] <- worktext[h]
      worktext <- paste(txt,collapse="\n")
    })
    try({
      x <- unlist(strsplit(worktext,""))
      idx <- sapply(sapply(x, function(x) 128<=ascii(x)),any)
      xx.old <- xx <- x[idx] 
      ax <- sapply(xx, function(x) ascii(x)[1])  # ax <- ascii(paste(xx,collapse="")) 
      # DOS
      xx.idx <- ax==132|ax==148|ax==129|ax==142|ax==153|ax==154|ax==225 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "CP850", "")
       # HP-UX 
      xx.idx <- ax==204|ax==206|ax==207|ax==216|ax==218|ax==219|ax==222 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "hp-roman8", "")
      # MAC
      xx.idx <- ax==138|ax==154|ax==159|ax==128|ax==133|ax==134|ax==167 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "macintosh", "")
      # Latin-1, Windows / ANSI / Suse-Linux alt 
      xx.idx <- ax==228|ax==246|ax==252|ax==196|ax==214|ax==220|ax==223 
      if(any(xx.idx)) xx[xx.idx] <- ICONV(xx[xx.idx], "iso-8859-1", "")
      x[idx] <- xx            
      worktext <- paste(x,collapse="")
    })

@
<<definiere [[ICONV]]>>=
ICONV <- function(x,from, to){ # iconv zeilenweise 
  local.encoding <- Encoding(iconv("\344","latin1",""))
  if(from=="") from <- local.encoding; if(to=="") to <- local.encoding
  org <- x; x <- sapply(x, function(x) iconv(x, from, to))
  x[is.na(x)] <- org[is.na(x)]; Encoding(x) <- to
  return(x)
}

@
Einige Experimente bzgl. Reparatur von Zeilen.
<<test>>= 
wrong.latin1.to.locale.transformation <- iconv("äöüÄÖÜß","latin1","")
txt <- wrong.latin1.to.locale.transformation

revers.from.to.locale.encoding <- function(txt,from="latin1"){
  umlaute.ok <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1","")
  umlaute.wrong <- iconv(umlaute.ok,from,""); Encoding(umlaute.wrong) <- "unknown"; umlaute.wrong
  for(i in 1:7){
    txt <- gsub(umlaute.wrong[i], umlaute.ok[i], txt); print(txt)
  }
  txt
}

revers.from.to.to.encoding <- function(txt,from="latin1",to=""){
  umlaute.ok <- iconv(c("\xe4","\xf6","\xfc","\xc4","\xd6","\xdc","\xdf"),"latin1",to)
  umlaute.wrong <- iconv(umlaute.ok,from,to); Encoding(umlaute.wrong) <- "unknown"; umlaute.wrong
  for(i in 1:7){
    txt <- gsub(umlaute.wrong[i], umlaute.ok[i], txt); print(txt)
  }
  txt
}

txt <- "äöüÄÖÜß"
print(txt)
txt <- iconv(txt,"","macintosh"); Encoding(txt) <- "unknown"
print(txt)
txt <- iconv(txt,"latin1","utf8")
print(txt)
txt <- iconv(txt,"","latin1")
print(txt)
txt <- iconv(txt,"macintosh","")
print(txt)

@
%----------------------------------------------------------------------------------%
<<old WinToTcl.read>>=
 # x<-chartr("\204\224\201\216\231\232\341","\244\266\274\204\226\234\237",x) # old dos
    x<-chartr("\314\316\317\330\332\333\336","\244\266\274\204\226\234\237",x) # old unix
    x<-chartr("\344\366\374\304\326\334\337","\244\266\274\204\226\234\237",x)
    x<-gsub("(\244|\266|\274|\204|\226|\234|\237)","\283\\1",x) #ae
WinToTcl.read<-function(x){ #old
  try(if(is.UTF&&replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  ##?? LATIN1
    # Latin1 document loaded->translate to utf-8
    res<-tkmessageBox(message=if(language=="german") 
        "Soll das Encoding des Dokuments (?Latin1?) auf das lokale umgesetzt werden?"
      else 
        "Do you want to change the encoding of the document (?latin1?) to the local one?",
            title="Encoding?",icon="warning",type="yesnocancel",default="no")
    if("externalptr"==mode(res))  res<-tclvalue(res)
    if(res=="yes"){
      x<-iconv(x,"latin1","")  ## LATIN1
      cat("Latin1 Encoding of document has been changed to local coding\n")
    }
  })
  try(if(!is.UTF&&replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  ## LATIN1
    # utf-8 document loaded->translate to Latin1
    res<-tkmessageBox(message=if(language=="german") 
        "Soll das Encoding des Dokuments (?UTF-8?) auf das lokale umgesetzt werden?"
      else 
        "Do you want to change the encoding (?utf-8?) of the document to the local one?",
            title="Encoding?",icon="warning",type="yesnocancel",default="no")
    if("externalptr"==mode(res))  res<-tclvalue(res)
    if(res=="yes"){
      x<-iconv(x,"utf-8","")
      cat("utf-8 Coding of document has been changed to local coding\n")
    }
  })
  return(x)
}
WinToTcl.read<-function(x){ #old
  try(if(is.UTF&&replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  ## LATIN1
    # Latin1 document loaded->translate to utf-8
      xx<-iconv(x,"latin1",""); idx<-is.na(xx); xx[idx]<-x[idx]; x<-xx      ## LATIN1
      cat("Latin1 Encoding of document has been changed to local coding\n")
      cat("=====================================================================\n")
      cat("WARNING: Latin1 Encoding of document has been changed to local coding\n")
      cat("=====================================================================\n")
      Sys.sleep(2)
  })
  try(if(!is.UTF&&replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  # LATIN1
    # utf-8 document loaded->translate to Latin1
      xx<-iconv(x,"utf-8",""); idx<-is.na(xx); xx[idx]<-x[idx]; x<-xx
      cat("==================================================================\n")
      cat("WARNING: utf-8 Coding of document has been changed to local coding\n")
      cat("==================================================================\n")
      Sys.sleep(2)
  })
  return(x)
}
%-------------------------------------------------------------------------------%
WinToTcl.read<-function(x){
  try(if(is.UTF && replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  # LATIN1
    # Latin1 document loaded->translate to utf-8 ## 121010
      xx <- sapply(x, function(x) iconv(x,"LATIN1","")) # xx<-iconv(x,"latin1","") # LATIN1
      idx<-is.na(xx); xx[idx]<-x[idx]; x<-xx
      cat("Latin1 Encoding of document has been changed to local coding\n")
      cat("=====================================================================\n")
      cat("WARNING: Latin1 Encoding of document has been changed to local coding\n")
      cat("=====================================================================\n")
      Sys.sleep(2)
  })
  try(if(!is.UTF&&replace.umlaute.sys && any(is.na(iconv(x,"","latin1")))){  ## LATIN1
    # utf-8 document loaded->translate to Latin1
      xx <- sapply(x, function(x) iconv(x,"utf-8","")) # xx<-iconv(x,"utf-8","")
      idx<-is.na(xx); xx[idx]<-x[idx]; x<-xx
      cat("==================================================================\n")
      cat("WARNING: utf-8 Coding of document has been changed to local coding\n")
      cat("==================================================================\n")
      Sys.sleep(2)
  })
  return(x)
}

@
Umlautumwandlung beim Schreiben von Dateien
Externe Dateien können seltsame Charaktere enthalten.
Diese müssen dann ersetzt werden:
UTF-8-Anpassung: 12.5.2006,
Anpassung in weaveR noch noetig,???
noch unklar, wie UTF-8 erkannt werden kann.???
%% # german<-1==length(grep("(=de)|(=ge)",lcctype)); if(!german) return(x)
%% # UTF<-UTF | (0==length(grep("(=de)|(=ge)",lcctype)))
Mit UTF-8 ergibt sich ein "ä" durch:
[[rawToChar(as.raw(c(195,164)))]], sodass wir schreiben können:
[[plot(1,main=rawToChar(as.raw(c(195,164))))]] und ein "ä" erscheint als 
Titel; dieses ist gleichbedeutend mit [[plot(1,main="\xc3\xa4")]]
[[c3 a4]] entspricht: [[as.raw(c(195,164))]].
Unter UTF-8 ist die Zeichenkette [["\xc3"]]
unvollständig und [[deparse("\xc3")]]
liefert die Zeichenkette [["\"<c3>\""]], die aus 6 Zeichen besteht,
wogegen unter iso-8955 eine Zeichenkette der Länge 3:
zwei Tüddelchen und einem [[A]] mit einer Tilde resultiert.
Dieses können wir zur Unterscheidung verwenden.
Leider war dieses Vorgehen war immer erfolgreich,
so dass nun 999 umgewandelt und untersucht wird, was dabei herauskommt.
In Abhängigkeit davon wird nun die Funktion [[TcltoWin.write]] definiert.
Nach Mail von Duncan Murdoch vom 4.9.11 ist [[\283]] mit [[\303]] identisch.
<<definiere Input/Output-Funktionen neu>>=
if(is.UTF)  TcltoWin.write<-function(x){ return(x) } else {
  # Latin1-Umwandlung von Umlauten
  pc<-eval(parse(text='"\\303"'))  # UTF-8-pre-char, old: 283
  uml.utf.8 <-eval(parse(text='"\\244\\266\\274\\204\\226\\234\\237"'))
  uml.latin1<-eval(parse(text='"\\344\\366\\374\\304\\326\\334\\337"'))
  TcltoWin.write<-function(x){
    if(replace.umlaute.sys){
      x<-chartr(uml.utf.8,uml.latin1,gsub(pc,"",x))
    }
    return(x)
  }
}

@
\subsubsection{Behandlung von UTF-8 u.a.}
wie Die R-Funktion [[l10m_info()]] zeigt uns die Zeichenbehandlung der lokalen Maschine an.
Diese Funktion liefert uns eine Liste mit drei logischen Einträgen:
\begin{enumerate}
\item  MBCS: If a multi-byte character set in use?
\item  UTF-8: Is this a UTF-8 locale?
\item  Latin-1: Is this a Latin-1 locale?
\item [] See Also:  'Sys.getlocale', 'Sys.localeconv'
\end{enumerate}
Unter Suse-Linux auf dem wiwi138 im Aug2011 erhielten wir: 
\begin{verbatim}
> l10n_info()
$MBCS
[1] FALSE
$`UTF-8`
[1] FALSE
$`Latin-1`
[1] FALSE
\end{verbatim}
Mac-Tiger
\begin{verbatim}
Fri Nov  9 08:53:19 2012
$MBCS
[1] TRUE
$`UTF-8`
[1] TRUE
$`Latin-1`
[1] FALSE
\end{verbatim}
Ubuntu auf athena gibt aus:
\begin{verbatim}
> l10n_info()
$MBCS
[1] TRUE
$`UTF-8`
[1] TRUE
$`Latin-1`
[1] FALSE
\end{verbatim}
WindowsXP zeigt uns folgende Infos:
\begin{verbatim}
> l10n_info()
$MBCS
[1] FALSE
$`UTF-8`
[1] FALSE
$`Latin-1`
[1] TRUE
$codepage
[1] 1252
\end{verbatim}



Somit könnten wir den folgenden Chunk auch ersetzen durch:\\
[[ is.UTF<- l10n_info()$"UTF-8" ]] \newcommand{\wega}{$}
<<stelle lokales Coding fest: [[is.UTF]]>>=
.Tcl("set XYZ [encoding system]")
UTF<-is.UTF<- 0<length(grep("utf",tclvalue("XYZ")))

@
<<old 20070228>>=
TcltoWin.write<-function(x){
   x<-gsub("\283","",x)
   x<-chartr("\244\266\274\204\226\234\237","\344\366\374\304\326\334\337",x)
   return(x)
 }

@
<<OLD vor 23.11.2006: definiere Input/Output-Funktionen neu>>=
#if(exists("intToUtf8")) {  
#   is.UTF<-substring(intToUtf8(as.integer(999)),2,2)=="" 
#}else{
#  is.UTF<-FALSE }
TcltoWin.write<-function(x){
 lcctype<-grep("LC_CTYPE",strsplit(Sys.getlocale(),";")[[1]],value=TRUE)
 UTF<-(1==length(grep("UTF",lcctype))) 
 # UTF<- UTF | nchar(deparse("\xc3")) > 3
 is.UTF<-substring(intToUtf8(as.integer(999)),2,2)==""
 UTF<- UTF | is.UTF
 #(0==length(grep("(=de)|(=ge)",lcctype)))
 # cat("UTF?"); print(UTF)
 if(!UTF){
   x<-gsub("\283","",x)
   x<-chartr("\244\266\274\204\226\234\237","\344\366\374\304\326\334\337",x)
   return(x)
 }else{
   return(x)
 }
}
@
Übersetzung beim weave-Prozess, jedoch muss getauscht werden: 283 -> 303:
\begin{verbatim}
  x<-gsub("\283\237","{\\\\ss}",x)
  x<-gsub("(\283\244|\283\266|\283\274|\283\204|\283\226|\283\234)",
                            "\\\\\"\\1",x)
  x<-chartr("\283\244\283\266\283\274\283\204\283\226\283\234", 
                              "aouAOU", x)
\end{verbatim}
 
alt / Fehler
\begin{verbatim}
#if(0==length(grep("=de",grep("LC_CTYPE",strsplit(Sys.getlocale(),";")[[1]],value=TRUE)))) return(x)  ####060113 /0602013
\end{verbatim}

@
Umlautersetzung für Html-Datei-Speicherung.
%% alt: #  UTF<-(1==length(grep("UTF",lcctype))) | (0==length(grep("(=de)|(=ge)",lcctype)))
 
<<ersetze Umlaute; [[AsHtml]]>>=
# Umlaute-Ersetzung fuer Tcl-Fenster nach Html:

 <<stelle lokales Coding fest: [[is.UTF]]>>

 if(!UTF){
   savetext<-gsub("\237","&szlig;",savetext)
   savetext<-gsub("(\244|\266|\274|\204|\226|\234)","&\\1uml;",savetext)
   savetext<-chartr("\244\266\274\204\226\234", "aouAOU", savetext)
   savetext<-gsub("\303","",savetext)
 }else{
   savetext<-gsub("\303\237","&szlig;",savetext)
   savetext<-gsub("(\303\244|\303\266|\303\274|\303\204|\303\226|\303\234)",
                            "&\\1uml;",savetext)
   savetext<-chartr("\303\244\303\266\303\274\303\204\303\226\303\234", 
                              "aouAOU", savetext)
 }
 # cat("AsHtml: 303..fertig"); print(UTF)
 
@
<<unused>>=
x<-gsub("\244","+ä",x) #ae
 x<-gsub("\266","+ö",x) #oe
 x<-gsub("\274","+ü",x) #ue
 x<-gsub("\204","+Ä",x) #Ae
 x<-gsub("\226","+Ö",x) #Oe
 x<-gsub("\234","+Ü",x) #Ue
 x<-gsub("\237","+ß",x) #sz
toUnixTcl<-function(x){
 x<-chartr("\344\366\374\304\326\334\337","\314\316\317\330\332\333\336",x)
 x<-chartr("\204\224\201\216\231\232\341","\314\316\317\330\332\333\336",x)
 x<-sub("\032","",x)
}
 x<-gsub("\344","\283\244",x) #ae
 x<-gsub("\366","\283\266",x) #oe
 x<-gsub("\374","\283\274",x) #ue
 x<-gsub("\304","\283\204",x) #Ae
 x<-gsub("\326","\283\226",x) #Oe
 x<-gsub("\334","\283\234",x) #Ue
 x<-gsub("\337","\283\237",x) #sz
savetext<-gsub("\336","&szlig;",savetext)
savetext<-gsub("(\314|\316|\317|\330|\332|\336)","&\\1uml;",savetext)
savetext<-chartr("\314\316\317\330\332\333", "aouAOU", savetext)
# Umlaute-Ersetzung fuer Unix-Dateien nach Html:
# savetext<-gsub("\341","&szlig;",savetext)  ;
# savetext<-gsub("(\204|\224|\201|\216|\231|\232)","&\\1uml;",savetext)
# savetext<- chartr("\204\224\201\216\231\232", "aouAOU", savetext)


@
%tcl2dos<-function(x){
% x<-gsub("ä","ä",x);x<-gsub("ö","ö",x);x<-gsub("ü","ü",x)
% x<-gsub("Ä","Ä",x);x<-gsub("Ö","Ö",x);x<-gsub("Ü","Ü",x)
% x<-gsub("ß","ß",x)
%}
%dos2tcl<-function(x){
% x<-gsub("ä","ä",x);x<-gsub("ö","ö",x);x<-gsub("ü","ü",x)
% x<-gsub("Ä","Ä",x);x<-gsub("Ö","Ö",x);x<-gsub("Ü","Ü",x)
% x<-gsub("ß","ß",x)
%}

@
\section{Zusammenbau und Restarbeiten}

@
\subsection{Die große Bauanleitung und die Funktion [[relax]]}
Nachdem jetzt alle Teilprobleme bearbeitet worden sind, können die Teillösungen
zu der Funktion [[relax]] zusammengebaut werden. Dabei ist besonders
zu berücksichtigen, daß Dinge, die verwendet werden, zuvor definiert
sein müssen, sprich: es kommt auf die richtige Reihenfolge an.
Voraussetzung für die Arbeit mit [[relax]] ist, daß das
Paket [[Tcl/Tk]] geladen wurde.
Die Option [[no.plots]] veranlaßt den Manager keine Bilder einzublenden.

[[pswidth.sys="13cm"]] wurde als Parameter, da an sich überflüssig, entfernt.
<<zeige Zustand von revive.sys>>=
cat(">>",state<-state+1,"<<\n")
print(ls(envir=get("revive.sys", envir=revive.env)))

@
<<*>>=
#.First.lib<-function(lib, pkg) {
#      options(warn=1)
#      options(warning.expression={cat("WARN: Warning-Info see Console window")})
#      cat(".First.lib erledigt!\n")
#}
relax<-function(file.name,no.plots=FALSE,cmds="",but.Wizardry="all"){
 # Copyright (C) 2005--2008 Hans Peter Wolf
  options(warn=1)
 #      options(warning.expression={cat("WARNING: Warning-Info see Console window")})
  <<stelle Pfad und Position von [[relax]] fest>>
  ## running.function<- #<relax>#  assign("running.function",#<relax>#, pos=relax.pos) ##111103
  <<generiere eine neue Umgebung für die Anwenderdaten>>
  <<definiere [[myhead.menu]]>>
  <<definiere Funktion zur Erleichterung der Fehlersuche>>
  <<setze Anwenderkonfiguration um>>
  ##lade das [[Img]]-Paket für [[Tcl/Tk]]>> 121212 
  <<definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>
  <<stelle lokales Coding fest: [[is.UTF]]>>
  <<definiere Input/Output-Funktionen neu>>
## attach(relax.fns)
  <<ermittle Namen einer temporären Datei>>
  <<ermittle Namen einer Sink-Datei>>
  ##definiere [[SaveAsHtml]]##           
  ##definiere Testknopf\-funktion##
  <<definiere Funktionen allgemeiner Knöpfe>>
  <<definiere Kopf-Zeilen-Funktionen>>    
          ##setze Umgebung für Knopf\-funktionen##
	  ##setze Umgebung für Testknopf\-funktion## 
          ##setze Umgebung für Zeilen-Funktionen##
  <<setze Umgebung für sonstige Funktionen>>
  <<definiere Data-Fns-Menü>>
  <<setze einige Konstanten>>
  <<setze einige [[tcl]]-Konstanten>>
  <<setze Systemkonstanten>>
  <<definiere plattformspezifische Ereignisse>>         ##definiere Testknopf-Ereignis>>
  <<definiere [[Implement.but]]>>
  melde("Implement.but defined",3)

  <<generiere Top-Level-Fenster mit verschiedenen Frames>>
  <<definiere Kopf-Frame>>
  melde("frame head defined",3)
  <<definiere Report-Aktionsframe>>           ##implementiere Testknopf##
  <<definiere Report-Text-Frame>>
  <<definiere Info-Frame>>
  melde("frame info defined",3)
  #<entferne [[relax.fns]] nach Beendigung von [[relax]] aus Suchpfad># # 121214

  <<implementiere Eigenschaften der allgemeinen Knöpfe>>   ##implementiere Eigenschaften vom Testknopf##
  twin<-tworkwin; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
  ##definiere Wirkung von [[Strg Pagedown]] im Reportfenster## ab 1.02 abgeschaltet
  <<definiere Klammernmatchanzeige im Reportfenster>>
  <<definiere Wirkung von [[Tab]] im Reportfenster>>
  ##definiere Funktionstasten-Puffer##
  <<definiere Bindung zur Abarbeitung von [[cmds]]>>
  ##definiere Bindung zur Warnungsabarbeitung##
  melde("initialization of RELAX finished",3)
  <<lade ggf. [[file.name]] und verarbeite Argument [[cmds]]>>
  ##definiere Logik zum Eintrag der Zeilennummer##
  data.fns.menu()
  ReloadReportWidget() # to repair defect report widget
  cat( <<Version von [[relax]]>> ,"\n")
  if(language=="german"){
    cat("relax Initialisierung abgeschlossen!\nR-Editor wird erneut durch  relax()  gestartet!\n")
  }else{
    cat("initialisation of relax completed!\nrestart relax by: relax()\n enjoy and relax it!!\n")
  }
#  tkwait.variable("tvexit")  # version 1.082
  return()
}
red<-redit<-function(file.name){
  if( missing(file.name)) eval(parse(text="relax(but.Wizardry='simple')"),envir=.GlobalEnv) else {
    file.name<-as.character(substitute(file.name))
    eval(parse(text=paste("relax('",file.name,"',but.Wizardry='simple')",sep="")),envir=.GlobalEnv)
    "redit: starts relax with reduced otions"
  }
}

@
Für Version R-2.14.0 ist es nicht mehr zulässig in ein geladenes Paket während der Laufzeit weitere 
Objekte einzubringen. Auf genau dieser Fähigkeit stellte relax bis Version ... ab. 

Nach library(relax) enthält das relax-Paket folgende 9 Objekte:
[1] "gslider"    "playground" "red"        "redit"      "relax"
[6] "slider"     "tangleR"    "weaveR"     "weaveRhtml"
Durch den Start von relax() wurde die Liste um 11 erweitert auf 20 Objekte: 
 [1] "cat"              "gslider"          "melde"            "menu"
 [5] "myhead.menu"      "playground"       "print"            "readline"
 [9] "red"              "redit"            "relax"            "running.function"
[13] "scan"             "set.tclvalue"     "slider"           "step"
[17] "str"              "tangleR"          "weaveR"           "weaveRhtml"
Hinzugekommen sind also 6 überlagerte Funktionen:
  cat, menu, print, readline, scan, str, step
sowie für die eigene Verwaltung:
  melde, myhead.menu, running.function, set.tclvalue

Maßnahmen:
  Verkürzte Schreibweise für "env" durch "envir" ersetzt.
  Es wird eine neue Umgebung eingerichtet: relax.fns
  Überlagerte Funktionen werden in die Umgebung von relax.fns plaziert
  revive.fns wird nach letzter Überlagerung "attached"
  hierdurch Lösung erhofft für: cat, menu, print, readline, scan, str, step
  für melde, myhead.menu und set.tclvalue wird entsprechender Versuch gemacht
  % # 121214: 
  Lösung wurde abgelehnt, nun werden wesentliche Objekte aus relax paket
  exportiert.

@
<<stelle Pfad und Position von [[relax]] fest>>=
relax.path<-path.package(<<relax>>)  # 130325 .path.package defunct
relax.pos<-grep("^package:relax$",search())[1]

@
Folgende Konstante werden jetzt in der Datei config/settings.relax gesetzt:
<<define-config-settings>>=
#############################################
# configuration file of relax
#############################################
#
## general parameters of relax
# language for messages:
language<-"english"
# language<-"german"
# maximal characters of output to be shown
maxol.sys<-4000
# size of fonts # set of values: 1,2, ..., 7
initial.font.size<-4
# height of included postscript plot in LaTeX document:
psheight.sys<-"10cm"
# height parameter for postscript device
psdesignheight.sys<-6
# width parameter for postscript device
psdesignwidth.sys<-6
# rotation of PS graphics
pshorizontal.sys<-FALSE
# size parameter for jpeg device in inch
jpgdesignsize.sys<-4
# resolution for ppm-plot within report widget
ppmresolution.sys<-15
# height of relax window ( e.g.: "500" or "1200" ) 
relaxwindow.height.sys<-"700"
# width of relax window ( e.g.: "500" or "1200" ) 
relaxwindow.width.sys<-"700"
# use of "tab"-key for name completion
name.complete.sys<-TRUE
# replace german umlaute
replace.umlaute.sys<-TRUE # FALSE
#############################################
## special settings for windows
# how to call LaTeX
latex.command.windows<-"echo q | latex"
# view command for viewing .dvi files
view.command.windows<-"yap"
# how to call dvipdf
dvipdf.command.windows<-"dvipdfm"
# text editor
text.editor.windows<-"notepad"
# browser
browser.windows<-" "
# browser.windows<-"c:/Programme/\"Mozilla Firefox\"/firefox.exe "
pdfview.windows<-"acroread"
# ghostscript-program e.g.: 
#   ghostscript<-"c:\\gs\\gs7.04\\bin\\gswin32c"
#   ghostscript<-"C:\\Programme\\gs\\gs8.71\\bin\\gswin32c
ghostscript<-" "
## defunc: Path to Tcl/Tk-img-package: # imgpath.sys <- "C:/Tcl/lib"
#############################################
## special settings for linux
# how to call LaTeX
latex.command.linux<-"echo q | latex"
# view command for viewing .dvi files
view.command.linux<-"xdvi"
# how to call dvipdf
dvipdf.command.linux<-"dvipdf"
# text editor ?????????
text.editor.linux<-"kwrite"
# browser
browser.linux<-"konqueror"
# pdf viewer
pdfview.linux<-"acroread"
## defunc: path.tcltk.package.img<-"/usr/local/lib"
#############################################
## special settings for mac
# how to call LaTeX
latex.command.mac<-"echo q | pdflatex" 
# view command for viewing .dvi files
view.command.mac<-"open " 
# how to call dvipdf
dvipdf.command.mac<-"dvipdf" 
# text editor
text.editor.mac<-"nano"
# browser
browser.mac<-"safari"

@
[[## Sys.setenv("R_GSCMD"="C:\\Programme\\gs\\gs8.71\\bin\\gswin32c.exe")]]
@
zum Thema pdf: 
PDF ist nicht Acrobat und noch nicht einmal Adobe

\begin{verbatim}
http://www.einfach-fuer-alle.de/artikel/pdf-fakten-meinungen/:
Lassen Sie uns noch etwas aus dem Weg räumen: Acrobat ist nicht gleich PDF und PDF ist nicht gleich Acrobat. Neben Acrobat können viele Programme PDFs darstellen. GSview ist eine bekannte Wahl und funktioniert unter Windows, Mac, OS/2 und Linux. Andere Optionen:

    * Unter Windows: Jaws PDF Editor (nicht der Screenreader)
    * Unter MacOS X: Vorschau, Graphikkonverter, Safari und OmniGraffle
    * Unter Linux oder Unix: OpenOffice / StarOffice
\end{verbatim}

@
<<setze Anwenderkonfiguration um>>=
<<define-config-settings>>
try({
  settings<-scan(file=file.path(relax.path,"config/settings.relax"),what="",sep="\n")
  for(i in seq(settings)) eval(parse(text=settings[i]))
})
editor.sys<-text.editor.mac
if(<<das OS ist Windows>>) {
  editor.sys <- text.editor.windows
}
if(<<das OS ist Linux>>) {
  editor.sys <- text.editor.linux
}
browser.sys<-""
if(<<das OS ist Windows>>) {
  browser.sys<-"start "
  if(exists("browser.windows")&&nchar(browser.windows)>0&&0<length(grep("[a-zA-Z]",browser.windows))) 
    browser.sys <- browser.windows
}
if(<<das OS ist Linux>>) {
  if(exists("browser.linux")) browser.sys <- browser.linux
}
if(<<OS ist Mac-Mini>>){
  browser.sys<-"open "
  latex.command.linux<-latex.command.mac
  view.command.linux<-view.command.mac
  dvipdf.command.linux<-dvipdf.command.mac
  text.editor.linux<-text.editor.mac
}
if(!exists("initial.font.size")) initial.font.size<-4
initial.font.size<-initial.font.size[1]
if(is.na(initial.font.size) || all(initial.font.size!=(1:7))) initial.font.size<-4
if(!exists("relaxwindow.width.sys")) relaxwindow.width.sys<-"700"
if(!exists("relaxwindow.height.sys")) relaxwindow.height.sys<-"700"
if(!exists("name.complete.sys")) name.complete.sys<-TRUE
<<checke unter windows, ob ghostscript existiert>>
<<checke unter linux, ob ghostscript existiert>>
@
Es soll geprüft werden, ob unter Windows ghostscript existiert. Falls die Systemvariable 
[[R_GSCMD]] den Pfad auf [[gswin32c.exe]] enthält, ist alles ok und gs ist installiert.
Andernfalls wird das Filesystem ausgehend vom Pfad durchsucht.
Am Ende der Suche wird ggf. die Umgebungsvariable [[R_GSCMD]] neu gesetzt und auch 
auf [[ghostscript]] der Pfad vermerkt.
Wenn nach diesem Chunk [[ghostscript]] noch leer ist, wird gs nicht erreichbar sein.
<<checke unter windows, ob ghostscript existiert>>=
if(<<das OS ist Windows>> && nchar(ghostscript)<=1){
  if(Sys.getenv("R_GSCMD")!="") ghostscript <- Sys.getenv("R_GSCMD")
  else { path.sep <- ";"
    # find pathes where a search will take place and generate all parts of the pathes
    s.path<-unlist(strsplit(Sys.getenv("PATH"),path.sep))
    s.path<-unique(unlist(lapply(s.path,function(x){
      dirs<-unlist(strsplit(x,"\\\\"))
      sapply(1:length(dirs), 
        function(x) paste(dirs[1:x],collapse=.Platform$file.sep))[-1]
    })))
    for(i in 1){
      # append "gs" to the pathes and look for existing pathes
      s.path<-file.path(s.path,"gs"); s.path<-s.path[file.exists(s.path)]
      if(0==length(s.path)) break
      # look for files (dirs) of the form gs7.81 in the generated pathes
      pattern <- "^gs[1-9]" # pattern <- "^gs[bj1-9]" # for testing
      idx <- sapply(s.path, function(x) 0<length(grep(pattern,list.files(x))))
      s.path <- s.path[idx]
      if(0==length(s.path)) break
      # extract the first path that matches the conditions and append gswin32c.exe
      dir <- lapply(s.path, function(x) (grep("^gs[bj1-9]",list.files(x),value=TRUE))[1])
      s.path <- file.path(s.path,dir,"bin","gswin32c.exe")[1]    
      if(!file.exists(s.path)){
        s.path<-NULL; cat("relax warning: gswin32c.exe not found")
      }
    }
    if(0<length(s.path)) {
      ghostscript <- s.path; Sys.setenv("R_GSCMD"=ghostscript)
    }
  }
}

@
Für den Check vergleiche Body der Funktion [[bitmap]].
<<checke unter linux, ob ghostscript existiert>>=
if(<<das OS ist Linux>> && nchar(ghostscript)<=1){
  if(Sys.getenv("R_GSCMD")!="") ghostscript <- Sys.getenv("R_GSCMD")
  else { 
    gsexe <- Sys.getenv("R_GSCMD")
    if (is.null(gsexe) || !nzchar(gsexe)) {
      gsexe <- system("which gs",intern=TRUE)
    }
    if (!is.null(gsexe) && 0<length(gsexe)) {
      ghostscript <- gsexe 
    }
  }
}

@
\subsection{Funktionstastenbelegung}
Für das Schreiben der Textstücke haben sich
Clipboard-Fähigkeiten bewährt. Etwas allgemeiner können mehrere
Buffer als temporäre Textbausteinspeicher zur Verfügung stehen.
Für experimentelle Zwecke werden 8 Speicher eingerichtet, deren
Inhalte durch Betätigung der Funktionstasten in das Textfenster
übertragen werden. Editiert werden sie über einen Wizard-Menü-Eintrag.
Default-mäßig werden auf ihnen übliche \LaTeX-Konstrukte abgelegt.
Der aktuelle Zustand befindet sich in der Umgebung [[revive.sys]].
Wird beim Aufruf die Variable "F.buffers gefunden,
wird diese zur Setzung der Puffer herangezogen.
<<definiere Funktionstasten-Puffer>>=
buffers <- if(exists("F.buffers")) F.buffers else NULL
buffers <- c(buffers,
                    "\\begin{center}\n\n\\end{center}\n",
                    "\\begin{enumerate}\n\\item\n\\end{enumerate}\n",
                    "\\begin{eqnarray*}\n\n\\end{eqnarray*}\n",
                    "\\begin{itemize}\n\\item\n\\end{itemize}\n",
                    "\\begin{quote}\n\n\\end{quote}\n",
                    "\\begin{verbatim}\n\n\\end{verbatim}\n","","")[1:8]
assign("F.buffers",buffers,envir=revive.sys)
tkbind(TopW,"<F1>", function(){
    news<-get("F.buffers",envir=revive.sys)[1];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F2>", function(){
    news<-get("F.buffers",envir=revive.sys)[2];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F3>", function(){
    news<-get("F.buffers",envir=revive.sys)[3];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F4>", function(){
    news<-get("F.buffers",envir=revive.sys)[4];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F5>", function(){
    news<-get("F.buffers",envir=revive.sys)[5];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F6>", function(){
    news<-get("F.buffers",envir=revive.sys)[6];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F7>", function(){
    news<-get("F.buffers",envir=revive.sys)[7];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F8>", function(){
    news<-get("F.buffers",envir=revive.sys)[8];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F1>", function(){
    news<-get("F.buffers",envir=revive.sys)[1];    <<schreibe [[news]] hinter Cursorzeile>>  })

@
<<schreibe [[news]] hinter Cursorzeile>>=
<<hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
    anzrows<-length(news)
    try(tkinsert(tworkwin,paste(line+1,"0",sep="."),paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert", paste(line+anzrows,"0",sep="."))
    tksee(tworkwin,paste(line+anzrows,"0",sep="."))
tkfocus(tworkwin)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
Jetzt ist noch der Menüpunkt zur Pufferänderung zu erstellen.
<<erstelle Menüeintrag für Funktionstasten-Puffer>>=
tkadd(mbRevweb.menu, "command", command=DefineFKeys,
      label="DefineFKeys:    define F-Keys / buffers")

@
Es folgt die Definition des Kommandos.
\subsubsection{Kopfzeile: [[DefineFKeys]]}
\paragraph{[[DefineFKeys]]} ermöglicht die Funktionstasten mit Texten zu belegen,
die dann ins Arbeitsfenster eingefügt werden.
<<definiere Kopf-Zeilen-Funktionen>>=
DefineFKeys<-function(){
  melde("DefineFKeys",1)
  frage<-"number of function key?"; set.tclvalue("tvinfo",1)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      F.no<-tclvalue("tvinfo")
      <<setze Manager nach {\sc Return} in Normalzustand>>
      if(!any(F.no==as.character(1:8))) return() else F.no<-as.numeric(F.no)
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+15");tkpack(tt<-tktext(.newl))
      twin<-tt; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
      tkwm.title(.newl,paste("contents of function key","Definition by Escape!"))
      F.buffers<-get("F.buffers",envir=revive.sys)
      try(tkinsert(tt,"0.0",paste(F.buffers[F.no],collapse="\n")))
      abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
      tkbind(.newl,"<Escape>", function(){
		 F.buffers[F.no]<-tclvalue(tkget(tt,"0.0","end"))
		 assign("F.buffers",F.buffers,envir=revive.sys)
                 tkdestroy(.newl); set.tclvalue("tvscandone",2)
	       })
      tkfocus(.newl);tkwait.variable("tvndone")
      set.tclvalue("tvmess","relax")
    } # end of function
  )
  melde("DefineFKeys",2)
}

@
\subsection{[[Tcl/Tk]] als Voraussetzung für die Oberfläche}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Links:
[[http://sourceforge.net/projects/tkimg/, http://wiki.tcl.tk/1404]],
[[http://members.chello.nl/~j.nijtmans/img.html]]
[[http://www.sciviews.org/_rgui/tcltk/]] tcltk-Beispiele

Wird der Report-Manager als R-Pakete geladen, so sind für das Funktionieren
einige Vorarbeiten zu erledigen. 
Früher: Unter Windows sind die Umgebungs-Variablen
[[PATH]] und [[TCL_library]] zu setzen,
damit für die [[tcl/tk]]-Oberfläche die notwendigen Zutaten gefunden werden.
\begin{center}
[[PATH=..../rw*/library/relax/bin]]\\
[[TCL_library=..../rw*/library/relax/lib/tcl8.3]]
\end{center}
Jetzt ist Tcl/Tk im Lieferumfang von R enthalten.
Weiterhin kann nach dem Laden des [[Tcl/Tk]]-Paketes mit Hilfe
eines [[Tcl]]-Kommandos das Paket [[img]]-Paket geladen werden, damit in den
Textfenster [[jpg]]-Bilder angezeigt werden können.

Unter [[Unix]] müssen ggf.\ die Pfade zum Beispiel bei
Änderungen des System-Dateibaums im [[HRZ]] angepasst werden.
<<old: lade das [[Img]]-Paket für [[Tcl/Tk]]>>=
#       cat('Note: Tcl/Tk-package Img not found!',
# 'Without this package relax is not able to show jpeg pictures in the report window.',
# 'However, the pictures will appear in the html report and the formated tex report.',
# 'For installing the Img package see: > help(relax).',
#           sep="\n" )
Img.package.found <- FALSE 
if(<<das OS ist Windows>>){
  settclenvvars<-function(){
    #if(exists("imgpath.sys")&&imgpath.sys!="") imgpath<-imgpath.sys else #121217
    #  imgpath<-file.path(relax.path,"lib")  # ; print(imgpath)
    #try(.Tcl(paste("lappend auto_path",imgpath)))
    #return(0<length(grep("img",ignore.case=TRUE,list.files(imgpath))))
  }
  res<-settclenvvars()
  if(res){   
    try.res<-try(.Tcl("package require Img"))
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  }
  if(!res || !ok){ 
   #  no.plots<-TRUE
  } else {
    Img.package.found <- TRUE 
  }
  ### if Img and ghostscript are absent no plot should be made for the report widget!!
  if(!Img.package.found && nchar(ghostscript)<=1) no.plots <- TRUE
  ### assign("ghostscript",ghostscript,envir=get("revive.sys",envir=revive.env))
  assign("no.plots",no.plots,envir=get("revive.sys",envir=revive.env))
} 
if(<<das OS ist Linux>>){
  ##setze unter [[Unix]] Pfad in [[Tcl/Tk]] zum Image-Paket##
  #if(file.exists(path.tcltk.package.img)){ # pwolf-lokal
  #  addTclPath(path.tcltk.package.img)
  #  result <- try(tclRequire("Img"))
  #  Img.package.found <- class(result) != "try-error" # 121113
  #}
  # if(!Img.package.found && nchar(ghostscript)<=1) no.plots <- TRUE
  ##assign("ghostscript",ghostscript,envir=get("revive.sys",envir=revive.env))
  assign("no.plots",no.plots,envir=get("revive.sys",envir=revive.env))
}
### Img.package.found <- FALSE ####### <----------- activate only for testing
assign("Img.package.found",Img.package.found,envir=get("revive.sys",envir=revive.env))

@
Der Tcl/Tk-Suchpfad wird verlängert durch 
[[.Tcl("lappend auto_path /usr/local/lib") # img1.3 ]].
Das Img-Paket wird unter Tcl/Tk geladen mit 
[[.Tcl("package require Img")]].

@
\paragraph{Beschreibung des Zustands der Entwicklungsmaschine im Juli 2011.}
Das Paket Img1.3 war unter [[/usr/share/tcl]] als Verzeichnis untergebracht. 
In diesem Verzeichnis befand sich die Datei [[pkgIndex.tcl]]. 
Mit dieser Index-Datei wurde das Shared-Objekt libtkimg1.3.so geladen, 
das sich unter [[/usr/lib]] zusammen mit
\begin{verbatim}
libtk8.5.so        libtkimgico1.3.so     libtkimgpng1.3.so  libtkimgstub1.3.a   
libtkimgwindow1.3.so
libtkimg1.3.so     libtkimgjpeg1.3.so    libtkimgppm1.3.so  libtkimgsun1.3.so   
libtkimgxbm1.3.so
libtkimgbmp1.3.so  libtkimgpcx1.3.so     libtkimgps1.3.so   libtkimgtga1.3.so   
libtkimgxpm1.3.so
libtkimggif1.3.so  libtkimgpixmap1.3.so  libtkimgsgi1.3.so  libtkimgtiff1.3.so  
libtkstub8.5.a
\end{verbatim}
befand. 
[[/usr/share/tcl]] befand sich im Suchpfad von Tcl/Tk (Check:
[[.Tcl("set auto_path")]]. Alle Pakete werden angezeigt mittels:
[[.Tcl("package names")]].

@
siehe: http://wiki.tcl.tk/6149: 
\begin{verbatim}
As of 22 May 2004 JPEG is a module in tcllib that allows one to read and manipulate image information and metadata. Documentation may be found at

    * http://tcllib.sourceforge.net/doc/jpeg.html
    * http://docs.activestate.com/activetcl/8.5/tcllib/jpeg/jpeg.html

The GWImage widget supports this format.
-> http://wiki.tcl.tk/3639
GPS Wed July 3, 2002: GWImage is a fast JPEG display widget for systems with Tk and X. It's much faster than Img, but of course this comes at the cost of reduced portability.

I've done my best to keep the code simple. It could also serve as an example C widget.

I recently added scrolling capability and I plan to add PNG support eventually.

GWImage is released under the terms of a BSD-like license.

http://www.xmission.com/~georgeps/implementation/software/GWImage/ (New Link as of 2009-06-04)

The more I hear about how people use it the more I feel like improving it.
What: GWImage
 Where: http://www.xmission.com/~georgeps/implementation/software/GWImage/GWImage-1.0.tgz
 Description: Tk image widget that currently supports JPEG, but was
        designed to extend to other image formats.  Faster than using
        Tk/Img.
 Updated: 09/2002
 Contact: mailto:georgeps@xmission.com (George Peter Staplin)
\end{verbatim}

siehe auch: http://wiki.tcl.tk/8786:
\begin{verbatim}
Today I was making pictures available on a tclhttpd server, and wanted to make a few hundred automatically sized, compressed (progressive), listed per 10 on a web page as little images with can be clicked on to expand.

The result: http://82.171.148.176/Pictures3/list1.html

I used the cygnus supplied, though separately downloadable, check some search engine, cjpeg/djpeg routines, and used a tcl script to use them on lists of image files:

 set j DSC00155b1m ;
 eval "exec /bin/djpeg -scale 1/1 $j.jpg |   /bin/cjpeg.exe  -quality 18 -progressive -outfile $j\_c.jpg"

The djpeg decompresses the source jpeg file, pipe-s it through to cjpeg, which reencodes it with quality 18, which is pretty compressed to another file. These tools are quite high quality, and make compact encoded images look relatively good.

The final commands where like this, to make a small and full scale both quite compressed image set per input image:

 set inp $path_to_source_images
 set outp $path_to_destination_images

 foreach i [glob $inp/*.jpg] {set j [file tail [file rootname $i]] ; eval "exec /bin/djpeg -scale 1/4 $inp/$j.jpg |   /bin/cjpeg.exe  -quality 15 -progressive -outfile $outp/$j\_cs.jpg"}

 foreach i [glob $inp/*.jpg] {set j [file tail [file rootname $i]] ; eval "exec /bin/djpeg -scale 1/1 $inp/$j.jpg |   /bin/cjpeg.exe  -quality 25 -progressive -outfile $outp/$j\_cn.jpg"}

Automatically, all .jpg images in the source dir will be encoded in 1/4 size and full size in the dest directory, both with progressive encoding, allowing a browser to start displaying a course impression of the image as soon as a little of the data has been downloaded.
\end{verbatim}

Alternative: jpegtopnm - convert JPEG/JFIF file to PPM or PGM image
on the fly einsetzen!?

@
\subsection{Funktionalitäten von Knöpfen, die immer präsent sind}
Für die Übersicht werden in dieser Sektion die Definitionen aller Knöpfe
zusammengefaßt.
<<definiere Funktionen allgemeiner Knöpfe>>=
<<definiere Funktion für Knopf: [[EvalRCode]]>>
<<definiere Funktion für Knopf: [[FindText]]>>
<<definiere Funktion für Knopf: [[Examples]]>>
<<definiere Funktion für Knopf: [[Help.R]]>>
##definiere Funktion für Knopf: [[InsertPlot]]##
<<definiere Funktion für Knopf: [[InsertTeX]]>>
<<definiere Funktion für Knopf: [[PlanRCode]]>>
<<definiere Funktion für Knopf: [[RemoveOut]]>>
<<definiere Funktion für Knopf: [[Insert]]>>
<<definiere Funktion für Knopf: [[SavePlot]]>>
##definiere Funktion für Knopf: [[CopyToEnd]]##
<<definiere Funktion für Knopf: [[TrashROutput]]>>
<<definiere Funktion für Knopf: [[WarnEval]]>>
<<definiere Funktion für Knopf: [[Up]]>>
<<definiere Funktion für Knopf: [[Down]]>>
@
Durch Verschiebung der folgenden Funktionen ist
eine Environment-Veränderung nicht mehr nötig.

@
<<setze Umgebung für sonstige Funktionen>>=
environment(myhead.menu)<-revive.sys

@
\subsection{Initialisiere einige Variablen}
<<setze einige Konstanten>>=
REVFILE            <- "REVFILE"    # eingelesener RevFile
RCHFILE            <- "RCHFILE"    # eingelesener Chunk-File
fr.paper.sys       <- "forget"     #
relax.version.sys<- <<Version von [[relax]]>>

@
<<unused: definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>=
get.tclvar<-function(name){
  tclvalue(name)
}
@
<<definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>=
set.tclvalue<-function(name,value)  tclvalue(name)<-as.character(value)
# assign("set.tclvalue",set.tclvalue, pos=relax.pos) ### 111103
# assign("set.tclvalue",set.tclvalue, pos=pos.of.relax.fns) ## 121214  ok ???
  
@
<<setze einige [[tcl]]-Konstanten>>=
tvexit       <- tclVar("0")
tvchoice     <- tclVar("0")
tvndone      <- tclVar("0")
tvscandone   <- tclVar("0")
tvinfo       <- tclVar("")      # Variable des Kopf-Entry-Widget
tvreadline   <- tclVar("0")
tvmess       <- tclVar("relax")


@
Unter Linux ggf.\ Variable:  export VISUAL=eddi   setzen???
<<setze Systemkonstanten>>=
revpath.sys  <- getwd()         # Pfad zum Revwebpaperverzeichnis
secno.sys    <- "0"             # aktuelle SecNo. in der Revdatei
string.sys   <- ""              # Default-Suchstring
sweave.args.sys<-""  # Default-Setzung weiterer Sweave-Argumente

sizes<-c("8-80","10-100","12-120","14-140","18-180","24-240","*-2000")
tfont.sys    <- "-Adobe-helvetica-Medium-R-Normal--14-140-*" # Text-Schrift
tfont.sys<-sub("al--.+-.+-\\*",paste("al--",sizes[initial.font.size],"-*",sep=""),tfont.sys)
outfont.sys  <- "-Adobe-courier-Medium-R-Normal--14-140-*"   # Output-Schrift
outfont.sys<-sub("al--.+-.+-\\*",paste("al--",sizes[initial.font.size],"-*",sep=""),outfont.sys)
workname.sys<-"out.rev"

@
<<lade ggf. [[file.name]] und verarbeite Argument [[cmds]]>>=
if(!missing(file.name)){
   file.name<-as.character(substitute(file.name)) ## 071115
   file.name<-gsub("\\\\","/",file.name)
   if(0<length(grep("/",file.name))){
     path<-sub("^(.*)/(.*)","\\1",file.name)
     print(path)
     if(nchar(path)>0) try(setwd(path))
     file.name<-sub("^(.*)/","",file.name)
   }
   if(0==length(grep(".rev$",file.name))) file.name<-paste(file.name,"rev",sep=".")
   print(file.name)
   workname.sys<-file.name
   assign("cmds",paste("r",file.name),envir=revive.env)
   Execute.cmds()
}
if(0<length(cmds) && cmds[1]!="") {
  assign("cmds",cmds,envir=revive.env)
  Execute.cmds()
}

@
Definition einiger Konstanten

Zeichensatz für Knöpfe u.ä.
War 14-140
<<Font für Knöpfe>>=
"-Adobe-helvetica-Medium-R-Normal--12-140-*" # ,foreground="#124800"

@
Breite der Knöpfe:
<<Knopfbreite>>=
10

@
Breite des Informationsfeldes:
<<Infofeldbreite>>=
60 ###100208 vorher 80

@
Hinweis für Schriften: Durch Tausch von [[-r-]] statt [[-o-]] erhält
man eine kursive Schrift.

@
@
\subsection{Probleme mit Plattformen}
17.~Juni 2002 -- Erkenntnis:
[[version$os]] liefert unter 1.5.1: [[mingw32]] statt [[Win32]],
evtl. könnte aber auch: 'Microsoft Windows' resultieren.
Gemäß der Help-Seite von [[version]] ist es besser, die Variable
[[.Platform]] mittels [[.Platform$OS.type=="windows"]] abzufragen. 
% # (version$os=="Win32" || version$os=="mingw32") # 130325
<<das OS ist Windows>>=
(.Platform$OS.type=="windows")
@
%% ## 101019
<<OS ist Mac-Mini>>=
substring(version$os,1,6)=="darwin" 
@
<<das OS ist Linux>>=
substring(version$os,1,5)=="linux"
@
Im Package tools: [[if(tools:::OStype()=="windows") ...]]

@
Für Vista muss evtl. etwas geändert werden.
Vgl. Mail:
\begin{verbatim}
This is a known problem with your compiler installation, discussed in the 
R-admin manual.  From the version in R-patched:

   There are known problems with one of the compilers sets in this toolset
   on Windows Vista: see the workaround below. (With that workaround it has
   been used on both 32- and 64-bit versions of Vista.)

   ...

   On Vista systems you will need to add

   c:\Rtools\MinGW\libexec\gcc\mingw\3.4.5

   to the path.

This is not relevant to the recommended compiler set for R 2.6.0.


On Wed, 19 Sep 2007, Anand Patil wrote:

> Hi all,
>
>
> I'd like to distribute an R package that compiles some (small) C functions
> every time it's sourced. The relevant code in the top level R script is as
> follows:
>
> system("R CMD SHLIB Selma_extensions.c")
> if (.Platform$OS.type=="windows") {
>    slash = '\\'
>    dyn.load("Selma_extensions.dll")
> }
> if (.Platform$OS.type=="unix") {
>    slash = '/'
>    dyn.load("Selma_extensions.so")
> }

Hmm, all the information you need is already in .Platform, $file.sep and 
$dynlib.ext: the latter varies by OS.type.

> This works fine on a Mac, but I tried it under Windows Vista, after
> installing RTools and telling it to put itself on the system path, and got
> the following:
>
> making Selma_extensions.d from Selma_extensions.c
> gcc.exe: installation problem, cannot exec `cc1': No such file or directory
> make: *** [Selma_extensions.d] Error 1
> Error in dyn.load(x, as.logical(local), as.logical(now)) :
>        unable to load shared library
> 'C:/Users/anand/Desktop/Selma/Selma_extensions.dll':
>  LoadLibrary failure:  The specified module could not be found.
>
> Can this be fixed without requiring the user to do anything?

The fix requires 'the user' to read the documentation.

-- 
Brian D. Ripley,                  [EMAIL PROTECTED]
Professor of Applied Statistics,  http://www.stats.ox.ac.uk/~ripley/
University of Oxford,             Tel:  +44 1865 272861 (self)
1 South Parks Road,                     +44 1865 272866 (PA)
Oxford OX1 3TG, UK                Fax:  +44 1865 272595
\end{verbatim}

@
\subsection{Plattformabhängige Events}
Die Bezeichnungen von Event variieren von Maschine zu Maschine. Deshalb
ist es vorteilhaft, mit virtuellen Events zu arbeiten. Die spezifischen
Events sollen in einem Chunk zusammengestellt werden.
Als Beispiel sei die Lösung zum Anstoß von [[fSetNo]] über
{\sc Alt-S} betrachtet. Ohne virtuelle Events leistet dieses:
\begin{quote}
\begin{verbatim}
if(version$os=="Win32"){
  tkbind(TopW,"<Alt_L><s>", fSetNo)
} else {
  tkbind(TopW,"<ssharp>", fSetNo)
}
\end{verbatim}
\end{quote}
@
Wird jedoch durch
\begin{quote}
\begin{verbatim}
if(version$os=="Win32"){
  tkevent.add("@<<SetNo>>","<Alt_L><s>")
} else {
  tkevent.add("@<<SetNo>>","<ssharp>")
}
\end{verbatim}
\end{quote}
@
anlagenspezifisch das virtuelle Ereignis [[@<<SetNo>>]] definiert,
so entfällt im Code die Verzweigung:
\begin{quote}
\begin{verbatim}
tkbind(TopW,"@<<SetNo>>", fSetNo)
\end{verbatim}
\end{quote}
@ 
<<definiere plattformspezifische Ereignisse>>=
if(<<das OS ist Windows>> | <<das OS ist Linux>>){
  tkevent.add("@<<Down>>",        "<Alt_L><d>")
  tkevent.add("@<<Up>>",          "<Alt_L><u>")
  tkevent.add("@<<PlanRCode>>",   "<Alt_L><p>")
  tkevent.add("@<<EvalRCode>>",   "<Alt_L><e>")
  tkevent.add("@<<WarnEval>>",    "<Alt_L><w>")
  tkevent.add("@<<Insert>>",      "<Alt_L><i>")
  tkevent.add("@<<SavePlot>>",    "<Alt_L><s>")
  tkevent.add("@<<RemoveOut>>",   "<Alt_L><r>")
  tkevent.add("@<<TrashROutput>>","<Alt_L><t>")
  tkevent.add("@<<Help.R>>",      "<Alt_L><h>")
  tkevent.add("@<<FindText>>",    "<Alt_L><f>") ## <F3> without virtual event
  tkevent.add("@<<FindReportText>>",   "<Control_L><f>")
  tkevent.add("@<<GoToLine>>",         "<Control_L><g>")
  tkevent.add("@<<SaveReport>>",       "<Control_L><s>")
  tkevent.add("@<<ProcessReport>>",    "<Control_L><p>")
  tkevent.add("@<<Next>>",        "<Alt_L><n>")
  tkevent.add("@<<Back>>",        "<Alt_L><b>")
  ## important for special characters
  tkevent.add("@<<RKgeschw>>",    "<Alt_L><0>")
  tkevent.add("@<<LKgeschw>>",    "<Alt_L><7>")
  tkevent.add("@<<RKeckig>>",     "<Alt_L><9>")
  tkevent.add("@<<LKeckig>>",     "<Alt_L><8>")
  tkevent.add("@<<Tilde>>",       "<Alt_L><plus>")
  tkevent.add("@<<Klammera>>",    "<Alt_L><q>")
  tkevent.add("@<<Pipe>>",        "<Alt_L><less>")
  tkevent.add("@<<aeumlaut>>",      "<adiaeresis><KeyRelease>")
  tkevent.add("@<<oeumlaut>>",      "<odiaeresis><KeyRelease>")
  tkevent.add("@<<ueumlaut>>",      "<udiaeresis><KeyRelease>")
  tkevent.add("@<<Aeumlaut>>",      "<Adiaeresis><KeyRelease>")
  tkevent.add("@<<Oeumlaut>>",      "<Odiaeresis><KeyRelease>")
  tkevent.add("@<<Ueumlaut>>",      "<Udiaeresis><KeyRelease>")
  tkevent.add("@<<szumlaut>>",      "<ssharp><KeyRelease>")
  tkevent.add("@<<Backsl>>",      "<Alt_L><ssharp>")
  #tkevent.add("@<<Klammeraffe>>", "<ISO_Level3_Shift><KeyPress><KeyRelease><KeyRelease>") unused
} 
if(<<OS ist Mac-Mini>>){
  tkevent.add("@<<Down>>",        "<Meta_L><d>") # don't work: deletes characters after Cursor 
  tkevent.add("@<<Up>>",          "<Meta_L><u>")
  tkevent.add("@<<PlanRCode>>",   "<Meta_L><p>")
  tkevent.add("@<<EvalRCode>>",   "<Meta_L><e>")
  tkevent.add("@<<Insert>>",      "<Meta_L><i>")
  tkevent.add("@<<SavePlot>>",    "<Meta_L><s>")
  tkevent.add("@<<RemoveOut>>",   "<Meta_L><r>")
  tkevent.add("@<<TrashROutput>>","<Meta_L><t>")
  tkevent.add("@<<Help.R>>",      "<Meta_L><h>") # don't work: hide relax window
  tkevent.add("@<<FindText>>",    "<Meta_L><f>")
  tkevent.add("@<<FindReportText>>",  "<Control_L><f>")
  tkevent.add("@<<GoToLine>>",        "<Control_L><g>")
  tkevent.add("@<<SaveReport>>",      "<Control_L><s>")
  tkevent.add("@<<ProcessReport>>",   "<Control_L><p>")
  tkevent.add("@<<Next>>",        "<Meta_L><n>") # Meta_L n opens new window
  tkevent.add("@<<Back>>",        "<Meta_L><b>") 
  # tkevent.add("@<<WarnEval>>",    "<Meta_L><w>") # willl destroy relax window
  ## important for special characters, aeoe...will work 
  tkevent.add("@<<RKgeschw>>",  "<Meta_L><0>")
  tkevent.add("@<<LKgeschw>>",  "<Meta_L><7>")
  tkevent.add("@<<RKeckig>>",   "<Meta_L><9>")
  tkevent.add("@<<LKeckig>>",   "<Meta_L><8>")
  tkevent.add("@<<Klammera>>",  "<Meta_L><q>")
  tkevent.add("@<<Pipe>>",      "<Meta_L><less>")
  #tkevent.add("@<<aeumlaut>>",      "<adiaeresis><KeyRelease>")
  #tkevent.add("@<<oeumlaut>>",      "<odiaeresis><KeyRelease>")
  #tkevent.add("@<<ueumlaut>>",      "<udiaeresis><KeyRelease>")
  #tkevent.add("@<<Aeumlaut>>",      "<Adiaeresis><KeyRelease>")
  #tkevent.add("@<<Oeumlaut>>",      "<Odiaeresis><KeyRelease>")
  #tkevent.add("@<<Ueumlaut>>",      "<Udiaeresis><KeyRelease>")
  #tkevent.add("@<<szumlaut>>",      "<ssharp><KeyRelease>")
  #tkevent.add("@<<Backsl>>",        "<Meta_L><ssharp>")
  #tkevent.add("@<<Tilde>>",    "<Meta_L><plus>")
  #tkevent.add("@<<Klammeraffe>>", "<ISO_Level3_Shift><KeyPress><KeyRelease><KeyRelease>") unused
} 

@
<<unused>>=
  # tkevent.add("@<<AdvanceNo>>", "<Alt_L><a>") # unused
  # tkevent.add("@<<Modify>>",    "<Alt_L><m>") # unused
  # tkevent.add("@<<CopyToEnd>>",   "<Alt_L><c>") # unused
  # tkevent.add("@<<CopyOld>>",   "<Alt_L><x>")   # unused
  # tkevent.add("@<<RunNo>>",     "<Alt_L><r>")   # unused
  # tkevent.add("@<<ActChunk>>",  "<Control_L><Next>") #Short-Cut copy.down / set
  # MAC:
  # tkevent.add("@<<AdvanceNo>>", "<Meta_L><a>")
  # tkevent.add("@<<Modify>>",    "<Meta_L><m>")
  # tkevent.add("@<<CopyToEnd>>", "<Alt_L><c>")
  # tkevent.add("@<<CopyOld>>",   "<Alt_L><x>")
  # tkevent.add("@<<RunNo>>",     "<Meta_L><r>")
  # tkevent.add("@<<SetNo>>",     "<Meta_L><s>")
  # tkevent.add("@<<ActChunk>>",  "<Control_L><Next>")#Short-Cut copy.down / set

@
Für HPUX galten die Setzungen:
<<old: definiere plattformspezifische Ereignisse>>=
if("HPUX") {                                               #f <hpguilder>
  tkevent.add("@<<WarnEval>>",  "<ae>")
  #tkevent.add("@<<AdvanceNo>>", "<aring>")
  tkevent.add("@<<TrashROutput>>","<hpmute_acute>") # vorher Drop:<eth>  #u <hpmute_diaeresis>
  tkevent.add("@<<InsertPlot>>","<hpmute_asciitilde>") #c <ccedilla>
  tkevent.add("@<<Next>>",      "<ordfeminine>")
  tkevent.add("@<<Help.R>>",   "<yen>")
  #tkevent.add("@<<Modify>>",    "<mu>")
  tkevent.add("@<<PlanRCode>>",   "<thorn>")
  #tkevent.add("@<<CopyOld>>",   "<ccedilla>")                #a aring
  #tkevent.add("@<<RunNo>>",     "<hpmute_acute>")
  tkevent.add("@<<SetNo>>",     "<ssharp>")
  tkevent.add("@<<ActChunk>>",  "<Control_L><Next>")#Short-Cut copy.down / set
  tkevent.add("@<<RKgeschw>>",  "<braceright>")
  tkevent.add("@<<LKgeschw>>",  "<braceleft>")
  tkevent.add("@<<RKeckig>>",   "<bracketright>")
  tkevent.add("@<<LKeckig>>",   "<bracketleft>")
  tkevent.add("@<<Tilde>>",     "<asciitilde>")
  tkevent.add("@<<Klammera>>",  "<at>")
  tkevent.add("@<<Backsl>>",    "<Alt_R><backslash>")
  tkevent.add("@<<Pipe>>",      "<Alt_R><bar>")
}

@
Es zeigte sich, daß in Abhängigkeit vom Betriebssystem ein unterschiedliches
Warteverhalten realisiert werden muß. Die Abfrage wird über einen Code-Chunk
umgesetzt. Vorher: [[tclvar$warten]]. \newcommand{\Weg}{$}
<<warte, falls das OS NICHT Windows ist>>=
if( (! <<das OS ist Windows>>) ) tkwait.variable("tvchoice")

@
\subsection{Debugging und Klick-Report}
Bis zum Schluß ist die Definition der Funktion [[melde]] aufgespart worden,
die die Fehlersuche ein wenig erleichtert. Testerei führte mit
[[sys.calls]], [[browser]] u.a.\ leider bei alten R-Versionen zu Problemen.
<<definiere Funktion zur Erleichterung der Fehlersuche>>=
DEBUG<-"1"; rm(DEBUG) 
melde<-function(report.msg,typ=0,...){
  cat<-get("cat",pos="package:base")
  # if(exists("last.warning"))get("print",pos="package:base")(last.warning)
  if(typ==0) cat(report.msg,...,"\n")
  if(exists("DEBUG") && TRUE==DEBUG){
    if(typ==1 | typ==2) cat(c(a="Start:",z="Ende:")[typ], report.msg,"\n")
    if(typ==3){cat(report.msg); cat(...); cat("\n")}
  }
  if(typ=="cmd.msg"){
    if(<<das OS ist Windows>>) flush.console()
    if(exists("report.msg.to.file.flag")) cat(report.msg, "\n", file="report.msg", append=TRUE)
  }
  invisible()
}
# assign("melde",melde, pos=relax.pos) ## 111103
#assign("melde",melde, pos=pos.of.relax.fns) ## 121214 ???

@
Zur Erleichtung der Fehlersuche kann mit der Funktion [[relax.debug]]
der eventuell veränderte Editor [[relax]] neu geladen werden.
Dabei kommen schärfere Debugging Regeln zum Einsatz.
<<dieser Chunk könnte beim Debuggen helfen>>=
relax.debug<-function(){
  DEBUG<<-TRUE; options(warn=5)
  path<-sub(paste("/",<<relax>>,sep=""),"",find.package(<<relax>>)) # 130325 .find.package defunct
  detach("package:relax")
  library(relax,lib.loc=path)
  assign("DEBUG",T,paste("package",<<relax>>,sep=":"))
  relax()
}

@
\section{Weitere wichtige Definitionen und Dateien von [[relax]]}

\subsection{Datei [[DESCRIPTION]]}

<<define-DESCRIPTION>>=
Package: relax
Version: 1.3.13
Date: 2013-02-27
Title: relax -- R Editor for Literate Analysis and lateX
Author: Hans Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Maintainer: Hans Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Depends: R (>= 2.10.0), tcltk
Suggests: tkrplot
Description: package relax contains some functions for report
    writing, presentation, and programming: relax(), tangleR(),
    weaveR(), (g)slider(). "relax" is written in R and Tcl/Tk.
    relax creates a new window (top level Tcl/Tk widget) that consists
    of two text fields and some buttons and menus.
    Text (chunks) and code (chunks) are inserted in the upper text field (report field).
    Code chunks are evaluated by clicking on EvalRCode.
    Results are shown in the lower text field (output field) and
    will be transferred to the report field by pressing on Insert.
    In this way you get correct reports. These reports can be
    loaded again in cause of presentation, modification and result checking.
    tangleR() and weaveR() implement a plain kind of tangling
    and weaving. gslider() and slider() are designed to define sliders for interactive
    experiments in a simple way.
    The syntax rules of code chunks and text chunks are defined by 
    the noweb system proposed by Norman Ramsey
    (http://www.eecs.harvard.edu/~nr/noweb/intro.html).
License: GPL (>= 2)
URL: http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html

@
alt: % # 121212
    For integrating jpeg graphics into the text field you need the
    Tcl/Tk Img package of Jan Nijtmans 
    (see: http://members.chello.nl/~j.nijtmans/img.html,
    http://home.kpnplanet.nl/~J.Nijtmans@kpnplanet.nl/img.html or
    http://tkimg.sourceforge.net/, the package is found on  
    http://sourceforge.net/projects/tkimg).
    If an Img version is integrated in the relax package
    the license terms concerning the img package will be found in 
    the source file of the package, for example in: relax/src/tkimg1.3.tar.gz.
    Older windows versions of relax
    contain the Tcl/Tk img package, so no further installations
    have to be done.

@
alt:
License: This package was written by Hans Peter Wolf.
   This software is licensed under the GPL (version 2 or newer) terms.
    It is free software and comes with ABSOLUTELY NO WARRANTY.

@
\subsection{Datei [[NAMESPACE]]}
ab R-Version 2.14.0 erforderlich.
%% exportPattern("^slider.[a-z]+")
<<define-NAMESPACE>>=
export(gslider,playground,CodeChunkPlayer,ConstructDemo,red,redit,relax,
       str,cat,print,readline,menu,step,scan,args.player,
       slider,tangleR,weaveR,weaveRhtml)

@
\subsection{Help-Page von [[relax]]}

<<define-relax-help>>=
\name{relax}
\alias{relax}
\alias{redit}
\alias{red}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{ R editor: relax }
\description{
  \code{relax} is an editor for doing data analysis with R and writing reports.
  \code{redit} is a simple version of relax offering a reduced set of items in the head menus.
  \code{red} is an other name for redit.
}
\usage{
  relax(file.name, no.plots = FALSE, cmds = "", but.Wizardry = "all")
  redit(file.name)
  red(file.name)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{file.name}{name of report file to be loaded }
  \item{no.plots}{ if \code{TRUE} no plots are integrated into the report text field}
  \item{cmds}{ special operations that are evaluated on start }
  \item{but.Wizardry}{ if \code{"all"} menu \code{Wizardry} is created;
                       if \code{"simple"} a reduced list of commands is offered }
}
\details{
  \code{relax} is written in R and Tcl/Tk.
  \code{relax} creates a new window (top level Tcl/Tk widget) that consists of
  two text fields and some buttons and menus. Text (chunks) and code (chunks)
  are inserted in the upper text field (report field). Code chunks are evaluated by clicking
  on \code{EvalRCode}. Results are shown in the lower text field (output field) and will be
  transferred to the report field by pressing on \code{Insert}.

  Chunks are separated by separators:
  A line containing the character "@" at its first position indicades the beginning of a text chunk.
  Patterns like \verb{@<<*>>=} or \verb{@<<}code chunk name\code{>>=} define code chunk
  headers and introduce code chunks.
  The code of a code chunk is the set of R expression found between the header and the
  following text chunk.

  \code{redit} is a wrapper function that calls \code{relax} with argument \code{but.Wizardy="simple"}.

  How to work with relax?
  \itemize{
   \item Load package \code{relax} by: \code{library(relax)}.

   \item Start the relax editor by:  \code{relax()}.

   \item \code{PlanRCode}: Press \code{PlanRCode} and an empty text chunk and an empty code
   chunk without contents appear in the report field (upper blue text field).
   Now you can write down any text between
   "@"-line and the header of next code chunk \verb{@<<*>>=}. The code has to be placed
   after the header line.

   \item \code{EvalRCode}: \code{EvalRCode} evaluates the code (the cursor is pointing at)
   and the results appear in the output field just as in \code{R};
   warnings will be converted in errors and will stop the evaluation.

   \item \code{WarnEval}: \code{WarnEval} evaluates the code  (the cursor is pointing at)
   and the results appear in the output field just as in \code{R};
   however warnings will not stop the evaluation of the code.

   \item \code{RemoveOut}: \code{RemoveOut} clears the output field.

   \item \code{Insert}: \code{Insert} transfers the contents of the output text field
   to the upper text field as a new text chunk.

   \item \code{SavePlot}: \code{SavePlot} copies the graphics device; it creates a \code{postscript}
         as well as a \code{jpeg} file and inserts the LaTeX includegraphics reference
	 in the report field as a new text chunk.

   \item \code{Find}: \code{Find} finds some text string in the working text and highlights 
         matches found.

   \item \code{TrashOutput}: \code{TrashOutput} removes inserted \code{R} output from the upper field
   (the cursor is pointing at). 

   \item \code{Down}: \code{Down} moves the cursor down to the next code chunk.

   \item \code{Up}: \code{Up} moves the cursor up to the next code chunk.

    \item \code{File}: The \code{File} menu in the menu bar of \code{relax} allows you save the report
   -- the contents of the blue text field. The saving operation generates two
   files: a text file (extension: \code{rev}) and a \code{html} file.
   You can load an old report into the upper text field (report field)
   and continue to work on the report.

    \item \code{Edit}: Several operations to make editing faster and easier are collected in the \code{Edit} menu:
   searching, starting an external editor, etc.

   \item \code{Options}: The entries of the \code{Options} menu change some of the parameter of relax.

    \item \code{Wizardry}: The items of \code{Wizardry} allow you to generate LaTeX documents from your 
    source file (for LaTeXperts only).
    After saving the raw report you can \code{web} it: this process generates a \code{tex}-file
    that can be formated by LaTeX. See your LaTeX companion for syntax.
    (The web syntax fits to the rules of \code{noweb}.
    Therefore, the raw files can also be processed by Norman Ramsey's
    \code{noweb} system (see: \cr \url{http://www.eecs.harvard.edu/~nr/noweb/}).

    \item \code{Configuration}: 
    Important parameters of \code{relax} are set in the file \verb{...relax/config/settings.relax}.

    \item \code{Environment for evaluation}: 
    Evaluations of code chunks take place in the environment (\code{revive.env}).

    \item \code{cmds}: 
    The character vector \code{cmds} in environment (\code{revive.env}) enables you to
    define operations of your own. For example, \code{cmds<-"r test1.rev"} forces \code{relax}
    to load file \code{test1.rev}. \code{cmds<-c("> 1+1","> 2+2")} results in
    computing 1+1 and then 2+2. \code{cmds<-"s10"} evaluates code chunk number 10.
   }
}
\value{
   --
}
\references{\url{http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html}}
\author{Hans Peter Wolf}
\examples{
### at first try: 
# > redit() 
### or 
# > relax()
### If you want to start with some old file use: 
# > redit("name of old rev-file") 
### or 
# > relax("name of old rev-file")
}
\keyword{ documentation }% at least one, from doc/KEYWORDS

@
old 121212
\note{
  \itemize{
    \item Img-package-not-found-warning:
      On start relax tries to load the Tcl/Tk package \code{Img} for showing jpeg pictures in the text window.
      If this package isn't found relax will print a warning message.
      For further information about the package see: 
        \url{http://sourceforge.net/projects/tkimg},
        \url{http://members.chello.nl/~j.nijtmans/img.html}, and
        \url{http://home.kpnplanet.nl/~J.Nijtmans@kpnplanet.nl/img.html}.
      The Img package has to be installed by the user himself. 
      Windows users can proceed as follows:

   \item Installing Img on windows PCs: How can you install the Tcl/Tk Img package on a windows PC?
         The simplest way to get \code{Img} is to install \code{ActiveTcl8.4.19}
         of ActiveState which you get via
         \url{http://www.activestate.com/Products/activetcl/index.mhtml}.
         The Tcl/Tk-package "Img" is included in the tcl distribution of ActiveState.
         It is important to use version \code{Tcl8.4} and not \code{Tcl8.5}!
         The following four steps will hopefully result in a working installation:
      \itemize{
       \item 1) Download \code{Tcl8.4} from ActiveState. May be the name of the 
         downloaded file is \code{ActiveTcl8.4.19.286921-win32-ix86-threaded.exe}.

       \item 2) Install Tcl8.4 by running the downloaded exe-file.
 
       \item 3) After installing Tcl8.4 you have to add the path to the directory 
         \code{lib} of Tcl8.4 in the relax configuration file.
         The configuration of relax is modified by activating the
         entry \verb{Configure Relax: view or change parameters of relax} of the
         relax menu \code{Options}.
         In the configuration file you have to search the line with the entry 
         \code{# imgpath.sys <- "C:/Tcl/lib"}. Then remove the comment character in front of
         \code{imgpath.sys} and insert the correct path to the Tcl/Tk lib directory.
         The modified line may look like this: \code{imgpath.sys <- "C:/Tcl/lib"}.
      
      \item 4) Save configuration file, quit relax and restart \code{relax} again.
      }
  }
}

@
\subsection{Help-Page von [[slider]]}
<<define-slider-function -- old version>>=
slider<-function(sl.functions,sl.names,sl.mins,sl.maxs,sl.deltas,sl.defaults,
                  but.functions,but.names,
                  no,set.no.value,obj.name,obj.value,
                  reset.function,title){
  # slider, version2, pw 040107
  if(!missing(no)) return(as.numeric(tclvalue(get(paste("slider",no,sep=""),envir=slider.env))))
  if(!missing(set.no.value)){ try(eval(parse(text=paste("tclvalue(slider",set.no.value[1],")<-",
                            set.no.value[2],sep="")),envir=slider.env)); return(set.no.value[2]) }
  if(!exists("slider.env")) eval(parse(text="slider.env@<<-new.env()"))
  if(!missing(obj.name)){
    if(!missing(obj.value)) assign(obj.name,obj.value,envir=slider.env) else
      obj.value<-get(obj.name,envir=slider.env)
    return(obj.value)
  }
  if(missing(title)) title<-"slider control widget"
  require(tcltk); nt<-tktoplevel(); tkwm.title(nt,title); tkwm.geometry(nt,"+0+15")
  if(missing(sl.names)) sl.names<-NULL
  if(missing(sl.functions)) sl.functions<-function(...){}
  for(i in seq(sl.names)){
    eval(parse(text=paste("assign('slider",i,"',tclVar(sl.defaults[i]),envir=slider.env)",sep="")))
    tkpack(fr<-tkframe(nt));  lab<-tklabel(fr, text=sl.names[i], width="25")
    sc<-tkscale(fr,from=sl.mins[i],to=sl.maxs[i],showvalue=T,resolution=sl.deltas[i],orient="horiz")
    tkpack(lab,sc,side="right"); assign("sc",sc,envir=slider.env)
    eval(parse(text=paste("tkconfigure(sc,variable=slider",i,")",sep="")),envir=slider.env)
    sl.fun<-if(length(sl.functions)>1) sl.functions[[i]] else sl.functions
    if(!is.function(sl.fun)) sl.fun<-eval(parse(text=paste("function(...){",sl.fun,"}")))
    tkconfigure(sc,command=sl.fun)
  }
  assign("slider.values.old",sl.defaults,envir=slider.env)
  tkpack(f.but<-tkframe(nt),fill="x")
  tkpack(tkbutton(f.but, text="Exit", command=function()tkdestroy(nt)),side="right")
  if(missing(reset.function)) reset.function<-function(...) print("relax")
  if(!is.function(reset.function))
    reset.function<-eval(parse(text=paste("function(...){",reset.function,"}")))
  tkpack(tkbutton(f.but, text="Reset", command=function(){
         for(i in seq(sl.names))
            eval(parse(text=paste("tclvalue(slider",i,")<-",sl.defaults[i],sep="")),envir=slider.env)
         reset.function()  }  ),side="right")
  if(missing(but.names)) but.names<-NULL
  for(i in seq(but.names)){
    but.fun<-if(length(but.functions)>1) but.functions[[i]] else but.functions
    if(!is.function(but.fun))but.fun<-
       eval(parse(text=paste("function(...){",but.fun,"}")))
    tkpack(tkbutton(f.but, text=but.names[i], command=but.fun),side="left")
    # cat("button",i,"eingerichtet")
  }
  invisible(nt)
}

@
\subsection{Die Hilfe von [[slider]]}
% The definition of slider is stored in slider-function.rev
% # 121207
<<define-slider-help>>=
\name{slider}
\alias{slider}
\alias{gslider}
%- Also NEED an '\alias' for EACH other topic documented here.
%-  cp slider2.Rd /home/wiwi/pwolf/work/relax/install.dir/relax/man/slider.Rd
\title{slider / button control widgets}
\description{
  \code{slider} and \code{gslider} construct a Tcl/Tk-widget with sliders and buttons to
  demonstrate the effects of variation of parameters on calculations and plots. 
}
\usage{
slider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults, but.functions,
  but.names, no, set.no.value, obj.name, obj.value, reset.function, title, prompt=FALSE,
  sliders.frame.vertical=TRUE)

gslider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults, but.functions,
  but.names, no, set.no.value, obj.name, obj.value, reset.function, title, prompt=FALSE,
  sliders.frame.vertical=TRUE, hscale=1, vscale=1,
  pos.of.panel = c("bottom","top","left","right")[1])
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{sl.functions}{set of functions or function connected to the slider(s)}
  \item{sl.names}{labels of the sliders}
  \item{sl.mins}{minimum values of the sliders' ranges}
  \item{sl.maxs}{maximum values of the sliders' ranges}
  \item{sl.deltas}{change of step per click}
  \item{sl.defaults}{default values for the sliders}
  \item{but.functions}{function or list of functions
          that are assigned to the button(s)}
  \item{but.names}{labels of the buttons}
  \item{no}{\code{slider(no=i)} requests slider \code{i}}
  \item{set.no.value}{\code{slider(set.no.value=c(i,val))} sets slider \code{i} to value \code{val}}
  \item{obj.name}{\code{slider(obj.name=name)} requests the value of 
  variable \code{name} from environment \code{slider.env}}
  \item{obj.value}{\code{slider(obj.name=name,obj.value=value)} assigns \code{value}
  to variable \code{name} in environment \code{slider.env}}
  \item{reset.function}{function that induce a \code{reset.button} and 
        contains the commands of it.}
  \item{title}{title of the control window}
  \item{prompt}{ if TRUE slider functions are called by moving a slider,
                 if FALSE slider functions are called after releasing the mouse button}
  \item{sliders.frame.vertical}{ if TRUE the sliders are stacked one above the other;
                 otherwise they are positioned side by side }
  \item{hscale}{horizontal scale factor for image size; compare tkrplot in package tkrplot}
  \item{vscale}{vertical scale factor for image size; compare tkrplot in package tkrplot}  
  \item{pos.of.panel}{position of the panel field for sliders and buttons. 
                      Value of \code{pos.of.panel}: bottom, top, left or right.}
}
\details{
  \code{slider} constructs a separated panel for controlling the parameters whereas 
  \code{gslider} integrates a graphical device and buttons and sliders within one window. 

  The following actions can be done:
  a) definition of (multiple) sliders and buttons, 
  b) request or specification of slider values, and
  c) request or specification of variables in the environment \code{slider.env}.
  The management takes place in the environment \code{slider.env}. If \code{slider.env}
  is not found it is generated.

  \bold{Definition} ... of sliders: First of all you have to define sliders, buttons and the attributes of them.
  Sliders are established by six arguments:
  \code{sl.functions, sl.names, sl.minima, sl.maxima,sl.deltas}, and \code{sl.defaults}.
  The first argument,
  \code{sl.functions}, is either a list of functions or a single function that 
  contains the commands for the sliders.
  If there are three sliders and slider 2 is moved with the mouse the function stored in
  \code{sl.functions[[2]]} (or in case of one function for all sliders the function \code{sl.functions})
  is called.

  \bold{DEFINITION} ... of buttons: Buttons are defined by a vector of labels \code{but.names} and a list of functions:
  \code{but.functions}. If button \code{i} is pressed the function stored in \code{but.functions[[i]]} is called.

  \bold{REQUESTING} ... a slider: 
  \code{slider(no=1)} returns the actual value of slider 1,
  \code{slider(no=2)} returns the value of slider 2, etc. 
  You are allowed to include expressions of the type
  \code{slider(no=i)} in functions describing the effect of
  sliders or buttons.

  \bold{SETTING} ... a slider: \code{slider(set.no.value=c(2,333))} sets slider \code{2} to value 333.
  \code{slider(set.no.value=c(i,value))} can be included in the functions 
  defining the effects of moving sliders or pushing buttons.

  \bold{VARIABLES} ... of the environment \code{slider.env}: Sometimes information
  has to be trransferred back and forth between functions defining the effects of sliders and buttons.
  Imagine for example two sliders: one to control \code{p} and another one to control \code{q},
  but they should satisfy: \code{p+q=1}. Consequently, you have to correct the value of the first slider
  after the second one was moved. To prevent the creation of  global 
  variables store them in the environment \code{slider.env}.
  Use \code{slider(obj.name="p.save",obj.value=1-slider(no=2))}
  to assign value  \code{1-slider(no=2)} to the variable \code{p.save} .
  \code{slider(obj.name=p.save)} returns the value of variable \code{p.save}.

  \bold{Dependencies} The function \code{gslider} depends on package \code{tkrplot}.
}
\value{
 Using \code{slider} in definition mode \code{slider} returns the value of new created the top level widget. 
  \code{slider(no=i)} returns the actual value of slider \code{i}.
  \code{slider(obj.name=name)} returns the value of variable \code{name} in environment \code{slider.env}.
 \code{gslider} return in definition mode the result of \code{tkrplot} which was called to construct the widget.
}
\author{Hans Peter Wolf}

\examples{

# example 1, sliders only
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm<-function(){
 refresh.code<-function(...){
   mu<-slider(no=1); sd<-slider(no=2); n<-slider(no=3)
   x<-rnorm(n,mu,sd)
   plot(x)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(+10,50,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20))
}
plot.sample.norm()
}

# example 2, sliders and buttons
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2<-function(){
 refresh.code<-function(...){
   mu<-slider(no=1); sd<-slider(no=2); n<-slider(no=3)
   type=  slider(obj.name="type")
   x<-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(obj.name="type",obj.value="l")
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
}
plot.sample.norm.2()
}

# example 2a, sliders and buttons and graphics in one window
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2<-function(){
 refresh.code<-function(...){
   mu<-slider(no=1); sd<-slider(no=2); n<-slider(no=3)
   type=  slider(obj.name="type")
   x<-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(obj.name="type",obj.value="l")
 gslider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
}
plot.sample.norm.2()
}

# example 3, dependent sliders
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
print.of.p.and.q<-function(){
 refresh.code<-function(...){
   p.old<-slider(obj.name="p.old")
   p<-slider(no=1); if(abs(p-p.old)>0.001) {slider(set.no.value=c(2,1-p))}
   q<-slider(no=2); if(abs(q-(1-p))>0.001) {slider(set.no.value=c(1,1-q))}
   slider(obj.name="p.old",obj.value=p)
   cat("p=",p,"q=",1-p,"\n")
 }
 slider(refresh.code,sl.names=c("value of p","value of q"),
       sl.mins=c(0,0),sl.maxs=c(1,1),sl.deltas=c(.01,.01),sl.defaults=c(.2,.8))
 slider(obj.name="p.old",obj.value=slider(no=1))
}
print.of.p.and.q()
}

# example 4, rotating a surface
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
R.veil.in.the.wind<-function(){
  # Mark Hempelmann / Peter Wolf
  par(bg="blue4", col="white", col.main="white", 
      col.sub="white", font.sub=2, fg="white") # set colors and fonts
  refresh.code<-function(...){
    samp	<- function(N,D) N*(1/4+D)/(1/4+D*N) 
    z<-outer(seq(1, 800, by=10), seq(.0025, 0.2, .0025)^2/1.96^2, samp) # create 3d matrix
    h<-100 
    z[10:70,20:25]<-z[10:70,20:25]+h; z[65:70,26:45]<-z[65:70,26:45]+h
    z[64:45,43:48]<-z[64:45,43:48]+h; z[44:39,26:45]<-z[44:39,26:45]+h
    x<-26:59; y<-11:38; zz<-outer(x,y,"+"); zz<-zz*(65<zz)*(zz<73)
    cz<-10+col(zz)[zz>0];rz<-25+row(zz)[zz>0]; z[cbind(cz,rz)]<-z[cbind(cz,rz)]+h
    theta<-slider(no=1); phi<-slider(no=2)
    persp(x=seq(1,800,by=10),y=seq(.0025,0.2,.0025),z=z,theta=theta,phi=phi, 
          scale=T, shade=.9, box=F, ltheta = 45,
          lphi = 45, col="aquamarine", border="NA",ticktype="detailed")   
  }
  slider(refresh.code, c("theta", "phi"), c(0, 0),c(360, 360),c(.2, .2),c(85, 270)  )
}
R.veil.in.the.wind()
}

}
\keyword{dynamic}% at least one, from doc/KEYWORDS
\keyword{iplot}% __ONLY ONE__ keyword per line

@
\subsection{Tk-Funktions-Caller}
<<definiere-args.player>>= 
args.player <- function( fn.call, width.of.label = 20,
                               width.of.entry = 25, main ){
  <<untersuche aktuellen Call>>
  <<extrahiere einzelne Argumente>>
  <<extrahiere Argument-Namen und Werte>>
  <<richte Fenster ein>>
  <<fülle den Frame für Argumenten>>
  <<setze Reset-Knopf um>>
  <<setze Evaluierung um>>
  invisible(NULL)
}

@
<<*>>=
<<definiere-args.player>>
@
Es soll zwei Arten des Calls geben: a) kompletter Funktionsaufruf, b) nur einen Funktionsnamen.

Falls der Call nicht als Zeichenkette übergeben wurde, wird zunächst das erste Argument in eine 
Zeichenkette überführt.

Falls nur ein Funktionsname angegeben wurde, gilt es die Argumente zu beschaffen. 
Für generische Funktionen bietet es sich an, die die Default-Methode zu ermitteln, denn
falls eine Spezialmethode gewünscht ist, kann ja diese im Aufruf auch genannt werden.
<<untersuche aktuellen Call>>=
  act.call <- deparse(substitute(fn.call))
  act.call <- sub('^["]{0,1} *',"",act.call)
  act.call <- sub(' *["]{0,1}$',"",act.call)
  args.found <- TRUE
  if( 0 == length(grep("[()]", act.call)) ) { # case only name of a function
    args.found <- FALSE
    # use default methods if exists
    fn.name <- if(exists(h <- paste(act.call,"default",sep="."))) h else act.call
    if(!exists(fn.name)) return(paste("function",fn.name,"not found"))
    # get arguments
    act.call <- deparse( args(fn.name) )
    # remove NULL entry
    if("NULL"==act.call[ h <- length(act.call) ]) act.call <- act.call[-h]
    # substitute "function" by fn.name
    act.call[1] <- sub("^function", fn.name, act.call[1])
    # check ... argument
    # if(0<length(grep("[.]{3}",act.call))) act.call<-sub("[.]{3}"," ",act.call)
  }
  # combine multiline calls
  act.call <- paste(act.call,collapse=" ")
  # get function name
  fn.name <- sub("[(].*","",act.call) #)
  # get argument list
  fn.args <- sub("[^(]*[(](.*)[)].*","\\1",act.call)
  ## print(fn.args)

@
Für die Verarbeitung ist es hilfreich, die Argumente einzeln zugreifbar zu haben.
Die Argumente sind durch Kommata abgetrennt. Die Kommata dürfen jedoch nicht
mit Kommanta der aktuellen Werteangaben verwechselt werden. Diese inneren 
Kommanta gilt es also zu escapen.
<<extrahiere einzelne Argumente>>=
  ### escape inner ","
  # split string to characters
  n <- nchar(fn.args)
  fn.args <- substring(fn.args,1:n,1:n)
  # ( opens a new level, ) closes a level, "," of level 0 are separators
  state <- 0
  for( i in 1:n ) {
    if( fn.args[i] == "(" ){ state <- state + 1; next }
    if( fn.args[i] == ")" ){ state <- state - 1; next }
    if( 0 < state && fn.args[i] == "," ){
      fn.args[i] <- "cOmMa FoUnD"; next
    }
  } 
  # now a "," is a separator and we can split the string
  fn.args <- paste(fn.args,collapse="")
  fn.args <- strsplit(fn.args,",")
  # and reconstruct escaped commas
  fn.args <- gsub("cOmMa FoUnD",",",unlist(fn.args))
  ### remove blanks in top and end position
  fn.args <- gsub("^ *([^ ].*)","\\1",fn.args)
  fn.args <- gsub("(.*[^ ]) *$","\\1",fn.args)
  # arguments without defaults get a "="
  if(!args.found){
    idx <- grep("[=]", invert=TRUE, fn.args)
    fn.args[idx] <- paste(fn.args[idx],"=")
  }
  ## print(fn.args)

@
Für die Verwendung müssen die Argumente und Werte gut zugreifbar sein. Deshalb zerlegen wir
die gefundene Informationen. Außerdem merken wir uns für den Reset-Knopf die ursprünglichen 
Setzungen.
<<extrahiere Argument-Namen und Werte>>=
# Entry Felder schreiben
n.args <- length(fn.args)
fn.arg.values <- fn.arg.names <- rep("  ",n.args)
for( i in 1:n.args ){
  arg <- fn.args[i]
  if( 0 < length(grep("[=]", arg))) fn.arg.names[i] <- sub("[=].*","=",arg) 
  fn.arg.values[i] <- sub(".*[=]","",arg)
}
fn.arg.reset <- fn.arg.values <- sub("^ *([^ ].*[^ ]) *$","\\1",fn.arg.values)
fn.arg.names <- gsub("[= ]","",fn.arg.names)
## print(fn.arg.values); print(fn.arg.names) #; return()

@
Jetzt haben wir unsere Vorarbeiten beendet und können uns der Fenstertechnik zuwenden.
Das Steuerungsfenster wird aus einen Bereich für die Argumente sowie einen für die 
Steuerungsfunktionen bestehen. Dieses wollen wir schon einmal vorbereiten.
In das Top-Level-Fenster bringen wir zwei Frames ein, einen für die Argumente und einen
zweiten für die Steuerungsknöpfe.
<<richte Fenster ein>>=
# Fenster einrichten
Top <- tktoplevel()
tkwm.title(Top,if(missing(main)) paste("function caller:",fn.name) else main)
tkwm.geometry(Top,paste("500x",25+25*n.args,"+10+15",sep=""))
tkpack(arg.frame <- tkframe(Top),fill="x",expand=1) # args
tkpack(org.frame <- tkframe(Top),fill="x",expand=1) # eval, reset, exit
tkpack(a <- tkbutton(org.frame, text = "Exit", width=10, height=1,
                     command = function()tkdestroy(Top)),
                     side = "right")
tkpack(reset.but <- tkbutton(org.frame, text = "Reset", width=10, height=1), side = "right")
tkpack(eval.but  <- tkbutton(org.frame, text = "Eval", width=10, height=1),  side = "left")

@
Es gilt, den Argumenten-Frame zu füllen.
<<fülle den Frame für Argumenten>>=
set.tclvalue <- function(name,value) tclvalue(name)<-as.character(value)
for( i in 1:n.args ){
  # cat("erstelle arg frame i",i)
  tkpack(a <- tkframe(arg.frame),fill="x")
  tkpack(tklabel(a,text = paste(fn.arg.names[i],"="), 
                 width= width.of.label), side="left")
  vari <- paste("ARG",i,collapse="")
  tkpack(ent <- tkentry(a, textvariable = vari, width= width.of.entry), side="right")
  if(i == 1) tkfocus(ent)
  set.tclvalue(vari,as.character(fn.arg.values[i]))
}

@
Die Einträge müssen nur mittels der anfänglichen Werte wieder neu gesetzt werden.
<<setze Reset-Knopf um>>=
tkconfigure(reset.but, command = function(){
  for( i in 1:n.args ){
    vari <- paste("ARG",i,collapse="")
    set.tclvalue(vari,as.character(fn.arg.reset[i]))
  }
})

@
Für die Evaluierung gilt es, den Funktionsaufruf zusammenzusetzen. Als besondere Fälle werden
leere Einträge entfernt. Das Dreipunkt-Argument muss seinen Namen einbüßen.
Verwendet der Anwender keine Argument-Namen, geschieht dieses auf eigene Gefahr.
<<setze Evaluierung um>>=
eval.envir <- parent.frame()
tkconfigure(eval.but, command = function(){
  act.args <- rep(" ",n.args)
  for( i in 1:n.args ){ 
    act.args[i] <- tclvalue( paste("ARG",i,collapse="") )
  }
  act.args <- gsub("^ *([^ ].*)","\\1",act.args)
  act.args <- gsub("(.*[^ ]) *$","\\1",act.args)
  # no args => remove argument
  idx <- 0 == nchar(act.args)
  if( any(idx) ){
    fn.arg.names <- fn.arg.names[!idx]
    act.args <- act.args[!idx]
  }
  # argument name == "..." => remove name
  idx <- "..." == fn.arg.names
  if( any(idx) ) fn.arg.names[idx] <- ""
  fn.arg.names <- ifelse(fn.arg.names == "", "", paste(fn.arg.names,"="))
  # combine call
  fn.call <- paste( fn.name,
                    "(",
                    paste(paste(fn.arg.names,act.args),collapse=", "),
                    ")" )
  cat("evaluation of:\n  ", fn.call,"\n")
  print(try(eval(parse(text=fn.call),envir=eval.envir)))
})

@
\subsection{Help-Page von [[args.player]]}

<<define-args.player-help>>=
\name{args.player}
\alias{args.player}
\title{ An interactive Tcl/Tk Tool for Evaluation of Functions Calls }
\description{
  \code{args.player} is a simple tool for checking the effect of different inputs to
  a function. \code{args.player} creates a small Tcl/Tk widget showing the arguments 
  of the function and the values of the arguments. The values can be modified by typing
  in new values. A click on the \code{Eval} button starts the function with the fixed 
  parameters and you can consider the results.
}
\usage{
args.player(fn.call, width.of.label = 20, width.of.entry = 25, main)
}
\arguments{
  \item{fn.call}{ a function call or a function name }
  \item{width.of.label}{ width of the region used for printing the argument names }
  \item{width.of.entry}{ width of the entry fields for the values of the arguments }
  \item{main}{ title for the widget }
}
\details{
  There are two ways of usage: 
  At first the input of \code{args.player} can be a complete function call.
  Then you should name the arguments correctly to prevent problems of identification.
  Secondly, it is possible to call \code{args.player} with a function name, only.
  In this case arguments will be searched by \code{arg}.
}
\author{ Peter Wolf, pwolf@wiwi.uni-bielefeld.de }
\examples{
# do not run
\dontrun{
    args.player(mean)
}
\dontrun{ 
    fun <- function(n = 100, m=0, sd=1, type="l", bty="n", 
                    xlim = c(0,1), col = "red", main = "title" ){
             x <- rnorm(n,m,sd)
             plot(x, type=type, bty=bty, xlim = xlim, col = col, main = main)
           }
    args.player( 
       fun( n = 100, m = 5, sd = 10, type = "l", bty = "n", 
            xlim = c(0,10), col = "blue", main = "effect of plot parameters" ), 
       main="some plot test" 
    ) 
}
}
\keyword{ utilities }

@
\subsection{Help-Page von [[playground]]}

<<define-playground-help>>=
\name{playground}
\alias{playground}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{playground for testing R code}
\description{
  \code{playground} opens a simple text window for testing R code.
}
\usage{
playground(playground.envir=NULL,code=NULL)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{playground.envir}{if not NULL \code{playground.envir} is used for evaluation}
  \item{code}{if not NULL \code{code} is inserted in the playground}
}
\details{
  Besides your usual work you often need little tools for writing memos or calculating simple
  arithmethic operations. Some times you take a sheet of paper, a pencil or your desk calculator to go ahead. 
  And there are situations in which you would like to have furthers fields for testing simple R codes. Perhaps you will start another R session in parallel for executing your R statements. 

  \code{playground()} is an alternative approach to this problem. After starting the function
  \code{playground} a text field (in a Tcl/Tk widget) is created and you are allow put some R commands
  into this field. At the bottom of the window you find two buttons: one for activating commands and 
  a second one for closing the window. The results will be printed on the current output device.
  All assignments take place in the global envirnment or if \code{revive.env} exists
  the new objects will be created in \code{revive.env}.

  May be you need the field for taking a lot of notes without any calculations only. 
  Anyway, it is no problem to call \code{playground} several times. 

  \code{playground} is in an experimental state yet. So it may be changed later on.
}
\value{
  \code{playground} does not have any explicit result.
}
\references{\url{http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html}}
\author{Hans Peter Wolf}
\examples{
## playground()
}
\keyword{ misc }% at least one, from doc/KEYWORDS

@
\subsection{Help-Page von [[CodeChunkPlayer]]}

<<define-CodeChunkPlayer-help>>=
\name{CodeChunkPlayer}
\alias{CodeChunkPlayer}
\alias{ConstructDemo}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{CodeChunkPlayer, ConstructDemo -- tools for browsing and evaluation of code chunks}
\description{
  \code{CodeChunkPlayer} enables the user to evaluate code chunks interactively.
  \code{ConstructDemo} constructs a demo function from a file containing code chunks.
}
\usage{
  CodeChunkPlayer(file="")
  ConstructDemo(file="")
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{file}{name of rev-, Snw-file or .R-file containing code chunks}
}
\details{
  Both functions need a .R-file that has been generated by \code{tangleR}.
  If the input file is not a .R-file but an rev-file or an Snw-file the input file 
  will be tangled by \code{tangleR} and a .R-file will be generated.  

  \code{CodeChunkPlayer}:
  \code{CodeChunkPlayer} extracts the code chunks stored in the .R-file and 
  creates a Tcl/Tk window to show a code chunk selected by the user. 
  The user can browse through 
  the set of chunks by clicking on \code{NEXT} or b\code{BACK} or by typing
  the number of a code chunk. The code of the selected code chunk is shown 
  in the text field of the player window and may be edited. By clicking button 
  \code{EVALUATE} the code will be evaluated and the output occurs on the R console.

  \code{ConstructDemo}: 
  \code{ConstructDemo} extracts the code chunks of the .R-file and builds a new
  function for browsing through the code chunks. This function will contain the code 
  chunks of the .R-file as well as the logic for browsing and evaluation of selected chunks.
  The function is stored with its call in a file whose name is composed 
  from the name of the input file and the extension \code{.demo.R}. Therefore, you can 
  start the demo function by e.g. \code{source("xyz.demo.R")} and 
  a Tcl/Tk window for code chunk browsing will be created. 
  This window works like the Tcl/Tk window that is generated by \code{CodeChunkPlayer}.  
}
\value{

  \code{CodeChunkPlayer} and \code{ConstructDemo} don't have any explicit result.
}
\references{\url{http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html}}
\author{Hans Peter Wolf}
\examples{
## CodeChunkPlayer()
## ConstructDemo()
}
\keyword{ misc }% at least one, from doc/KEYWORDS

@
\section{Anhang: Installationsskript}
Das Skript [[dorw]] erzeugt aufgerufen in [[install.dir]] die wesentlichen Datei
des Paket-Quellverzeichnisses [[install.dir/relax]]. Es wird generiert durch:
\begin{verbatim}
notangle -Rdefine-dorx relax.rev > install.dir/dorx; chmod +x install.dir/dorx
\end{verbatim}
<<define-dorx>>=
# dorx: Installationsskript fuer relax
# new dorx script:
# notangle -Rdefine-dorx relax.rev > install.dir/dorx; chmod +x install.dir/dorx
# new relax tree
## mkdir relax; mkdir relax/inst; mkdir relax/man; mkdir relax/R; 
## mkdir relax/inst/src; mkdir relax/inst/config; mkdir relax/inst/lib 
## mkdir relax/inst/rev; cp -rp ???/rev/* relax/inst/rev/ 
##          robj.R, rrevbook.rev, roulette.rev and other

[ ! -d relax/R ] && mv relax/r relax/R

notangle -Rdefine-tangleR          ../webR/webR.rev > relax/R/tangleR.R
notangle -Rdefine-tangleR-help ../webR/webR.rev > relax/man/tangleR.Rd
notangle -Rdefine-weaveR         ../webR/webR.rev > relax/R/weaveR.R
notangle -Rdefine-weaveR-help ../webR/webR.rev > relax/man/weaveR.Rd
notangle -Rdefine-weaveRhtml  ../webR/webR.rev >  relax/R/weaveRhtml.R
notangle -Rdefine-weaveRhtml-help ../webR/webR.rev > relax/man/weaveRhtml.Rd

cp -p ../webR/webR.rev  relax/inst/src/webR.rev
cp -p ../webR/webR.pdf  relax/inst/src/webR.pdf

notangle -Rdefine-str-help ../relax.rev > relax/man/str.Rd
notangle -Rdefine-cat-help ../relax.rev > relax/man/cat.Rd
notangle -Rdefine-print-help ../relax.rev > relax/man/print.Rd
notangle -Rdefine-readline-help ../relax.rev > relax/man/readline.Rd
notangle -Rdefine-menu-help ../relax.rev > relax/man/menu.Rd
notangle -Rdefine-step-help ../relax.rev > relax/man/step.Rd
notangle -Rdefine-scan-help ../relax.rev > relax/man/scan.Rd

notangle -Rdefine-args.player-help ../relax.rev > relax/man/args.player.Rd

notangle -Rdefine-relax-help ../relax.rev > relax/man/relax.Rd
notangle -Rdefine-playground-help ../relax.rev > relax/man/playground.Rd
notangle -Rdefine-CodeChunkPlayer-help   ../relax.rev > relax/man/CodeChunkPlayer.Rd
notangle -Rdefine-slider ../slider-function.rev >  relax/R/slider.R
### notangle -Rdefine-slider-function ../relax.rev > relax/R/slider.R
notangle -Rdefine-slider-help   ../relax.rev > relax/man/slider.Rd
notangle -Rdefine-DESCRIPTION  ../relax.rev > relax/DESCRIPTION
notangle -Rdefine-NAMESPACE    ../relax.rev > relax/NAMESPACE
notangle -Rdefine-config-settings ../relax.rev > relax/inst/config/settings.relax
notangle -Rdefine-config-settings ../relax.rev > relax/inst/config/settings.init
notangle ../relax.rev > relax/R/relax.R
cp -p ../relax.rev  relax/inst/src/relax.rev
notangle -RLaTeX-head ../relax.rev > relax/inst/lib/LaTeX-head.tex

# Rcompile=R, Rnew, Rtest
Rcompile=Rtest
$Rcompile CMD check --as-cran relax
# Rnew CMD check relax; 
$Rcompile CMD build relax
rm lib/relax/R/relax.rb
$Rcompile CMD INSTALL --library=lib relax_1.3.13.tar.gz
echo "library(relax,lib.loc=\"lib\"); relax()" | $Rcompile --vanilla

#Rtest CMD check --as-cran relax
#Rtest CMD build relax
#rm lib/relax/R/relax.rdb
#Rtest CMD INSTALL --library=lib relax_1.3.13.tar.gz
#echo "library(relax,lib.loc=\"lib\"); relax()" | Rtest --vanilla


# R CMD check relax;  R CMD build relax
# rm lib/relax/R/relax.rdb
# R CMD INSTALL --library=lib relax_1.3.13.tar.gz
# echo "library(relax,lib.loc=\"lib\"); relax()" | R --vanilla
cd $HOME/R/work/relax/install.dir/lib; 
# zip aus $HOME/bin mit 7z aus p7zip_9.13 
# zip a -r relax_1.3.13.zip relax # a-flag nicht notwendig unter ubuntu
zip -r relax_1.3.13.zip relax
mv relax_1.3.13.zip ..

cd ..
cp relax_1.3.13.tar.gz /home/pwolf/www/public_html/software/relax/R-2.5.0/
cp relax_1.3.13.zip /home/pwolf/www/public_html/software/relax/R-2.5.0/

# exit 0

@
\section{Anhang: Formfill}
Diese Funktion ist entstanden aus [[ff2.rev]].

Ziel der Funktion [[ff.verbatim]] ist die Ersetzung von Anweisungen
durch ihrer Ergebnisse, so daß sich leicht schöne Outputs mit den
Ergebnissen konkreter Datensätze erstellen lassen.

Zur Anwendung sind folgende Regeln zu beachten:
\begin{enumerate}
\item In einer Verbatim-Umgebung ist ein komplettes
\LaTeX-Dokument mit den zu ersetzenden Anweisungen
abzulegen.
\item
Auszuwertende Anweisungen müssen durch zwei Lattenzäune eingeschlossen
werden: [[#]]{\em auszuwertende Anweisung\/}[[#]]
\item
Nach dieser Verbatim-Umgebung muß ein Code-Chunk folgen,
in dem als letztes die Funktion [[ff.verbatim]] aufgerufen wird.
Der Name, den das \TeX-Dokument bekommen soll, ist dieser Funktion
zu übergeben.
\item
Weitere notwendige Operationen können diesem Funktionaufruf vorgelagert
werden.
\item
Nun ist das Papier nur noch in den Reportmanager zu laden und
der Code-Chunk zu aktivieren. Hierdurch wird der \LaTeX-File
mit der Ergebnissen angelegt, formatiert und im Viewer angezeigt.
\end{enumerate}
@
Es folgt ein Beispiel:
{\footnotesize
\begin{verbatim}
Vorspann des rev-File mit beliebigem Text.
@
\begin{VERBATIM}
\documentclass{slides}\usepackage{graphics}
\begin{document}

\begin{center} Regression \end{center}
\footnotesize
Mit diesem Entwurf lassen sich zu beliebigen Daten schnell
Outputs / Folien  mit passenden Regressionsergebnissen erstellen.
\begin{itemize}
\item Mittel der $x$-Werte: #mean(x)#
\item Mittel der $y$-Werte: #mean(y)#
\item
\[
  \hat\beta
       = \frac{ \overline{xy} - \bar x \bar y}{ \bar{x^2} - \bar x^2 }
       = \frac{#mean(x*y)# - #mean(x)*mean(y)# }{ #mean(x*x)# - #mean(x)^2# }
       = \frac{#mean(x*y)  -  mean(x)*mean(y)# }{ #mean(x*x)  - mean(x)^2# }
       = #b.dach <- (mean(x*y)-mean(x)*mean(y)) / (mean(x*x)-mean(x)^2)#
\]
\item $ \hat\alpha = \bar y - \hat\beta \bar x = #mean(y)-b.dach*mean(x)# $ .
\end{itemize}

\begin{center}
\includegraphics[width=10cm,height=6cm]{file=tmp2.ps}
\end{center}

Wie ist die Summe der ersten 100 Zahlen? Antwort: #sum(1:100)#

Hier endet der mit Ergebnissen zu versehende Text.


@<<*>>=
n<-100; a<-10; b<-0.7; sigma.u<-5
x<-1:n; y<-a+b*x+ rnorm(n,sd=sigma.u)
plot(x,y); abline(lsfit(x,y))
dev.copy(postscript,"tmp2.ps",horizontal=FALSE,width=psdesignwidth.sys,height=psdesignheight.sys)
dev.off()
ff.verbatim("testtest")

@@
Ende des ff.verbatim-Beispiels.
\end{verbatim}
} % end of footnotesize
@
%%%%%%% start of ../R/formfill/ffverb/ffverb.sch  %%%%%%%%%%%%%%
Die [[repeat]]-Schleife ist identisch mit dem Kern von [[ff2.rev]].
Davor wird nur der Ort des aktivierten Chunks festgestellt und die
davorstehende Verbatim-Umgebung gesucht, die dann auf [[tz]]
abgelegt wird. Am Ende sind Systemaufrufe zum Texen und Anzeigen
eingefügt.
<<im Moment unused: definiere [[ff.verbatim]] für [[relax]]>>=
ff.verbatim<-
function(out.file="tmpout.tex",path="",digits=4,escape.symbol="#"){
  ##lese Paperfenster auf [[REVFILE]] ein>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  REVFILE<-worktext
    <<lese Arbeitsfenster auf [[worktext]] ein>>
   <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  if(0==length(line))  return()
  if(2 >length(line<-grep("{verbatim}", REVFILE[1:line]  )))return()
  line <- rev(line) [2:1]+c(1,-1); lines<-line[1]:line[2]
   if(0==length(tz <-REVFILE[lines])) return()
  cat("processing for   ",out.file,": starts   \n")
  ff.begin.end<-grep(escape.symbol,tz)
  cat("  lines with replacements: \n")
  cat(paste("  ",tz[ff.begin.end],"\n"))
  repeat{
   if(length(ff.begin.end)==0) break
   ff.repl <-tz[ff.begin.end[1]]
   ff.chars<-substring(ff.repl,1:nchar(ff.repl),1:nchar(ff.repl))
   ff.found<-T
   ff.positions<-seq(ff.chars)[ff.chars==escape.symbol]
   if(length(ff.positions)<2)           ff.found<-F
   if(ff.chars[ff.positions[1]+1]==":") ff.found<-F
   if(0!=length(ff.positions)%%2)       ff.found<-F
   if(ff.found){
     ff.positions<-matrix(ff.positions,2)
     ff.eval <-substring(ff.repl,ff.positions[1,]+1,ff.positions[2,]-1)
     ff.out<-NULL
     for(ff.e in ff.eval){
       cat("  expression to be evaluated / replaced:", ff.e, "\n")
       ff.out<-c(ff.out,eval(parse(text=ff.e),envir=revive.env))
       cat("  evaluation done, result: ",ff.out[length(ff.out)]," \n")
     }
     if(is.numeric(ff.out)) ff.out<-as.character(signif(ff.out,digits))
     ff.chars<-c("a",ff.chars[0==cumsum(ff.chars==escape.symbol)%%2],"z")
     ff.chars<-paste(ff.chars,collapse="")
     ff.chars<-strsplit(ff.chars,escape.symbol)[[1]]
     ff.chars<-rbind(c(" ",ff.out),ff.chars)[-1]
     ff.chars<-paste(ff.chars,collapse="")
     ff.repl <-substring(ff.chars,2,nchar(ff.chars)-1)
     tz[ff.begin.end[1]]<-ff.repl
     cat("  REPLACED line:",ff.repl,"\n")
   }
   ff.begin.end<-ff.begin.end[-1]
  }
  cat("replacements for ",out.file,": finished\n")
  if(0<nchar(path)) out.file<-paste(path,.Platform$file.sep,out.file,sep="")
  tex.file <- paste(out.file,".tex",sep="")
  get("cat",pos="package:base")(paste(tz,"\n"),file=tex.file,sep="")
  cat("output file      ",tex.file," generated\n")
  if(<<das OS ist Windows>>){
    system(paste("latex ",tex.file)); system(paste("yap",out.file))
  }else{
    system(paste("echo q | latex ",tex.file," ; xdvi ",out.file,"&"))
  }
  "formfillverb beendet"
}
@
%%%%%%% end of ff.verbatim

@
\section{Umstellung auf R-2.0.0}

Wie schnell erkannt, lief die damalige Version von rwined nicht unter R-2.0.0
Deshalb wurden ein paar kleine Änderungen notwendig, die hier
beschrieben werden.

\begin{verbatim}
0. Sicherung der alten Version von rwined

  cp rwined.rev versions/rwined.040922.rev

  gehe nach install.dir und dort nach rwined
  das rwined-Verzeichnis wird die Quelldateien für das Paket aufnehmen.

1. Erstellung einer geeigneten Paketstruktur in:
   /home/wiwi/pwolf/work/relax/install.dir/rwined
DESCRIPTION:

Package: rwined
Version: 0.93
Date: 2004-10-18
Title: relax
Author: Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Maintainer: Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Depends: tcltk
Description: package rwined contains full screen R editor rwined()
License: GPL version 2 or newer
URL: http://www2.wiwi.uni-bielefeld.de/~wolf

2. lege inst-Datei an und platziere dort revweb-Kram und Materialien.

(mkdir) R;   hier kommen alle *.R-Dateien hinein, die später in dem
Paket sein sollen.

(mkdir) inst; hier kommen alle Dateien hinein, die später noch existieren
sollen:

bin  config  lib  rev  rtrevweb

3. verschiebe das Revbook z.B.\ nach

mv rbo/rev/rbk.rev inst/rev/rbk.rev
bzw.
mv rev/*rev inst/rev

4. Check und Bau in install.dir: ( ohne rwined in rwined/R! )

R CMD check rwined; R CMD build rwined

5. Installation:

R CMD INSTALL --library=lib rwined_0.93.tar.gz

6. Lauftest aus dem Verzeichnis .. \verb+$HOME/work/relax/install.dir+

library(rwined,lib.loc="./lib")

-> alle Dinge aus rbo sind angekommen.

7. Hinweise

Warnings: S3 inconsistency: Punkte in Funktionsnamen


Fehler: tmp-Datei wird zum gecheckt: ist aber Quatsch,
da tmp-Datei erst zur Laufzeit benötigt wird.

8. Bewegung von @<<ermittle Namen einer Sink-Datei>> und
 @<<ermittle Namen einer temporären Datei>>  in Funktion rwined
Ablage in der Systemumgebung: revive.sys
@
@<<ermittle Namen einer temporären Datei>>=
tmp.file.name <- tempfile("rt-tmp")
assign(tmp.file.name,"tmp.file.name",envir=revive.sys)
@
@<<tmp>>=
get("tmp.file.name",envir=revive.sys)

@<<ermittle Namen einer Sink-Datei>>=
tmp.sink.name <- tempfile("rt-sink")
assign(tmp.sink.name,"tmp.sink.name",envir=revive.sys)
@
vorher: "r.tmp"
@<<tmp.sink>>=
get("tmp.file.name",envir=revive.sys)

tmp.sink wird verwendet in
fEvalRCode, SaveDiffReport, print, EditReport

9. Entfernung von
library("rbo",lib.loc=.find.package(c(@<<rwined>>)[1]))
aus rwined()


10. Verschiebung der Ueberlagerung von cat, print, menu, scan und readline
in die Funktion rwined mit anschliessender Zuordnung in das Paket zur
Laufzeit Muster:

assign("cat",cat,pos=@<<stelle Nummer von [[rwined]] im Suchpfad fest>>)

Zur Sicherheit werden vor rwined Objekte gleichen namens erzeugt:

cat<-print<-menu<-scan<-readline<-1 besser bekommen alte Definitionen

-> check build und Install, library funktionieren, Oberfläche wird erstellt!!
und auch der Code

11. TCLTK-image-jpeg funktioniert nicht:

Error in structure(.External("dotTclObjv", objv, PACKAGE = "tcltk"), class = "tclObj") :
        [tcl] image file format "jpeg" is not supported.

@<<lade tcl/tk... >> ausgewechselt gegen @<<lade img fuer tcltk>>
und in rwined verschoben

12. TeX-Head nicht ans Ende -> nach aktuellen Chunk

13. Konfiguration fuer Systemspezialitäten zentral
... ganz vorn als erstes

14. Unterverzeichnisse z.B. rev/* werden nicht uebernommen.

Loesung: platziere die Verzeichnisse in das Verzeichnis "inst"!

15. Das Data-menu war unbrauchbar.

Grund es wurde nach rbo gesucht, diese Datei war aber nicht mehr da.

16. Experimentell neue Parameter psdesignheight /width eingefuehrt.

XX:
a) R CMD check rwined; b) R CMD build rwined
c) R CMD INSTALL --library=lib rwined_0.91.tar.gz

17. c) R CMD INSTALL --library=lib rwined_0.92.tar.gz simuliert durch

 c1) per Hand (winzip) gz-File ausgepackt
 c2) Alles, was unter Verzeichnis "inst" zu finden war, einen hoeher gehaengt
 c3) Build-Zeile in DESCRIPTION eingefügt
 c4) rwined/R/rwined.R umbenannt in rwined/R/rwined
 c5) lokale Fehlerbehebung:  rtrevweb.bin.path -> binpath in rtrevweb

18. stilgerechter Ladeversuch unter  Windows

19. Variablenfehler in rtrevweb beheben.

20. Dateistruktur fuer windows anpassen, aufbauen: rrtcl, rtrevweb

21. chmod: 644 fuer DESCRIPTION, 755 fuer alle andere Dinge
\end{verbatim}
Inzwischen ist rrtcl/lib/img* unter lib gehängt und revweb bzw.\ rtrevweb nicht mehr nötig.

@
\section{Anhang: Installation}
Mit Übergang auf R-2.0.0 ist die Struktur vereinfacht und für
die Windows / Linux\_Version einheitlich geworden.
Damit die Verzeichnisse so stehen wie hier abgedruckt, muss
alles (bis auf R, man und DESCRIPTION unter inst stehen).
\begin{verbatim}
|
+-- relax                  lokale Bibliothek relax
    |
    +-- DESCRIPTION           Kurzbeschreibung wegen Package-Bedingungen
    |
    +-- INDEX             Kurzindex
    |
    +-- R                     Code-Verzeichnis der Bibliothek relax
    |   |
    |   +-- relax.R          Code der Bibliothek relax
    |   |
    |   +-- weaveR.R          eigene weave-Funktion
    |   |
    |   +-- tangleR.R          eigene tangle-Funktion
    |   |
    |   +-- slider.R          eigene slider-Funktion
    |
+-+
|
+ inst:
    |
    +-- config             Verzeichnis fuer Pfadeinstellungen
    |   |
    |   +-- settings.relax         Datei mit Pfadeinstellungen
    |
    +-- lib            Bibliothek mit diversen Dateien
    |   |
    |   +-- img1.3  tcltk Paket img1.3
    |   |
    |   +-- LaTeX-head.tex  gnoweb.sty  gpl.txt  img1.3  noweb.sty
    |
    +-- man        Help-Pages
    |   |
    |   +-- relax.Rd, slider.Rd, tangleR.Rd, weaveR.Rd
    |
    +-- rev                   wiederbelebbare Materialien
    |   |
    |   +-- rrevbook.rev, roulette.rev, robj.R
    |
    +-- src    Quelldateien
        |
        +-- relax.rev Quelldatei des Pakets
        |
        +-- webR.rev Quelldatei zur eigenen Webfunktionen
     
...+-- old -- rtrevweb              rtrevweb-Arbeitsverzeichnis mit Funktione
                    |
                    +-- sta.txt, ste.txt, end.txt, delcopy.awk, umlaute.awk,
                          ausblend.awk, twebnum.awk, start.awk, tohtm.awk,
                          markup.exe, gawk.exe, nt.exe, iconx.exe, totex.exe, noidx.exe,
                          rtrevweb.sch
\end{verbatim}


@
Erwähnenswert ist nur noch die mitgelieferte Readme-Datei:

\begin{verbatim}
Installationshinweise:

 1. am besten installieren unter

     ..\rw2001\library

    bei anderen Versionen entsprechend.

 2. Der Autor übernimmt keine Gewaehr dafür, 
 dass die Software das, was beschrieben wurde, tut und
 dass die Eigenschaften wirklich so wie beschrieben sind.
 Er übernimmt auch keine Haftung für irgendwelche Fehler oder
 Probleme die aus dem Gebrauch oder dem Umgang mit der
 Software resultieren.

 Hans Peter Wolf
\end{verbatim}

@
\subsection{Eine Kurzbeschreibung im Ansatz}
<<zeige Kurzbeschreibung>>=
cat(  "Installationsleitfaden fuer Linux und Windows: Version vom 28.02.05",
      "=========================================================",
      "install R", "  how to get it?  http://www.r-project.org/", 
      "install relax-package","  how to get it?  ",  
      "    http://www.wiwi.uni-bielefeld.de/com/wolf/software/relax.html",

      "start R: ",  " click R-icon or  R --vanilla",  "load relax packages",  "  > library(relax)",
      "start report manager",  "  > relax()    ",sep="\n")

@
\section{Zum Schluß}
<<*>>=
## DEBUG<<-TRUE
cat("relax geladen!\n")
cat("R-Editor  mit  relax()  starten!\n")
## cat("Soll der Manager gestartet werden? (n=nein)\n")
## if("n"!=substring(readline(),1,1)) r()

@
\section{Anhang: Übersicht der [[noweb]] Code-Chunks}

\nowebchunks


@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
